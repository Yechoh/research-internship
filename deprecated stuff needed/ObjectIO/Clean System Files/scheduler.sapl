|| ?module? scheduler


scheduler.openLocalIO !ioState_0 !local_1 = iostate._CProcess (Data.Maybe.Just local_1) ioState_0
scheduler.createNewIOSt !pAtts_0 !ioDef_1 ioDefAbout_2 !nr_3 !parent_4 !guishare_5 !isSubProcess_6::B !document_7 !ioKind_8 = iostate.emptyIOSt nr_3 parent_4 guishare_5 document_7 ioKind_8 pAtts_0 ioDef_1 Data.Maybe.Nothing
scheduler.initContext !ioDef_0 !ioDefAbout_1 !local_2 !document_3 !ioKind_4 !world_5 = let w_1_0 = world.loadWorld world_5, _x_1_1::I = ostime.osGetTime (ostoolbox.osInitToolbox 0) in <{_Tuple2!3}> (scheduler._Context (scheduler._Environs osevent.osNewEvents (world.storeWorld w_1_0 world_5)) (_predefined._Cons (processstack._ProcessShowState systemid.initSystemId (<{processstack.==_6}> ioKind_4 processstack.InteractiveProcess) ioKind_4) _predefined._Nil) systemid.initSystemId (roundrobin.toRR _predefined._Nil (_predefined._Cons (scheduler.openLocalIO (scheduler.createNewIOSt _predefined._Nil ioDef_0 ioDefAbout_1 systemid.initSystemId Data.Maybe.Nothing Data.Maybe.Nothing True document_3 ioKind_4) local_2) _predefined._Nil)) Data.Maybe.Nothing receivertable.initialReceiverTable timertable.initialTimerTable id.initialIdTable (select _x_1_1::_Tuple2 0) w_1_0 0) (select _x_1_1::_Tuple2 1)
<{scheduler.initContext`}> !world_0 = let w_1_0 = world.loadWorld world_0, _x_1_1::I = ostime.osGetTime (ostoolbox.osInitToolbox 0) in <{_Tuple2!3}> (scheduler._Context (scheduler._Environs osevent.osNewEvents (world.storeWorld w_1_0 world_0)) _predefined._Nil systemid.initSystemId (roundrobin.toRR _predefined._Nil _predefined._Nil) Data.Maybe.Nothing receivertable.initialReceiverTable timertable.initialTimerTable id.initialIdTable (select _x_1_1::_Tuple2 0) w_1_0 0) (select _x_1_1::_Tuple2 1)
scheduler.toTimerEvent_53 !timertable_0 = let _x_1_0 = timertable.getActiveTimerInTimerTable timertable_0 in <{_Tuple2!3}> (deviceevents.ScheduleTimerEvent (Data.Maybe.fromJust (select _x_1_0::_Tuple2 0))) (select _x_1_0::_Tuple2 1)
scheduler.toASyncEvent_52 !rid_0 !receivertable_1 = let !_x_1_0 = receivertable.getReceiverTableEntry rid_0 receivertable_1, !rte_1_1 = Data.Maybe.fromJust (select _x_1_0::_Tuple2 0), !rte_1_2 = update rte_1_1::receivertable._ReceiverTableEntry [2:<{StdInt.-_7}> (select rte_1_1::receivertable._ReceiverTableEntry 2) 1], !receivertable_1_3 = receivertable.setReceiverTableEntry rte_1_2 (select (receivertable.removeReceiverFromReceiverTable rid_0 (select _x_1_0::_Tuple2 1))::_Tuple2 1) in <{_Tuple2!3}> (deviceevents.ScheduleMsgEvent (deviceevents.ASyncMessage (receivermessage._ASyncMessage (select rte_1_2::receivertable._ReceiverTableEntry 0)))) receivertable_1_3
scheduler.zerotimelimit =: let x_1_0::I = 1, y_1_1::I = <{StdInt./_10}> 1000 20 in ostime.fromInt_9 (<{scheduler._c;51;16_121}> (<{StdInt.<_17}> x_1_0 y_1_1) y_1_1 x_1_0)
<{scheduler._c;51;16_121}>::I !_x_0::B y_1::I x_2::I = case _x_0 (True -> y_1) (_ -> x_2)
scheduler.checkOSZeroTimerEvent_51 !zerotimer_0::B !osTime_1 !osevent_2 !osEvents_3 = case (StdBool.not zerotimer_0) (True -> osEvents_3) (False -> let maybe_zerotimer_start_2_0 = osevent.getOSZeroTimerStartTime osevent_2 in case (Data.Maybe.isNothing maybe_zerotimer_start_2_0) (True -> osevent.osAppendEvents (_predefined._Cons (osevent.createOSZeroTimerEvent osTime_1) _predefined._Nil) osEvents_3) (False -> case (StdBool.not (<{ostime.<_7}> scheduler.zerotimelimit (<{ostime.-_6}> osTime_1 (Data.Maybe.fromJust maybe_zerotimer_start_2_0)))) (True -> osevent.osAppendEvents (_predefined._Cons osevent_2 _predefined._Nil) osEvents_3) (False -> osEvents_3) ) ) 
scheduler.toSchedulerEvent !osevent_0 !receivertable_1 !timertable_2 !osTime_3 !osEvents_4 = case (osevent.osEventIsUrgent osevent_0) (True -> <{_Tuple4!15}> (deviceevents.ScheduleOSEvent osevent_0 _predefined._Nil) receivertable_1 timertable_2 osEvents_4) (False -> let _x_2_0::I = timertable.getTimeIntervalFromTimerTable timertable_2, maybe_timer_2_1 = select _x_2_0::_Tuple2 0, sure_timer_2_2::B = scheduler._f122_122 (Data.Maybe.isJust maybe_timer_2_1) interval_2_7, _x_2_3 = receivertable.getActiveReceiverTableEntry receivertable_1, maybe_receiver_2_4 = select _x_2_3::_Tuple2 0, sure_receiver_2_5::B = Data.Maybe.isJust maybe_receiver_2_4, _x_2_6 = Data.Maybe.fromJust maybe_timer_2_1, interval_2_7 = select _x_2_6::_Tuple2 1 in case (case (StdBool.not sure_timer_2_2) (True -> StdBool.not sure_receiver_2_5) (False -> False) ) (True -> <{_Tuple4!15}> (deviceevents.ScheduleOSEvent osevent_0 _predefined._Nil) (select _x_2_3::_Tuple2 1) (select _x_2_0::_Tuple2 1) osEvents_4) (False -> case (case sure_timer_2_2 (True -> sure_receiver_2_5) (False -> False) ) (True -> case (StdInt.isEven_18 (ostime.toInt_8 osTime_3)) (True -> let _x_6_0 = scheduler.toTimerEvent_53 (select _x_2_0::_Tuple2 1) in <{_Tuple4!15}> (select _x_6_0::_Tuple2 0) (select _x_2_3::_Tuple2 1) (select _x_6_0::_Tuple2 1) (scheduler.checkOSZeroTimerEvent_51 (select _x_2_6::_Tuple2 0) osTime_3 osevent_0 osEvents_4)) (False -> let _x_6_0 = scheduler.toASyncEvent_52 (Data.Maybe.fromJust maybe_receiver_2_4) (select _x_2_3::_Tuple2 1) in <{_Tuple4!15}> (select _x_6_0::_Tuple2 0) (select _x_6_0::_Tuple2 1) (select _x_2_0::_Tuple2 1) (scheduler.checkOSZeroTimerEvent_51 (select _x_2_6::_Tuple2 0) osTime_3 osevent_0 osEvents_4)) ) (False -> case sure_timer_2_2 (True -> let _x_6_0 = scheduler.toTimerEvent_53 (select _x_2_0::_Tuple2 1) in <{_Tuple4!15}> (select _x_6_0::_Tuple2 0) (select _x_2_3::_Tuple2 1) (select _x_6_0::_Tuple2 1) (scheduler.checkOSZeroTimerEvent_51 (select _x_2_6::_Tuple2 0) osTime_3 osevent_0 osEvents_4)) (False -> let _x_6_0 = scheduler.toASyncEvent_52 (Data.Maybe.fromJust maybe_receiver_2_4) (select _x_2_3::_Tuple2 1) in <{_Tuple4!15}> (select _x_6_0::_Tuple2 0) (select _x_6_0::_Tuple2 1) (select _x_2_0::_Tuple2 1) osEvents_4) ) ) ) 
scheduler._f122_122::B !_x_0::B interval_1::I = case _x_0 (True -> StdBool.not (<{StdInt.<_17}> 0 interval_1)) (_ -> False)
scheduler.processQuitted_54 !local_0 = case local_0 (iostate._CProcess localState_1_0 local_1_1 -> let _x_2_0 = iostate.ioStClosed local_1_1 in <{_Tuple2!3}> (select _x_2_0::_Tuple2 0) (update local_0::iostate._CProcess [1:select _x_2_0::_Tuple2 1])) 
scheduler.processModal_55 !local_0 = case local_0 (iostate._CProcess localState_1_0 local_1_1 -> let _x_2_0 = iostate.ioStHasDevices local_1_1 in <{_Tuple2!3}> (select _x_2_0::_Tuple2 0) (update local_0::iostate._CProcess [1:select _x_2_0::_Tuple2 1])) 
scheduler.rsIsBlocked !_x_0 = case _x_0 (iostate.Blocked ioid_1_0 -> <{_Tuple2!1}> True ioid_1_0) (_ -> <{_Tuple2!1}> False systemid.nullSystemId)
scheduler.cSwitchIn !local_0 !_x_1 !ioState_2 = case _x_1 (scheduler._Context _x_1_0 cProcessStack_1_1 cMax_1_2 cProcesses_1_3 cModalProcess_1_4 cReceiverTable_1_5 cTimerTable_1_6 c_1_7 cOSTime_1_8 c_1_9 cOSToolbox_1_10 -> case _x_1_0 (scheduler._Environs envsEvents_2_0 envsWorld_2_1 -> let _x_3_0 = iostate.ioStSwapIO (_Tuple2 (_predefined._Cons envsWorld_2_1 _predefined._Nil) cProcesses_1_3) (iostate.ioStSetMaxIONr cMax_1_2 (iostate.ioStSetEvents envsEvents_2_0 (iostate.ioStSetProcessStack cProcessStack_1_1 ioState_2))) in <{_Tuple2!3}> (select _x_3_0::_Tuple2 0) (iostate._PSt local_0 (iostate.ioStSetIdSeed c_1_9 (iostate.ioStSetOSTime cOSTime_1_8 (iostate.ioStSetTimerTable cTimerTable_1_6 (iostate.ioStSetReceiverTable cReceiverTable_1_5 (iostate.ioStSetIdTable c_1_7 (iostate.ioStSetIOIsModal cModalProcess_1_4 (select _x_3_0::_Tuple2 1))))))))) ) 
<{scheduler.removeIOIdFromLocals`_64}> !me_0 !parent_1 !_x_2 = case _x_2 (_predefined._Cons process_1_0 processes_1_1 -> case process_1_0 (iostate._CProcess localState_2_0 ioState_2_1 -> let _x_3_0 = iostate.ioStGetIOId ioState_2_1 in case (<{systemid.==_5}> parent_1 (select _x_3_0::_Tuple2 0)) (True -> let _x_5_0 = iostate.ioStGetSubProcessIds (select _x_3_0::_Tuple2 1) in <{_Tuple2!3}> True (_predefined._Cons (iostate._CProcess localState_2_0 (iostate.ioStSetSubProcessIds (select (commondef.remove (<{systemid.==_5}> me_0) (commondef.dummy "removeIOIdFromLocals") (select _x_5_0::_Tuple2 0))::_Tuple3 2) (select _x_5_0::_Tuple2 1))) processes_1_1)) (False -> let _x_5_0 = <{scheduler.removeIOIdFromLocals`_64}> me_0 parent_1 processes_1_1 in <{_Tuple2!3}> (select _x_5_0::_Tuple2 0) (_predefined._Cons (iostate._CProcess localState_2_0 (select _x_3_0::_Tuple2 1)) (select _x_5_0::_Tuple2 1))) ) ) (_ -> <{_Tuple2!3}> False _predefined._Nil)
scheduler.removeIOIdFromLocals_65 !me_0 !parent_1 !locals_2 = let _x_1_0::B = roundrobin.fromRR locals_2, done_1_1 = select _x_1_0::_Tuple2 0, _x_1_2 = <{scheduler.removeIOIdFromLocals`_64}> me_0 parent_1 done_1_1, removed_1_3 = select _x_1_2::_Tuple2 0 in case removed_1_3 (True -> <{_Tuple2!3}> removed_1_3 (roundrobin.toRR (select _x_1_2::_Tuple2 1) (select _x_1_0::_Tuple2 1))) (False -> let _x_3_0 = <{scheduler.removeIOIdFromLocals`_64}> me_0 parent_1 (select _x_1_0::_Tuple2 1) in <{_Tuple2!3}> (select _x_3_0::_Tuple2 0) (roundrobin.toRR (select _x_1_2::_Tuple2 1) (select _x_3_0::_Tuple2 1))) 
scheduler.schedulerFatalError !rule_0 !message_1 = commondef.error rule_0 "scheduler" message_1
scheduler.removeIOIdFromParentProcess !me_0 !ioState_1 = let _x_1_0 = iostate.ioStGetParentId ioState_1, opt_parent_1_1 = select _x_1_0::_Tuple2 0 in case (Data.Maybe.isNothing opt_parent_1_1) (True -> select _x_1_0::_Tuple2 1) (False -> let parent_3_0 = Data.Maybe.fromJust opt_parent_1_1, ioState_3_1 = select _x_1_0::_Tuple2 1, _x_3_2 = iostate.ioStGetCProcesses ioState_3_1, locals_3_3 = select _x_3_2::_Tuple2 0, _x_3_4 = scheduler.removeIOIdFromLocals_65 me_0 parent_3_0 locals_3_3 in case (select _x_3_4::_Tuple2 0) (True -> iostate.ioStSetCProcesses (select _x_3_4::_Tuple2 1) (select _x_3_2::_Tuple2 1)) (False -> scheduler.schedulerFatalError "CloseProcess" "parent process could not be located") ) 
scheduler.closeVirtualProcess_57 !pState_0 = case pState_0 (iostate._PSt ls_1_0 io_1_1 -> let _x_2_0 = iostate.ioStGetSubProcessIds io_1_1 in case (StdBool.not (StdList.isEmpty (select _x_2_0::_Tuple2 0))) (True -> update pState_0::iostate._PSt [1:select _x_2_0::_Tuple2 1]) (False -> let _x_4_0 = iostate.ioStGetProcessStack (select _x_2_0::_Tuple2 1), _x_4_1 = iostate.ioStGetIOId (select _x_4_0::_Tuple2 1), nr_4_2 = select _x_4_1::_Tuple2 0 in update pState_0::iostate._PSt [1:iostate.ioStSetRuntimeState iostate.Closed (scheduler.removeIOIdFromParentProcess nr_4_2 (iostate.ioStSetProcessStack (select (processstack.removeProcessShowState nr_4_2 (select _x_4_0::_Tuple2 0))::_Tuple2 1) (select _x_4_1::_Tuple2 1)))]) ) 
scheduler.cSwitchOut !ioContext_0 !_x_1 = case _x_1 (iostate._PSt ls_1_0 io_1_1 -> let _x_2_0 = iostate.ioStGetOSTime io_1_1, _x_2_1 = iostate.ioStGetTimerTable (select _x_2_0::_Tuple2 1), _x_2_2 = iostate.ioStGetIdSeed (select _x_2_1::_Tuple2 1), _x_2_3 = iostate.ioStGetReceiverTable (select _x_2_2::_Tuple2 1), _x_2_4 = iostate.ioStGetIdTable (select _x_2_3::_Tuple2 1), _x_2_5 = iostate.ioStGetIOIsModal (select _x_2_4::_Tuple2 1), _x_2_6 = iostate.ioStSwapIO ioContext_0 (select _x_2_5::_Tuple2 1), _x_2_7 = iostate.ioStGetMaxIONr (select _x_2_6::_Tuple2 1), _x_2_8 = iostate.ioStGetProcessStack (select _x_2_7::_Tuple2 1), _x_2_9 = iostate.ioStGetEvents (select _x_2_8::_Tuple2 1), ioContext_2_10 = select _x_2_6::_Tuple2 0 in <{_Tuple3!7}> ls_1_0 (scheduler._Context (scheduler._Environs (select _x_2_9::_Tuple2 0) (StdList.hd (select ioContext_2_10::_Tuple2 0))) (select _x_2_8::_Tuple2 0) (select _x_2_7::_Tuple2 0) (select ioContext_2_10::_Tuple2 1) (select _x_2_5::_Tuple2 0) (select _x_2_3::_Tuple2 0) (select _x_2_1::_Tuple2 0) (select _x_2_4::_Tuple2 0) (select _x_2_0::_Tuple2 0) (select _x_2_2::_Tuple2 0) 0) (select _x_2_9::_Tuple2 1)) 
<{scheduler.c;347;69_56}> !g_l_0 = <{scheduler.g_c1;347;74_123}> g_l_0
<{scheduler.g_c1;347;74_123}> !g_l_0 = case g_l_0 (_predefined._Cons df_1_0 g_t_1_1 -> _predefined._Cons (_Tuple2 (select df_1_0::devicefunctions._DeviceFunctions 3) (select df_1_0::devicefunctions._DeviceFunctions 4)) (<{scheduler.c;347;69_56}> g_t_1_1)) (_ -> _predefined._Nil)
scheduler.mergeMsgEventIntoSchedulerEvent_58 !_x_0 !_x_1 = case _x_0 (deviceevents.ReceiverEvent msgEvent_1_0 -> deviceevents.ScheduleMsgEvent msgEvent_1_0) (_ -> _x_1)
scheduler.handleEventForDevices !_x_0 !eventDone_1::B !schedulerEvent_2 pState_3 = case _x_0 (_predefined._Cons _x_1_0 do_1_1 -> case _x_1_0 (_Tuple2 mapDeviceEvent_2_0 doDevice_2_1 -> case eventDone_1 (True -> <{_Tuple3!3}> eventDone_1 schedulerEvent_2 pState_3) (False -> let _x_4_0 = StdPSt.accPIO iostate.ioStClosed pState_3 in case (select _x_4_0::_Tuple2 0) (True -> <{_Tuple3!3}> True schedulerEvent_2 (select _x_4_0::_Tuple2 1)) (False -> let pState_6_0 = select _x_4_0::_Tuple2 1, _x_6_1 = mapDeviceEvent_2_0 schedulerEvent_2 pState_6_0 in case (StdBool.not (select _x_6_1::_Tuple4 0)) (True -> scheduler.handleEventForDevices do_1_1 eventDone_1 (select _x_6_1::_Tuple4 2) (select _x_6_1::_Tuple4 3)) (False -> let okDeviceEvent_8_0 = select _x_6_1::_Tuple4 1 in case (Data.Maybe.isNothing okDeviceEvent_8_0) (True -> scheduler.handleEventForDevices do_1_1 True (select _x_6_1::_Tuple4 2) (select _x_6_1::_Tuple4 3)) (False -> let _x_10_0 = doDevice_2_1 (Data.Maybe.fromJust okDeviceEvent_8_0) (select _x_6_1::_Tuple4 3) in scheduler.handleEventForDevices do_1_1 True (scheduler.mergeMsgEventIntoSchedulerEvent_58 (select _x_10_0::_Tuple2 0) (select _x_6_1::_Tuple4 2)) (select _x_10_0::_Tuple2 1)) ) ) ) ) ) (_ -> <{_Tuple3!3}> eventDone_1 schedulerEvent_2 pState_3)
scheduler.handleEventForLocalIO !eventDone_0::B !schedulerEvent_1 !_x_2 !context_3 = case _x_2 (iostate._CProcess opt_local_1_0 ioState_1_1 -> let _x_2_0 = iostate.ioStGetRuntimeState ioState_1_1 in case (select (scheduler.rsIsBlocked (select _x_2_0::_Tuple2 0))::_Tuple2 0) (True -> <{_Tuple4!15}> eventDone_0 schedulerEvent_1 (iostate._CProcess opt_local_1_0 (select _x_2_0::_Tuple2 1)) context_3) (False -> let ioState_4_0 = select _x_2_0::_Tuple2 1, _x_4_1 = iostate.ioStGetInitIO ioState_4_0, init_4_2 = select _x_4_1::_Tuple2 0, ioState_4_3 = select _x_4_1::_Tuple2 1, _x_4_4 = scheduler.cSwitchIn (Data.Maybe.fromJust opt_local_1_0) context_3 ioState_4_3, pState_4_5 = select _x_4_4::_Tuple2 1, pState_4_6 = init_4_2 pState_4_5, _x_4_7 = StdPSt.accPIO iostate.ioStGetProcessKind pState_4_6 in case (<{processstack.==_6}> (select _x_4_7::_Tuple2 0) processstack.VirtualProcess) (True -> let _x_6_0 = scheduler.cSwitchOut (select _x_4_4::_Tuple2 0) (scheduler.closeVirtualProcess_57 (select _x_4_7::_Tuple2 1)) in <{_Tuple4!15}> eventDone_0 schedulerEvent_1 (iostate._CProcess (Data.Maybe.Just (select _x_6_0::_Tuple3 0)) (select _x_6_0::_Tuple3 2)) (select _x_6_0::_Tuple3 1)) (False -> let pState_6_0 = select _x_4_7::_Tuple2 1, _x_6_1 = StdPSt.accPIO iostate.ioStClosed pState_6_0 in case (select _x_6_1::_Tuple2 0) (True -> let _x_8_0 = scheduler.cSwitchOut (select _x_4_4::_Tuple2 0) (select _x_6_1::_Tuple2 1) in <{_Tuple4!15}> eventDone_0 schedulerEvent_1 (iostate._CProcess (Data.Maybe.Just (select _x_8_0::_Tuple3 0)) (select _x_8_0::_Tuple3 2)) (select _x_8_0::_Tuple3 1)) (False -> let _x_8_0 = StdPSt.accPIO iostate.ioStGetDeviceFunctions (select _x_6_1::_Tuple2 1), _x_8_1 = scheduler.handleEventForDevices (<{scheduler.c;347;69_56}> (select _x_8_0::_Tuple2 0)) eventDone_0 schedulerEvent_1 (select _x_8_0::_Tuple2 1), _x_8_2 = scheduler.cSwitchOut (select _x_4_4::_Tuple2 0) (select _x_8_1::_Tuple3 2) in <{_Tuple4!15}> (select _x_8_1::_Tuple3 0) (select _x_8_1::_Tuple3 1) (iostate._CProcess (Data.Maybe.Just (select _x_8_2::_Tuple3 0)) (select _x_8_2::_Tuple3 2)) (select _x_8_2::_Tuple3 1)) ) ) ) 
scheduler.handleEventForContext !eventDone_0::B !schedulerEvent_1 !context_2 = case context_2 (scheduler._Context cEnvs_1_0 cProcessStack_1_1 cMax_1_2 processes_1_3 cModalProcess_1_4 cReceiverTable_1_5 cTimerTable_1_6 c_1_7 cOSTime_1_8 c_1_9 cOSToolbox_1_10 -> let _x_2_0 = roundrobin.notodoRR processes_1_3 in case (select _x_2_0::_Tuple2 0) (True -> <{_Tuple2!3}> schedulerEvent_1 (update context_2::scheduler._Context [3:select _x_2_0::_Tuple2 1])) (False -> let processes_4_0 = select _x_2_0::_Tuple2 1, _x_4_1 = roundrobin.getcurrentRR processes_4_0, process_4_2::B = select _x_4_1::_Tuple2 0, _x_4_3 = scheduler.processQuitted_54 process_4_2, quitted_4_4 = select _x_4_3::_Tuple2 0, process_4_5 = select _x_4_3::_Tuple2 1, _x_4_6 = scheduler.processModal_55 process_4_5 in case (case quitted_4_4 (True -> StdBool.not (select _x_4_6::_Tuple2 0)) (False -> False) ) (True -> scheduler.handleEventForContext eventDone_0 schedulerEvent_1 (update context_2::scheduler._Context [3:select _x_4_1::_Tuple2 1])) (False -> case quitted_4_4 (True -> scheduler.handleEventForContext eventDone_0 schedulerEvent_1 (update context_2::scheduler._Context [3:roundrobin.adddoneRR (select _x_4_6::_Tuple2 1) (select _x_4_1::_Tuple2 1)])) (False -> let _x_7_0 = scheduler.handleEventForLocalIO eventDone_0 schedulerEvent_1 (select _x_4_6::_Tuple2 1) (update context_2::scheduler._Context [3:select _x_4_1::_Tuple2 1]), context_7_1 = select _x_7_0::_Tuple4 3 in scheduler.handleEventForContext (select _x_7_0::_Tuple4 0) (select _x_7_0::_Tuple4 1) (update context_7_1::scheduler._Context [3:roundrobin.adddoneRR (select _x_7_0::_Tuple4 2) (select context_7_1::scheduler._Context 3)])) ) ) ) 
scheduler.contextGetProcessStack !context_0 = case context_0 (scheduler._Context cEnvs_1_0 cProcessStack_1_1 cMax_1_2 cProcesses_1_3 cModalProcess_1_4 cReceiverTable_1_5 cTimerTable_1_6 c_1_7 cOSTime_1_8 c_1_9 cOSToolbox_1_10 -> <{_Tuple2!3}> cProcessStack_1_1 context_0) 
scheduler.contextGetProcesses !context_0 = case context_0 (scheduler._Context cEnvs_1_0 cProcessStack_1_1 cMax_1_2 cProcesses_1_3 cModalProcess_1_4 cReceiverTable_1_5 cTimerTable_1_6 c_1_7 cOSTime_1_8 c_1_9 cOSToolbox_1_10 -> <{_Tuple2!3}> cProcesses_1_3 (update context_0::scheduler._Context [3:roundrobin.emptyRR])) 
scheduler.activateTopProcess_60 !top_0 !ioStack_1 !process_2 = case process_2 (iostate._CProcess localState_1_0 ioState_1_1 -> let _x_2_0 = iostate.ioStGetIOId ioState_1_1 in case (StdBool.not (<{systemid.==_5}> (select _x_2_0::_Tuple2 0) top_0)) (True -> <{_Tuple3!7}> False ioStack_1 (update process_2::iostate._CProcess [1:select _x_2_0::_Tuple2 1])) (False -> let _x_4_0 = iostate.ioStGetProcessStack (iostate.ioStSetProcessStack ioStack_1 (select _x_2_0::_Tuple2 1)) in <{_Tuple3!7}> True (select _x_4_0::_Tuple2 0) (update process_2::iostate._CProcess [1:select _x_4_0::_Tuple2 1])) ) 
scheduler.activateTopOfGroups !top_0 !ioStack_1 !processes_2 = let _x_1_0 = roundrobin.notodoRR processes_2 in case (select _x_1_0::_Tuple2 0) (True -> <{_Tuple2!3}> ioStack_1 (select _x_1_0::_Tuple2 1)) (False -> let processes_3_0 = select _x_1_0::_Tuple2 1, _x_3_1 = roundrobin.getcurrentRR processes_3_0, process_3_2 = select _x_3_1::_Tuple2 0, _x_3_3 = scheduler.activateTopProcess_60 top_0 ioStack_1 process_3_2 in case (select _x_3_3::_Tuple3 0) (True -> <{_Tuple2!3}> (select _x_3_3::_Tuple3 1) (roundrobin.inserttodoRR (select _x_3_3::_Tuple3 2) (select _x_3_1::_Tuple2 1))) (False -> let _x_5_0 = scheduler.activateTopOfGroups top_0 (select _x_3_3::_Tuple3 1) (select _x_3_1::_Tuple2 1) in <{_Tuple2!3}> (select _x_5_0::_Tuple2 0) (roundrobin.inserttodoRR (select _x_3_3::_Tuple3 2) (select _x_5_0::_Tuple2 1))) ) 
scheduler.handleContextOSEvent !osEvent_0 !context_1 = case context_1 (scheduler._Context envs_1_0 cProcessStack_1_1 cMax_1_2 cProcesses_1_3 cModalProcess_1_4 cReceiverTable_1_5 cTimerTable_1_6 c_1_7 cOSTime_1_8 c_1_9 cOSToolbox_1_10 -> case envs_1_0 (scheduler._Environs osEvents_2_0 envsWorld_2_1 -> let _x_3_0 = ostime.osGetTime cOSToolbox_1_10, ostime_3_1 = select _x_3_0::_Tuple2 0, timeshift_3_2 = ostime.toInt_8 (<{ostime.-_6}> ostime_3_1 cOSTime_1_8), timertable_3_3 = timertable.shiftTimeInTimerTable timeshift_3_2 cTimerTable_1_6, _x_3_4 = scheduler.toSchedulerEvent osEvent_0 cReceiverTable_1_5 timertable_3_3 cOSTime_1_8 osEvents_2_0, schedulerEvent_3_5 = select _x_3_4::_Tuple4 0, osEvents_3_6 = select _x_3_4::_Tuple4 3, processes_3_7::I = roundrobin.resetRR cProcesses_1_3, receivertable_3_8 = select _x_3_4::_Tuple4 1, timertable_3_9 = select _x_3_4::_Tuple4 2, tb_3_10 = select _x_3_0::_Tuple2 1, context_3_11 = update context_1::scheduler._Context [0:update envs_1_0::scheduler._Environs [0:osEvents_3_6],3:processes_3_7,5:receivertable_3_8,6:timertable_3_9,8:ostime_3_1,10:tb_3_10], _x_3_12 = scheduler.handleEventForContext False schedulerEvent_3_5 context_3_11, context_3_13 = select _x_3_12::_Tuple2 1, _x_3_14 = scheduler.contextGetProcessStack context_3_13, newStack_3_15::I = select _x_3_14::_Tuple2 0, _x_3_16 = processstack.topShowProcessShowState newStack_3_15, newTop_3_17 = select _x_3_16::_Tuple2 1 in case (case (<{systemid.==_5}> (select (processstack.topShowProcessShowState cProcessStack_1_1)::_Tuple2 1) newTop_3_17) (True -> True) (False -> StdBool.not (select _x_3_16::_Tuple2 0)) ) (True -> <{_Tuple2!3}> (<{scheduler._c;188;35_124}> (select _x_3_12::_Tuple2 0)) (select _x_3_14::_Tuple2 1)) (False -> let _x_5_0 = scheduler.contextGetProcesses (select _x_3_14::_Tuple2 1), _x_5_1 = scheduler.activateTopOfGroups newTop_3_17 newStack_3_15 (roundrobin.resetRR (select _x_5_0::_Tuple2 0)) in <{_Tuple2!3}> (<{scheduler._c;188;35_125}> (select _x_3_12::_Tuple2 0)) (update (select _x_5_0::_Tuple2 1)::scheduler._Context [1:select _x_5_1::_Tuple2 0,3:select _x_5_1::_Tuple2 1])) ) ) 
<{scheduler._c;188;35_125}> !_x_0 = case _x_0 (deviceevents.ScheduleOSEvent _x_1_0 reply_1_1 -> reply_1_1) (_ -> _predefined._Nil)
<{scheduler._c;188;35_124}> !_x_0 = case _x_0 (deviceevents.ScheduleOSEvent _x_1_0 reply_1_1 -> reply_1_1) (_ -> _predefined._Nil)
scheduler.contextGetSleepTime !context_0 = case context_0 (scheduler._Context cEnvs_1_0 cProcessStack_1_1 cMax_1_2 cProcesses_1_3 cModalProcess_1_4 cReceiverTable_1_5 tt_1_6 c_1_7 cOSTime_1_8 c_1_9 cOSToolbox_1_10 -> let _x_2_0 = receivertable.getActiveReceiverTableEntry cReceiverTable_1_5, _x_2_1 = timertable.getTimeIntervalFromTimerTable tt_1_6, maybe_sleep_2_2 = select _x_2_1::_Tuple2 0 in <{_Tuple2!3}> (<{scheduler._if;51;31_126}> (Data.Maybe.isJust (select _x_2_0::_Tuple2 0)) maybe_sleep_2_2) (update context_0::scheduler._Context [5:select _x_2_0::_Tuple2 1,6:select _x_2_1::_Tuple2 1])) 
<{scheduler._if;51;31_126}>::I !_x_0::B maybe_sleep_1 = case _x_0 (True -> 0) (_ -> case (Data.Maybe.isJust maybe_sleep_1) (True -> select (Data.Maybe.fromJust maybe_sleep_1)::_Tuple2 1) (False -> <{StdInt.-_7}> (<{StdInt.^_12}> 2 15) 1) )
scheduler.contextSetOSEvents !_x_0 = case _x_0 (_Tuple2 osEvents_1_0 context_1_1 -> case context_1_1 (scheduler._Context envs_2_0 cProcessStack_2_1 cMax_2_2 cProcesses_2_3 cModalProcess_2_4 cReceiverTable_2_5 cTimerTable_2_6 c_2_7 cOSTime_2_8 c_2_9 cOSToolbox_2_10 -> update context_1_1::scheduler._Context [0:update envs_2_0::scheduler._Environs [0:osEvents_1_0]]) ) 
scheduler.contextGetOSEvents !context_0 = case context_0 (scheduler._Context envs_1_0 cProcessStack_1_1 cMax_1_2 cProcesses_1_3 cModalProcess_1_4 cReceiverTable_1_5 cTimerTable_1_6 c_1_7 cOSTime_1_8 c_1_9 cOSToolbox_1_10 -> case envs_1_0 (scheduler._Environs es_2_0 envsWorld_2_1 -> <{_Tuple2!3}> es_2_0 (update context_0::scheduler._Context [0:update envs_1_0::scheduler._Environs [0:osevent.osNewEvents]])) ) 
scheduler.terminate_49 !context_0 = case context_0 (scheduler._Context cEnvs_1_0 cProcessStack_1_1 cMax_1_2 cProcesses_1_3 cModalProcess_1_4 cReceiverTable_1_5 cTimerTable_1_6 c_1_7 cOSTime_1_8 c_1_9 cOSToolbox_1_10 -> <{_Tuple2!3}> (StdList.isEmpty cProcessStack_1_1) context_0) 
scheduler.handleEvents !context_0 !tb_1::I = osevent.osHandleEvents scheduler.terminate_49 scheduler.contextGetOSEvents scheduler.contextSetOSEvents scheduler.contextGetSleepTime scheduler.handleContextOSEvent (_Tuple2 (select (scheduler.handleContextOSEvent osevent.osNullEvent context_0)::_Tuple2 1) tb_1)
scheduler.terminate_50 !cond_0 !context_1 = let _x_1_0 = cond_0 context_1 in <{_Tuple2!3}> (StdBool.not (select _x_1_0::_Tuple2 0)) (select _x_1_0::_Tuple2 1)
scheduler.chandleEvents !cond_0 !context_1 !tb_2::I = osevent.osHandleEvents (scheduler.terminate_50 cond_0) scheduler.contextGetOSEvents scheduler.contextSetOSEvents scheduler.contextGetSleepTime scheduler.handleContextOSEvent (_Tuple2 context_1 tb_2)
scheduler.closeContext !_x_0 !tb_1::I = case _x_0 (scheduler._Context _x_1_0 cProcessStack_1_1 cMax_1_2 cProcesses_1_3 cModalProcess_1_4 cReceiverTable_1_5 cTimerTable_1_6 c_1_7 cOSTime_1_8 c_1_9 cOSToolbox_1_10 -> case _x_1_0 (scheduler._Environs envsEvents_2_0 envsWorld_2_1 -> case (StdList.isEmpty cProcessStack_1_1) (True -> world.storeWorld 42 envsWorld_2_1) (False -> scheduler.schedulerFatalError "closeContext" "not a final Context") ) ) 
<{scheduler.c;442;57_59}> !g_l_0 = <{scheduler.g_c1;442;62_127}> g_l_0
<{scheduler.g_c1;442;62_127}> !g_l_0 = case g_l_0 (_predefined._Cons df_1_0 g_t_1_1 -> _predefined._Cons (_Tuple2 (select df_1_0::devicefunctions._DeviceFunctions 3) (select df_1_0::devicefunctions._DeviceFunctions 4)) (<{scheduler.c;442;57_59}> g_t_1_1)) (_ -> _predefined._Nil)
scheduler.handleOneEventForDevices !schedulerEvent_0 !pState_1 = let _x_1_0 = StdPSt.accPIO iostate.ioStGetDeviceFunctions pState_1 in scheduler.handleEventForDevices (<{scheduler.c;442;57_59}> (select _x_1_0::_Tuple2 0)) False schedulerEvent_0 (select _x_1_0::_Tuple2 1)
scheduler.getGUIShare !isSubProcess_0::B !ioState_1 = case (StdBool.not isSubProcess_0) (True -> <{_Tuple2!3}> Data.Maybe.Nothing ioState_1) (False -> let _x_2_0 = iostate.ioStGetGUIShare ioState_1, guishare_2_1 = select _x_2_0::_Tuple2 0 in case (Data.Maybe.isJust guishare_2_1) (True -> <{_Tuple2!3}> guishare_2_1 (select _x_2_0::_Tuple2 1)) (False -> let ioState_4_0 = select _x_2_0::_Tuple2 1, _x_4_1 = iostate.ioStGetProcessKind ioState_4_0 in case (<{processstack.==_6}> (select _x_4_1::_Tuple2 0) processstack.VirtualProcess) (True -> <{_Tuple2!3}> guishare_2_1 (select _x_4_1::_Tuple2 1)) (False -> <{_Tuple2!3}> guishare_2_1 (select _x_4_1::_Tuple2 1)) ) ) 
scheduler.addSubProcessId !isSubProcess_0::B !nr_1 !ioState_2 = case (StdBool.not isSubProcess_0) (True -> ioState_2) (False -> let _x_2_0 = iostate.ioStGetSubProcessIds ioState_2 in iostate.ioStSetSubProcessIds (_predefined._Cons nr_1 (select _x_2_0::_Tuple2 0)) (select _x_2_0::_Tuple2 1)) 
scheduler.addVirtualProcess !ioDef_0 ioDefAbout_1 local_2 !pState_3 = let _x_1_0 = iostate.ioStNewMaxIONr (select pState_3::iostate._PSt 1), nr_1_1 = select _x_1_0::_Tuple2 0, _x_1_2 = iostate.ioStGetIOId (select _x_1_0::_Tuple2 1), _x_1_3 = scheduler.getGUIShare True (select _x_1_2::_Tuple2 1), _x_1_4 = iostate.ioStGetProcessStack (scheduler.addSubProcessId True nr_1_1 (select _x_1_3::_Tuple2 1)), _x_1_5 = iostate.ioStGetCProcesses (iostate.ioStSetProcessStack (processstack.pushProcessShowState (processstack._ProcessShowState nr_1_1 False processstack.VirtualProcess) (select _x_1_4::_Tuple2 0)) (select _x_1_4::_Tuple2 1)) in update pState_3::iostate._PSt [1:iostate.ioStSetCProcesses (roundrobin.inserttodoRR (scheduler.openLocalIO (scheduler.createNewIOSt _predefined._Nil ioDef_0 ioDefAbout_1 nr_1_1 (Data.Maybe.Just (select _x_1_2::_Tuple2 0)) (select _x_1_3::_Tuple2 0) True StdIOCommon.NDI processstack.VirtualProcess) local_2) (select _x_1_5::_Tuple2 0)) (select _x_1_5::_Tuple2 1)]
scheduler.addInteractiveProcess !pAtts_0 !ioDef_1 ioDefAbout_2 local_3 !isSubProcess_4::B !document_5 !pState_6 = let _x_1_0 = iostate.ioStNewMaxIONr (select pState_6::iostate._PSt 1), nr_1_1 = select _x_1_0::_Tuple2 0, ioState_1_2 = select _x_1_0::_Tuple2 1, _x_1_3 = iostate.ioStGetIOId ioState_1_2, _x_1_4 = scheduler.getGUIShare isSubProcess_4 (select _x_1_3::_Tuple2 1), _x_1_5 = iostate.ioStGetProcessStack (scheduler.addSubProcessId isSubProcess_4 nr_1_1 (select _x_1_4::_Tuple2 1)), _x_1_6 = iostate.ioStGetCProcesses (iostate.ioStSetProcessStack (processstack.pushProcessShowState (processstack._ProcessShowState nr_1_1 True processstack.InteractiveProcess) (select _x_1_5::_Tuple2 0)) (select _x_1_5::_Tuple2 1)), parent_1_7 = select _x_1_3::_Tuple2 0 in update pState_6::iostate._PSt [1:iostate.ioStSetCProcesses (roundrobin.inserttodoRR (scheduler.openLocalIO (scheduler.createNewIOSt (StdList.filter (StdProcessAttribute.isProcessKindAttribute document_5) pAtts_0) ioDef_1 ioDefAbout_2 nr_1_1 (<{scheduler._if;491;31_128}> isSubProcess_4 parent_1_7) (select _x_1_4::_Tuple2 0) isSubProcess_4 document_5 processstack.InteractiveProcess) local_3) (select _x_1_6::_Tuple2 0)) (select _x_1_6::_Tuple2 1)]
<{scheduler._if;491;31_128}> !isSubProcess_0::B parent_1 = case isSubProcess_0 (True -> Data.Maybe.Just parent_1) (_ -> Data.Maybe.Nothing)
scheduler.rsIsClosed::B !_x_0 = case _x_0 (iostate.Closed -> True) (_ -> False)
<{scheduler.c;571;60_61}> !g_l_0 = <{scheduler.g_c1;571;65_129}> g_l_0
<{scheduler.g_c1;571;65_129}> !g_l_0 = case g_l_0 (_predefined._Cons df_1_0 g_t_1_1 -> _predefined._Cons (select df_1_0::devicefunctions._DeviceFunctions 6) (<{scheduler.c;571;60_61}> g_t_1_1)) (_ -> _predefined._Nil)
<{scheduler.quitLocalSubProcesses`_62}> !_x_0 !processes_1 = case _x_0 (_predefined._Nil -> <{_Tuple2!3}> _predefined._Nil processes_1) (_ -> case processes_1 (_predefined._Nil -> <{_Tuple2!3}> _x_0 _predefined._Nil) (_predefined._Cons process_1_0 processes_1_1 -> case process_1_0 (iostate._CProcess localState_2_0 ioState_2_1 -> let _x_3_0 = iostate.ioStGetIOId ioState_2_1, ioid_3_1 = select _x_3_0::_Tuple2 0, _x_3_2 = commondef.remove (<{systemid.==_5}> ioid_3_1) systemid.nullSystemId _x_0 in case (select _x_3_2::_Tuple3 0) (True -> let _x_5_0 = iostate.ioStGetSubProcessIds (select _x_3_0::_Tuple2 1), _x_5_1 = <{scheduler.quitLocalSubProcesses`_62}> (<{StdList.++}> (select _x_3_2::_Tuple3 2) (select _x_5_0::_Tuple2 0)) processes_1_1 in <{_Tuple2!3}> (select _x_5_1::_Tuple2 0) (_predefined._Cons (iostate._CProcess localState_2_0 (iostate.ioStSetInitIO scheduler.quitProcess (select _x_5_0::_Tuple2 1))) (select _x_5_1::_Tuple2 1))) (False -> let _x_5_0 = <{scheduler.quitLocalSubProcesses`_62}> (select _x_3_2::_Tuple3 2) processes_1_1 in <{_Tuple2!3}> (select _x_5_0::_Tuple2 0) (_predefined._Cons (iostate._CProcess localState_2_0 (select _x_3_0::_Tuple2 1)) (select _x_5_0::_Tuple2 1))) ) ) )
scheduler.quitLocalSubProcesses_63 !ids_0 !processes_1 = case (StdList.isEmpty ids_0) (True -> <{_Tuple2!3}> ids_0 processes_1) (False -> let _x_2_0 = roundrobin.fromRR processes_1, _x_2_1 = <{scheduler.quitLocalSubProcesses`_62}> ids_0 (select _x_2_0::_Tuple2 0), _x_2_2 = <{scheduler.quitLocalSubProcesses`_62}> (select _x_2_1::_Tuple2 0) (select _x_2_0::_Tuple2 1) in <{_Tuple2!3}> (select _x_2_2::_Tuple2 0) (roundrobin.toRR (select _x_2_1::_Tuple2 1) (select _x_2_2::_Tuple2 1))) 
scheduler.quitSubProcesses !ids_0 !ioState_1 = let _x_1_0 = iostate.ioStGetCProcesses ioState_1 in iostate.ioStSetCProcesses (select (scheduler.quitLocalSubProcesses_63 ids_0 (select _x_1_0::_Tuple2 0))::_Tuple2 1) (select _x_1_0::_Tuple2 1)
scheduler.quitProcess !pState_0 = let _x_1_0 = StdPSt.accPIO iostate.ioStGetRuntimeState pState_0, rs_1_1 = select _x_1_0::_Tuple2 0 in case (select (scheduler.rsIsBlocked rs_1_1)::_Tuple2 0) (True -> scheduler.schedulerFatalError "quitProcess" "closeProcess applied to blocked process") (False -> case (scheduler.rsIsClosed rs_1_1) (True -> select _x_1_0::_Tuple2 1) (False -> let _x_4_0 = StdPSt.accPIO iostate.ioStGetDeviceFunctions (select _x_1_0::_Tuple2 1), pState_4_1 = commondef.strictSeq (<{scheduler.c;571;60_61}> (select _x_4_0::_Tuple2 0)) (select _x_4_0::_Tuple2 1), _x_4_2 = iostate.ioStGetIOId (iostate.ioStSetRuntimeState iostate.Closed (select pState_4_1::iostate._PSt 1)), nr_4_3 = select _x_4_2::_Tuple2 0, _x_4_4 = iostate.ioStGetSubProcessIds (select _x_4_2::_Tuple2 1), _x_4_5 = iostate.ioStGetProcessStack (scheduler.removeIOIdFromParentProcess nr_4_3 (scheduler.quitSubProcesses (select _x_4_4::_Tuple2 0) (select _x_4_4::_Tuple2 1))), _x_4_6 = iostate.ioStGetOSDInfo (iostate.ioStSetProcessStack (select (processstack.removeProcessShowState nr_4_3 (select _x_4_5::_Tuple2 0))::_Tuple2 1) (select _x_4_5::_Tuple2 1)) in update pState_4_1::iostate._PSt [1:iostate.appIOToolbox (osdocumentinterface.osCloseOSDInfo (select _x_4_6::_Tuple2 0)) (select _x_4_6::_Tuple2 1)]) ) 
<{scheduler.turnRRToProcess`_69}> !id_0 !l_1 = case l_1 (iostate._CProcess localState_1_0 ioState_1_1 -> let _x_2_0 = iostate.ioStGetIOId ioState_1_1 in <{_Tuple2!3}> (<{systemid.==_5}> id_0 (select _x_2_0::_Tuple2 0)) (update l_1::iostate._CProcess [1:select _x_2_0::_Tuple2 1])) 
scheduler.turnRRToProcess_70 !id_0 !locals_1 = let _x_1_0 = roundrobin.notodoRR locals_1 in case (select _x_1_0::_Tuple2 0) (True -> <{_Tuple2!3}> False (select _x_1_0::_Tuple2 1)) (False -> let locals_3_0 = select _x_1_0::_Tuple2 1, _x_3_1 = roundrobin.getcurrentRR locals_3_0, local_3_2 = select _x_3_1::_Tuple2 0, _x_3_3 = <{scheduler.turnRRToProcess`_69}> id_0 local_3_2 in case (select _x_3_3::_Tuple2 0) (True -> <{_Tuple2!3}> True (roundrobin.inserttodoRR (select _x_3_3::_Tuple2 1) (select _x_3_1::_Tuple2 1))) (False -> scheduler.turnRRToProcess_70 id_0 (roundrobin.adddoneRR (select _x_3_3::_Tuple2 1) (select _x_3_1::_Tuple2 1))) ) 
scheduler.turnRRToProcessInGroups !id_0 !gs_1 = scheduler.turnRRToProcess_70 id_0 (roundrobin.resetRR gs_1)
scheduler.castType _x_0 y_1 = error "no AnyCodeExpr"
scheduler.switchToPSt_66 !type_0 !return_1 !context_2 !local_3 = case context_2 (scheduler._Context cEnvs_1_0 cProcessStack_1_1 cMax_1_2 cProcesses_1_3 cModalProcess_1_4 cReceiverTable_1_5 cTimerTable_1_6 c_1_7 cOSTime_1_8 c_1_9 cOSToolbox_1_10 -> let _x_2_0 = roundrobin.getcurrentRR (select (scheduler.turnRRToProcessInGroups return_1 cProcesses_1_3)::_Tuple2 1), _x_2_1 = roundrobin.fromRR (select _x_2_0::_Tuple2 1) in select (scheduler.cSwitchIn local_3 (update context_2::scheduler._Context [3:roundrobin.toRR (select _x_2_1::_Tuple2 0) (select _x_2_1::_Tuple2 1)]) (iostate.ioStSetRuntimeState iostate.Running (scheduler.castType type_0 (select (select _x_2_0::_Tuple2 0)::iostate._CProcess 1))))::_Tuple2 1) 
scheduler.checkSyncMessageError_67 !_x_0 = case _x_0 (deviceevents.ScheduleMsgEvent _x_1_0 -> case _x_1_0 (deviceevents.SyncMessage _x_2_0 -> case _x_2_0 (receivermessage._SyncMessage smRecLoc_3_0 smMsg_3_1 smResp_3_2 smError_3_3 -> case (StdList.isEmpty smError_3_3) (True -> Data.Maybe.Nothing) (False -> case (StdBool.not (commondef.isSingleton smError_3_3)) (True -> scheduler.schedulerFatalError "checkSyncMessageError" "more than one MessageError returned") (False -> <{scheduler._c;746;15_130}> (StdList.hd smError_3_3)) ) ) ) ) (_ -> Data.Maybe.Nothing)
<{scheduler._c;746;15_130}> !_x_0 = case _x_0 (receivermessage.ReceiverUnable -> Data.Maybe.Just scheduler.SwitchReceiverUnable) (receivermessage.ReceiverUnknown -> Data.Maybe.Just scheduler.SwitchToReceiverDoesNotExist) 
scheduler.getSyncMessageResponse_68 !_x_0 = case _x_0 (deviceevents.ScheduleMsgEvent _x_1_0 -> case _x_1_0 (deviceevents.SyncMessage _x_2_0 -> case _x_2_0 (receivermessage._SyncMessage smRecLoc_3_0 smMsg_3_1 smResp_3_2 smError_3_3 -> smResp_3_2) ) ) (_ -> _predefined._Nil)
scheduler.checkProcess_72 !ioid_0 !ioState_1 = let _x_1_0 = iostate.ioStGetIOId ioState_1 in case (StdBool.not (<{systemid.==_5}> ioid_0 (select _x_1_0::_Tuple2 0))) (True -> <{_Tuple2!3}> (_Tuple2 False Data.Maybe.Nothing) (select _x_1_0::_Tuple2 1)) (False -> let ioState_3_0 = select _x_1_0::_Tuple2 1, _x_3_1 = iostate.ioStGetRuntimeState ioState_3_0, runtime_3_2 = select _x_3_1::_Tuple2 0, _x_3_3 = scheduler.rsIsBlocked runtime_3_2 in case (select _x_3_3::_Tuple2 0) (True -> <{_Tuple2!3}> (_Tuple2 True (Data.Maybe.Just (select _x_3_3::_Tuple2 1))) (select _x_3_1::_Tuple2 1)) (False -> <{_Tuple2!3}> (_Tuple2 True Data.Maybe.Nothing) (select _x_3_1::_Tuple2 1)) ) 
scheduler.checkInLocal_73 !nextproc_0 !local_1 = case local_1 (iostate._CProcess localState_1_0 ioState_1_1 -> let _x_2_0 = scheduler.checkProcess_72 nextproc_0 ioState_1_1 in <{_Tuple2!3}> (select _x_2_0::_Tuple2 0) (update local_1::iostate._CProcess [1:select _x_2_0::_Tuple2 1])) 
scheduler.accessLocalIOs_74 !accLocal_0 !_x_1 = case _x_1 (_predefined._Cons local_1_0 locals_1_1 -> let _x_2_0 = accLocal_0 local_1_0, r_2_1 = select _x_2_0::_Tuple2 0 in case (select r_2_1::_Tuple2 0) (True -> <{_Tuple2!3}> r_2_1 (_predefined._Cons (select _x_2_0::_Tuple2 1) locals_1_1)) (False -> let _x_4_0 = scheduler.accessLocalIOs_74 accLocal_0 locals_1_1 in <{_Tuple2!3}> (select _x_4_0::_Tuple2 0) (_predefined._Cons (select _x_2_0::_Tuple2 1) (select _x_4_0::_Tuple2 1))) ) (_predefined._Nil -> <{_Tuple2!3}> (_Tuple2 False Data.Maybe.Nothing) _predefined._Nil) 
scheduler.accessLocals !accLocal_0 !locals_1 = let _x_1_0 = roundrobin.fromRR locals_1, lsDone_1_1 = select _x_1_0::_Tuple2 0, _x_1_2 = scheduler.accessLocalIOs_74 accLocal_0 lsDone_1_1, rDone_1_3 = select _x_1_2::_Tuple2 0 in case (select rDone_1_3::_Tuple2 0) (True -> <{_Tuple2!3}> rDone_1_3 (roundrobin.toRR (select _x_1_2::_Tuple2 1) (select _x_1_0::_Tuple2 1))) (False -> let _x_3_0 = scheduler.accessLocalIOs_74 accLocal_0 (select _x_1_0::_Tuple2 1) in <{_Tuple2!3}> (select _x_3_0::_Tuple2 0) (roundrobin.toRR (select _x_1_2::_Tuple2 1) (select _x_3_0::_Tuple2 1))) 
scheduler.checkBlockedProcess !nextproc_0 !groups_1 = scheduler.accessLocals (scheduler.checkInLocal_73 nextproc_0) groups_1
scheduler.processIsBlocked !id_0 !context_1 = case context_1 (scheduler._Context cEnvs_1_0 cProcessStack_1_1 cMax_1_2 cProcesses_1_3 cModalProcess_1_4 cReceiverTable_1_5 cTimerTable_1_6 c_1_7 cOSTime_1_8 c_1_9 cOSToolbox_1_10 -> let _x_2_0::B = scheduler.checkBlockedProcess id_0 cProcesses_1_3, _x_2_1 = select _x_2_0::_Tuple2 0, procfound_2_2 = select _x_2_1::_Tuple2 0 in case procfound_2_2 (True -> <{_Tuple2!3}> (Data.Maybe.isJust (select _x_2_1::_Tuple2 1)) (update context_1::scheduler._Context [3:select _x_2_0::_Tuple2 1])) (False -> <{_Tuple2!3}> procfound_2_2 (update context_1::scheduler._Context [3:select _x_2_0::_Tuple2 1])) ) 
scheduler.switchFromPSt !pState_0 = scheduler.cSwitchOut (_Tuple2 _predefined._Nil roundrobin.emptyRR) pState_0
scheduler.typeIsIOSt !ioState_0 = <{_Tuple2!2}> scheduler.Unguard ioState_0
<{scheduler.checkDeadlock`_71}> !blockedprocs_0 !nextproc_1 !gs_2 = let _x_1_0 = scheduler.checkBlockedProcess nextproc_1 gs_2, _x_1_1 = select _x_1_0::_Tuple2 0 in case (StdBool.not (select _x_1_1::_Tuple2 0)) (True -> <{_Tuple2!3}> False (select _x_1_0::_Tuple2 1)) (False -> let opt_id_3_0 = select _x_1_1::_Tuple2 1 in case (Data.Maybe.isNothing opt_id_3_0) (True -> <{_Tuple2!3}> False (select _x_1_0::_Tuple2 1)) (False -> let nextproc_5_0 = Data.Maybe.fromJust opt_id_3_0, blockedprocs_5_1 = _predefined._Cons nextproc_5_0 blockedprocs_0 in case (commondef.contains (<{systemid.==_5}> nextproc_5_0) blockedprocs_5_1) (True -> <{_Tuple2!3}> True (select _x_1_0::_Tuple2 1)) (False -> <{scheduler.checkDeadlock`_71}> blockedprocs_5_1 nextproc_5_0 (select _x_1_0::_Tuple2 1)) ) ) 
scheduler.checkDeadlock !return_0 !switchTo_1 !gs_2 = <{scheduler.checkDeadlock`_71}> (_predefined._Cons return_0 _predefined._Nil) switchTo_1 gs_2
scheduler.cswitchProcess !process_0 !message_1 !pState_2 = let _x_1_0 = StdPSt.accPIO iostate.ioStGetIOId pState_2, return_1_1 = select _x_1_0::_Tuple2 0 in case (<{systemid.==_5}> process_0 return_1_1) (True -> <{_Tuple3!7}> (Data.Maybe.Just scheduler.SwitchToYourself) _predefined._Nil (select _x_1_0::_Tuple2 1)) (False -> let pState1_3_0 = select _x_1_0::_Tuple2 1, _x_3_1 = scheduler.switchFromPSt pState1_3_0, ioState_3_2 = select _x_3_1::_Tuple3 2, ioState1_3_3 = iostate.ioStSetRuntimeState (iostate.Blocked process_0) ioState_3_2, _x_3_4 = scheduler.typeIsIOSt ioState1_3_3, ioState3_3_5 = select _x_3_4::_Tuple2 1, blockedLocal_3_6 = iostate._CProcess Data.Maybe.Nothing ioState3_3_5, context_3_7 = select _x_3_1::_Tuple3 1, _x_3_8 = scheduler.contextGetProcesses context_3_7, groups_3_9 = select _x_3_8::_Tuple2 0, groups1_3_10 = roundrobin.adddoneRR blockedLocal_3_6 groups_3_9, _x_3_11 = scheduler.turnRRToProcessInGroups process_0 groups1_3_10 in case (StdBool.not (select _x_3_11::_Tuple2 0)) (True -> <{_Tuple3!7}> (Data.Maybe.Just scheduler.SwitchToDoesNotExist) _predefined._Nil (scheduler.switchToPSt_66 (select _x_3_4::_Tuple2 0) return_1_1 (update (select _x_3_8::_Tuple2 1)::scheduler._Context [3:select _x_3_11::_Tuple2 1]) (select _x_3_1::_Tuple3 0))) (False -> let groups2_5_0 = select _x_3_11::_Tuple2 1, _x_5_1 = scheduler.checkDeadlock return_1_1 process_0 groups2_5_0 in case (select _x_5_1::_Tuple2 0) (True -> <{_Tuple3!7}> (Data.Maybe.Just scheduler.SwitchEndsUpInDeadlock) _predefined._Nil (scheduler.switchToPSt_66 (select _x_3_4::_Tuple2 0) return_1_1 (update (select _x_3_8::_Tuple2 1)::scheduler._Context [3:select _x_5_1::_Tuple2 1]) (select _x_3_1::_Tuple3 0))) (False -> let _x_7_0 = scheduler.contextGetProcesses (select (scheduler.chandleEvents (scheduler.processIsBlocked process_0) (update (select _x_3_8::_Tuple2 1)::scheduler._Context [3:select _x_5_1::_Tuple2 1]) 0)::_Tuple2 0), _x_7_1 = scheduler.handleEventForContext False message_1 (update (select _x_7_0::_Tuple2 1)::scheduler._Context [3:roundrobin.resetRR (select _x_7_0::_Tuple2 0)]), message1_7_2 = select _x_7_1::_Tuple2 0 in <{_Tuple3!7}> (scheduler.checkSyncMessageError_67 message1_7_2) (scheduler.getSyncMessageResponse_68 message1_7_2) (scheduler.switchToPSt_66 (select _x_3_4::_Tuple2 0) return_1_1 (select _x_7_1::_Tuple2 1) (select _x_3_1::_Tuple3 0))) ) ) 
scheduler.typeIsLocal !ioState_0 = <{_Tuple2!2}> scheduler.Unguard ioState_0
scheduler.switchToPSt !type_0 !typeLocal_1 !return_2 !context_3 = case context_3 (scheduler._Context cEnvs_1_0 cProcessStack_1_1 cMax_1_2 cProcesses_1_3 cModalProcess_1_4 cReceiverTable_1_5 cTimerTable_1_6 c_1_7 cOSTime_1_8 c_1_9 cOSToolbox_1_10 -> let _x_2_0 = scheduler.turnRRToProcessInGroups return_2 cProcesses_1_3 in case (StdBool.not (select _x_2_0::_Tuple2 0)) (True -> scheduler.schedulerFatalError "accContext" "interactive process not found") (False -> let groups_4_0 = select _x_2_0::_Tuple2 1, _x_4_1 = roundrobin.fromRR groups_4_0, gToDo_4_2 = select _x_4_1::_Tuple2 1, _x_4_3 = commondef.hdtl gToDo_4_2, group_4_4 = select _x_4_3::_Tuple2 0, ioState_4_5 = select group_4_4::iostate._CProcess 1, ioState1_4_6 = scheduler.castType type_0 ioState_4_5, _x_4_7 = iostate.ioStClosed ioState1_4_6 in case (select _x_4_7::_Tuple2 0) (True -> select (scheduler.cSwitchIn (Data.Maybe.fromJust (scheduler.castType typeLocal_1 (select group_4_4::iostate._CProcess 0))) (update (update context_3::scheduler._Context [3:roundrobin.toRR (select _x_4_1::_Tuple2 0) (select _x_4_3::_Tuple2 1)])::scheduler._Context [4:Data.Maybe.Nothing]) (select _x_4_7::_Tuple2 1))::_Tuple2 1) (False -> select (scheduler.cSwitchIn (Data.Maybe.fromJust (scheduler.castType typeLocal_1 (select group_4_4::iostate._CProcess 0))) (update context_3::scheduler._Context [3:roundrobin.toRR (select _x_4_1::_Tuple2 0) (select _x_4_3::_Tuple2 1)]) (select _x_4_7::_Tuple2 1))::_Tuple2 1) ) ) 
scheduler.appContext !fun_0 !pState_1 = let _x_1_0 = StdPSt.accPIO iostate.ioStGetIOId pState_1, _x_1_1 = scheduler.switchFromPSt (select _x_1_0::_Tuple2 1), _x_1_2 = scheduler.typeIsIOSt (select _x_1_1::_Tuple3 2), _x_1_3 = scheduler.typeIsLocal (select _x_1_2::_Tuple2 1), _x_1_4 = scheduler.contextGetProcesses (select _x_1_1::_Tuple3 1), _x_1_5 = scheduler.contextGetProcesses (fun_0 (update (select _x_1_4::_Tuple2 1)::scheduler._Context [3:roundrobin.adddoneRR (iostate._CProcess (Data.Maybe.Just (select _x_1_1::_Tuple3 0)) (select _x_1_3::_Tuple2 1)) (select _x_1_4::_Tuple2 0)])) in scheduler.switchToPSt (select _x_1_2::_Tuple2 0) (select _x_1_3::_Tuple2 0) (select _x_1_0::_Tuple2 0) (update (select _x_1_5::_Tuple2 1)::scheduler._Context [3:roundrobin.resetRR (select _x_1_5::_Tuple2 0)])
scheduler.accContext !fun_0 !pState_1 = let _x_1_0 = StdPSt.accPIO iostate.ioStGetIOId pState_1, _x_1_1 = scheduler.switchFromPSt (select _x_1_0::_Tuple2 1), _x_1_2 = scheduler.contextGetProcesses (select _x_1_1::_Tuple3 1), _x_1_3 = scheduler.typeIsIOSt (select _x_1_1::_Tuple3 2), _x_1_4 = scheduler.typeIsLocal (select _x_1_3::_Tuple2 1), _x_1_5 = fun_0 (update (select _x_1_2::_Tuple2 1)::scheduler._Context [3:roundrobin.adddoneRR (iostate._CProcess (Data.Maybe.Just (select _x_1_1::_Tuple3 0)) (select _x_1_4::_Tuple2 1)) (select _x_1_2::_Tuple2 0)]), _x_1_6 = scheduler.contextGetProcesses (select _x_1_5::_Tuple2 1) in <{_Tuple2!3}> (select _x_1_5::_Tuple2 0) (scheduler.switchToPSt (select _x_1_3::_Tuple2 0) (select _x_1_4::_Tuple2 0) (select _x_1_0::_Tuple2 0) (update (select _x_1_6::_Tuple2 1)::scheduler._Context [3:roundrobin.resetRR (select _x_1_6::_Tuple2 0)]))
<{scheduler.TD;Environs}> _x_0::B = _predefined._Nil
<{scheduler.TD;Context}> _x_0::B = _predefined._Nil
<{scheduler.TD;SwitchError}> _x_0::B = _predefined._Nil
<{scheduler.TD;Result}> _x_0::B = _predefined._Nil
<{scheduler.TD;UnguardType}> _x_0::B = _predefined._Nil

:: scheduler.SwitchError = scheduler.SwitchToYourself | scheduler.SwitchToDoesNotExist | scheduler.SwitchToReceiverDoesNotExist | scheduler.SwitchReceiverUnable | scheduler.SwitchEndsUpInDeadlock
:: scheduler.UnguardType = scheduler.Unguard

|| Converted Records
:: scheduler._Environs = {!scheduler.envsEvents, !scheduler.envsWorld}

:: scheduler._Context = {!scheduler.cEnvs, !scheduler.cProcessStack, !scheduler.cMaxIONr, !scheduler.cProcesses, !scheduler.cModalProcess, !scheduler.cReceiverTable, !scheduler.cTimerTable, !scheduler.cIdTable, !scheduler.cOSTime, !scheduler.cIdSeed::I, !scheduler.cOSToolbox}

:: <{scheduler.gEq_s;}> = {!scheduler.gEq_s}

:: <{scheduler.gEq_ss;}> = {!scheduler.gEq_ss}

:: <{scheduler.gEq_sss;}> = {!scheduler.gEq_sss}

:: <{scheduler.gEq_ssss;}> = {!scheduler.gEq_ssss}

:: <{scheduler.gEq_sssss;}> = {!scheduler.gEq_sssss}

:: <{scheduler.gEq_ssssss;}> = {!scheduler.gEq_ssssss}

:: <{scheduler.gEq_sssssss;}> = {!scheduler.gEq_sssssss}

:: <{scheduler.gEq_ssssssss;}> = {!scheduler.gEq_ssssssss}

:: <{scheduler.gEq_sssssssss;}> = {!scheduler.gEq_sssssssss}

:: <{scheduler.bimap_s;}> = {scheduler.bimap_s}

:: <{scheduler.bimap_ss;}> = {scheduler.bimap_ss}

:: <{scheduler.bimap_sss;}> = {scheduler.bimap_sss}

