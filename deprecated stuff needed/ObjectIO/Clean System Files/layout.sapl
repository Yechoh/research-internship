|| ?module? layout


layout.identifyLayoutItem::B !id_0 !_x_1 = case _x_1 (layout._LayoutItem li_1_0 li_1_1 li_1_2 -> <{id.==_27}> id_0 li_1_0) 
layout.identifyRoot::B !id_0 !_x_1 = case _x_1 (layout._Root root_1_0 rootPos_1_1 rootTree_1_2 -> layout.identifyLayoutItem id_0 root_1_0) 
layout.identifyRelative::B !id_0 !_x_1 = case _x_1 (layout._Relative relative_1_0 relativePos_1_1 -> layout.identifyLayoutItem id_0 relative_1_0) 
layout.getRelativeItem_31 !id_0 !_x_1 = case _x_1 (_predefined._Cons item_1_0 items_1_1 -> case (layout.identifyRelative id_0 item_1_0) (True -> <{_Tuple4!15}> True (select item_1_0::layout._Relative 1) (select (select item_1_0::layout._Relative 0)::layout._LayoutItem 2) items_1_1) (False -> let _x_3_0 = layout.getRelativeItem_31 id_0 items_1_1 in <{_Tuple4!15}> (select _x_3_0::_Tuple4 0) (select _x_3_0::_Tuple4 1) (select _x_3_0::_Tuple4 2) (_predefined._Cons item_1_0 (select _x_3_0::_Tuple4 3))) ) (_ -> <{_Tuple4!15}> False StdIOBasic.zero_11 StdIOBasic.zero_15 _x_1)
layout.layoutError !rule_0 !message_1 = commondef.error rule_0 "layout" message_1
layout.getLayoutItem !id_0 !items_1 = case items_1 (_predefined._Cons root_1_0 roots_1_1 -> case (layout.identifyRoot id_0 root_1_0) (True -> case (StdList.isEmpty (select root_1_0::layout._Root 2)) (True -> <{_Tuple4!15}> (<{layout._c;134;19_87}> (select (select root_1_0::layout._Root 0)::layout._LayoutItem 1)) (select root_1_0::layout._Root 1) (select (select root_1_0::layout._Root 0)::layout._LayoutItem 2) roots_1_1) (False -> <{_Tuple4!15}> (<{layout._c;134;19_88}> (select (select root_1_0::layout._Root 0)::layout._LayoutItem 1)) (select root_1_0::layout._Root 1) (select (select root_1_0::layout._Root 0)::layout._LayoutItem 2) items_1) ) (False -> let depends_3_0 = select root_1_0::layout._Root 2, _x_3_1 = layout.getRelativeItem_31 id_0 depends_3_0 in case (select _x_3_1::_Tuple4 0) (True -> <{_Tuple4!15}> (<{layout._c;134;19_89}> (select (select root_1_0::layout._Root 0)::layout._LayoutItem 1)) (select _x_3_1::_Tuple4 1) (select _x_3_1::_Tuple4 2) (_predefined._Cons (update root_1_0::layout._Root [2:select _x_3_1::_Tuple4 3]) roots_1_1)) (False -> let _x_5_0 = layout.getLayoutItem id_0 roots_1_1 in <{_Tuple4!15}> (select _x_5_0::_Tuple4 0) (select _x_5_0::_Tuple4 1) (select _x_5_0::_Tuple4 2) (_predefined._Cons root_1_0 (select _x_5_0::_Tuple4 3))) ) ) (_ -> layout.layoutError "getLayoutItem" "Unknown Id")
<{layout._c;134;19_89}> !_x_0 = case _x_0 (_Tuple2 _x_1_0 _x_1_1 -> case _x_1_0 (StdIOCommon.Fix -> windowhandle.LayoutFix) (_ -> case _x_1_1 (StdIOCommon.OffsetFun i_2_0 f_2_1 -> windowhandle.LayoutFun i_2_0 f_2_1) )) (_ -> windowhandle.LayoutFrame)
<{layout._c;134;19_88}> !_x_0 = case _x_0 (_Tuple2 _x_1_0 _x_1_1 -> case _x_1_0 (StdIOCommon.Fix -> windowhandle.LayoutFix) (_ -> case _x_1_1 (StdIOCommon.OffsetFun i_2_0 f_2_1 -> windowhandle.LayoutFun i_2_0 f_2_1) )) (_ -> windowhandle.LayoutFrame)
<{layout._c;134;19_87}> !_x_0 = case _x_0 (_Tuple2 _x_1_0 _x_1_1 -> case _x_1_0 (StdIOCommon.Fix -> windowhandle.LayoutFix) (_ -> case _x_1_1 (StdIOCommon.OffsetFun i_2_0 f_2_1 -> windowhandle.LayoutFun i_2_0 f_2_1) )) (_ -> windowhandle.LayoutFrame)
layout.IsLine::B !_x_0 = case _x_0 (_Tuple2 _x_1_0 _x_1_1 -> case _x_1_0 (StdIOCommon.Left -> True) (StdIOCommon.Center -> True) (StdIOCommon.Right -> True) ) (_ -> False)
layout.anon_32::B !_x_0 = case _x_0 (layout._LayoutItem li_1_0 li_1_1 li_1_2 -> layout.IsLine li_1_1) 
layout.divide !f_0 !_x_1 = case _x_1 (_predefined._Cons x_1_0 xs_1_1 -> case (f_0 x_1_0) (True -> let _x_3_0 = layout.divide f_0 xs_1_1 in <{_Tuple2!3}> (_predefined._Cons x_1_0 (select _x_3_0::_Tuple2 0)) (select _x_3_0::_Tuple2 1)) (False -> let _x_3_0 = layout.divide f_0 xs_1_1 in <{_Tuple2!3}> (select _x_3_0::_Tuple2 0) (_predefined._Cons x_1_0 (select _x_3_0::_Tuple2 1))) ) (_ -> <{_Tuple2!3}> _predefined._Nil _predefined._Nil)
layout.IsRelative !_x_0 = case _x_0 (_Tuple2 _x_1_0 _x_1_1 -> case _x_1_0 (StdIOCommon.LeftOf id_2_0 -> <{_Tuple2!3}> True id_2_0) (StdIOCommon.RightTo id_2_0 -> <{_Tuple2!3}> True id_2_0) (StdIOCommon.Above id_2_0 -> <{_Tuple2!3}> True id_2_0) (StdIOCommon.Below id_2_0 -> <{_Tuple2!3}> True id_2_0) ) (_ -> <{_Tuple2!3}> False (id.sysId 0))
layout.getItemPosChain_34 !next_0 !done_1 !chain_2 !todo_3 = case (commondef.contains (layout.identifyLayoutItem next_0) chain_2) (True -> layout.layoutError "calculating layout" "cyclic dependency between Ids") (False -> case (commondef.contains (layout.identifyLayoutItem next_0) done_1) (True -> <{_Tuple3!7}> done_1 chain_2 todo_3) (False -> let _x_3_0 = commondef.remove (layout.identifyLayoutItem next_0) StdMisc.undef todo_3 in case (StdBool.not (select _x_3_0::_Tuple3 0)) (True -> layout.layoutError "calculating layout" "reference to unknown Id") (False -> let next_5_0 = select _x_3_0::_Tuple3 1, nextPos_5_1 = select next_5_0::layout._LayoutItem 1, _x_5_2 = layout.IsRelative nextPos_5_1 in case (StdBool.not (select _x_5_2::_Tuple2 0)) (True -> <{_Tuple3!7}> done_1 (_predefined._Cons next_5_0 chain_2) (select _x_3_0::_Tuple3 2)) (False -> layout.getItemPosChain_34 (select _x_5_2::_Tuple2 1) done_1 (_predefined._Cons next_5_0 chain_2) (select _x_3_0::_Tuple3 2)) ) ) ) 
layout.insertchain_33 !id_0 chain_1 !_x_2 = case _x_2 (_predefined._Cons item_1_0 items_1_1 -> case (layout.identifyLayoutItem id_0 item_1_0) (True -> <{StdList.++}> chain_1 (_predefined._Cons item_1_0 items_1_1)) (False -> _predefined._Cons item_1_0 (layout.insertchain_33 id_0 chain_1 items_1_1)) ) (_ -> chain_1)
layout.insertItemPosChain_35 !chain_0 !done_1 = case chain_0 (_predefined._Cons final_1_0 _x_1_1 -> let _x_2_0 = layout.IsRelative (select final_1_0::layout._LayoutItem 1) in case (StdBool.not (select _x_2_0::_Tuple2 0)) (True -> <{StdList.++}> (StdList.reverse chain_0) done_1) (False -> layout.insertchain_33 (select _x_2_0::_Tuple2 1) (StdList.reverse chain_0) done_1) ) (_ -> done_1)
<{layout.sortLayoutItems`_36}> !done_0 !todo_1 = case (StdList.isEmpty todo_1) (True -> StdList.reverse done_0) (False -> let _x_2_0 = commondef.hdtl todo_1, item1_2_1 = select _x_2_0::_Tuple2 0, pos1_2_2 = select item1_2_1::layout._LayoutItem 1, _x_2_3 = layout.IsRelative pos1_2_2 in case (StdBool.not (select _x_2_3::_Tuple2 0)) (True -> <{layout.sortLayoutItems`_36}> (_predefined._Cons item1_2_1 done_0) (select _x_2_0::_Tuple2 1)) (False -> let _x_4_0 = layout.getItemPosChain_34 (select _x_2_3::_Tuple2 1) done_0 (_predefined._Cons item1_2_1 _predefined._Nil) (select _x_2_0::_Tuple2 1) in <{layout.sortLayoutItems`_36}> (layout.insertItemPosChain_35 (select _x_4_0::_Tuple3 1) (select _x_4_0::_Tuple3 0)) (select _x_4_0::_Tuple3 2)) ) 
layout.sortLayoutItems !layout_0 = let _x_1_0 = layout.divide layout.anon_32 layout_0 in <{layout.sortLayoutItems`_36}> _predefined._Nil (<{StdList.++}> (select _x_1_0::_Tuple2 0) (select _x_1_0::_Tuple2 1))
layout.itemPosOffset !_x_0 _x_1 = case _x_0 (StdIOCommon.NoOffset -> StdIOBasic.Alt1Of2 StdIOBasic.zero_11) (StdIOCommon.OffsetVector v_1_0 -> StdIOBasic.Alt1Of2 v_1_0) (StdIOCommon.OffsetAlign a_1_0 -> StdIOBasic.Alt2Of2 a_1_0) (StdIOCommon.OffsetFun i_1_0 f_1_1 -> case (commondef.isBetween i_1_0 1 (StdList.length_47 _x_1)) (True -> StdIOBasic.Alt1Of2 (f_1_1 (<{StdList.!!}> _x_1 (<{StdInt.-_7}> i_1_0 1)))) (False -> layout.layoutError "calculating OffsetFun" (<{StdString.+++_11}> "illegal ParentIndex value: " (StdString.toString_5 i_1_0))) ) 
layout.layoutFatalError !rule_0 !message_1 = commondef.fatalError rule_0 "layout" message_1
layout.IsRelativeX::B !_x_0 = case _x_0 (_Tuple2 _x_1_0 _x_1_1 -> case _x_1_0 (StdIOCommon.LeftOf _x_2_0 -> True) (StdIOCommon.RightTo _x_2_0 -> True) ) (_ -> False)
layout.IsCorner::B !_x_0 = case _x_0 (_Tuple2 _x_1_0 _x_1_1 -> case _x_1_0 (StdIOCommon.LeftTop -> True) (StdIOCommon.RightTop -> True) (StdIOCommon.LeftBottom -> True) (StdIOCommon.RightBottom -> True) ) (_ -> False)
layout.IsFix !_x_0 = case _x_0 (_Tuple2 _x_1_0 offset_1_1 -> case _x_1_0 (StdIOCommon.Fix -> <{_Tuple2!3}> True offset_1_1) ) (_ -> <{_Tuple2!3}> False StdIOCommon.NoOffset)
layout.IsBelow::B !_x_0 = case _x_0 (_Tuple2 _x_1_0 _x_1_1 -> case _x_1_0 (StdIOCommon.Below _x_2_0 -> True) ) (_ -> False)
layout.getLayoutItemPosSize !id_0 !item_1 = case (layout.identifyRoot id_0 item_1) (True -> <{_Tuple3!7}> True (select item_1::layout._Root 1) (select (select item_1::layout._Root 0)::layout._LayoutItem 2)) (False -> let _x_2_0 = commondef.cselect (layout.identifyRelative id_0) StdMisc.undef (select item_1::layout._Root 2) in case (StdBool.not (select _x_2_0::_Tuple2 0)) (True -> <{_Tuple3!7}> False StdIOBasic.zero_11 StdIOBasic.zero_15) (False -> let relative_4_0 = select _x_2_0::_Tuple2 1 in <{_Tuple3!7}> True (select relative_4_0::layout._Relative 1) (select (select relative_4_0::layout._Relative 0)::layout._LayoutItem 2)) ) 
layout.calcYPosition_38 !itemSpaces_0 !orientations_1 !item1_2 !id2_3 !sizeY_4::I !item2_5 = case item2_5 (layout._Root root2_1_0 rootPos_1_1 tree2_1_2 -> let _x_2_0 = layout.getLayoutItemPosSize id2_3 item2_5 in case (StdBool.not (select _x_2_0::_Tuple3 0)) (True -> layout.layoutFatalError "calcXPosition" "dependent item could not be found in rootTree") (False -> let pos2_4_0 = select root2_1_0::layout._LayoutItem 1, corner2_4_1 = select _x_2_0::_Tuple3 1, pos1_4_2 = select item1_2::layout._LayoutItem 1, offset_4_3::I = layout.itemPosOffset (select pos1_4_2::_Tuple2 1) orientations_1, isVectorOffset_4_4::B = StdIOBasic.isAlt1Of2 offset_4_3, t_4_5 = <{layout._if;341;31_92}> (layout.IsBelow pos1_4_2) corner2_4_1 size2_4_6 itemSpaces_0 isVectorOffset_4_4 v_4_8 size1_4_7, size2_4_6 = select _x_2_0::_Tuple3 2, size1_4_7 = select item1_2::layout._LayoutItem 2, v_4_8 = StdIOBasic.alt1Of2 offset_4_3 in <{_Tuple2!3}> (<{layout._if;326;17_94}> (layout._f93_93 (layout.IsCorner pos2_4_0) pos2_4_0) sizeY_4 t_4_5 size1_4_7) (update item2_5::layout._Root [2:_predefined._Cons (layout._Relative item1_2 (StdIOBasic._Vector2 (<{StdInt.+_6}> (select corner2_4_1::StdIOBasic._Vector2 0) (<{layout._if;334;31_96}> isVectorOffset_4_4 v_4_8 offset_4_3 size2_4_6 size1_4_7)) t_4_5)) tree2_1_2])) ) 
<{layout._if;334;31_96}>::I !isVectorOffset_0::B v_1 offset_2 size2_3 size1_4 = case isVectorOffset_0 (True -> select v_1::StdIOBasic._Vector2 0) (_ -> <{layout._c;336;34_95}> (StdIOBasic.alt2Of2 offset_2) size2_3 size1_4)
<{layout._c;336;34_95}>::I !_x_0 size2_1 size1_2 = case _x_0 (StdIOCommon.AlignLeft -> StdInt.zero_8) (StdIOCommon.AlignCenter -> <{StdInt./_10}> (<{StdInt.-_7}> (select size2_1::StdIOBasic._Size 0) (select size1_2::StdIOBasic._Size 0)) 2) (StdIOCommon.AlignRight -> <{StdInt.-_7}> (select size2_1::StdIOBasic._Size 0) (select size1_2::StdIOBasic._Size 0)) 
<{layout._if;326;17_94}>::I !_x_0::B !sizeY_1::I t_2::I size1_3 = case _x_0 (True -> sizeY_1) (_ -> let x_1_0::I = <{StdInt.+_6}> t_2 (select size1_3::StdIOBasic._Size 1) in case (<{StdInt.<_17}> x_1_0 sizeY_1) (True -> sizeY_1) (False -> x_1_0) )
layout._f93_93::B !_x_0::B pos2_1 = case _x_0 (True -> True) (_ -> select (layout.IsFix pos2_1)::_Tuple2 0)
<{layout._if;341;31_92}>::I !_x_0::B !corner2_1 size2_2 !itemSpaces_3 !isVectorOffset_4::B v_5 size1_6 = case _x_0 (True -> <{StdInt.+_6}> (<{StdInt.+_6}> (<{StdInt.+_6}> (select corner2_1::StdIOBasic._Vector2 1) (select size2_2::StdIOBasic._Size 1)) (select itemSpaces_3::_Tuple2 1)) (<{layout._if;342;68_90}> isVectorOffset_4 v_5)) (_ -> <{StdInt.+_6}> (<{StdInt.-_7}> (<{StdInt.-_7}> (select corner2_1::StdIOBasic._Vector2 1) (select size1_6::StdIOBasic._Size 1)) (select itemSpaces_3::_Tuple2 1)) (<{layout._if;343;68_91}> isVectorOffset_4 v_5))
<{layout._if;343;68_91}>::I !isVectorOffset_0::B v_1 = case isVectorOffset_0 (True -> select v_1::StdIOBasic._Vector2 1) (_ -> StdInt.zero_8)
<{layout._if;342;68_90}>::I !isVectorOffset_0::B v_1 = case isVectorOffset_0 (True -> select v_1::StdIOBasic._Vector2 1) (_ -> StdInt.zero_8)
layout.IsLeftOf::B !_x_0 = case _x_0 (_Tuple2 _x_1_0 _x_1_1 -> case _x_1_0 (StdIOCommon.LeftOf _x_2_0 -> True) ) (_ -> False)
layout.calcXPosition_37 !itemSpaces_0 !orientations_1 !item1_2 !id2_3 !sizeY_4::I !item2_5 = case item2_5 (layout._Root root2_1_0 rootPos_1_1 tree2_1_2 -> let _x_2_0 = layout.getLayoutItemPosSize id2_3 item2_5 in case (StdBool.not (select _x_2_0::_Tuple3 0)) (True -> layout.layoutFatalError "calcXPosition" "dependent item could not be found in rootTree") (False -> let pos2_4_0 = select root2_1_0::layout._LayoutItem 1, pos1_4_1 = select item1_2::layout._LayoutItem 1, corner2_4_2 = select _x_2_0::_Tuple3 1, offset_4_3 = layout.itemPosOffset (select pos1_4_1::_Tuple2 1) orientations_1, isVectorOffset_4_4::I = StdIOBasic.isAlt1Of2 offset_4_3, dy_4_5::I = <{layout._if;304;31_98}> isVectorOffset_4_4 v_4_7 align_4_10 size2_4_8 size1_4_9, t_4_6::B = <{StdInt.+_6}> (select corner2_4_2::StdIOBasic._Vector2 1) dy_4_5, v_4_7 = StdIOBasic.alt1Of2 offset_4_3, size2_4_8 = select _x_2_0::_Tuple3 2, size1_4_9 = select item1_2::layout._LayoutItem 2, align_4_10 = StdIOBasic.alt2Of2 offset_4_3 in <{_Tuple2!3}> (<{layout._if;293;17_100}> (layout._f99_99 (layout.IsCorner pos2_4_0) pos2_4_0) sizeY_4 t_4_6 size1_4_9) (update item2_5::layout._Root [2:_predefined._Cons (layout._Relative item1_2 (StdIOBasic._Vector2 (<{layout._if;300;31_103}> (layout.IsLeftOf pos1_4_1) corner2_4_2 size1_4_9 itemSpaces_0 isVectorOffset_4_4 v_4_7 size2_4_8) t_4_6)) tree2_1_2])) ) 
<{layout._if;300;31_103}>::I !_x_0::B !corner2_1 size1_2 !itemSpaces_3 !isVectorOffset_4::B v_5 size2_6 = case _x_0 (True -> <{StdInt.+_6}> (<{StdInt.-_7}> (<{StdInt.-_7}> (select corner2_1::StdIOBasic._Vector2 0) (select size1_2::StdIOBasic._Size 0)) (select itemSpaces_3::_Tuple2 0)) (<{layout._if;301;68_101}> isVectorOffset_4 v_5)) (_ -> <{StdInt.+_6}> (<{StdInt.+_6}> (<{StdInt.+_6}> (select corner2_1::StdIOBasic._Vector2 0) (select size2_6::StdIOBasic._Size 0)) (select itemSpaces_3::_Tuple2 0)) (<{layout._if;302;68_102}> isVectorOffset_4 v_5))
<{layout._if;302;68_102}>::I !isVectorOffset_0::B v_1 = case isVectorOffset_0 (True -> select v_1::StdIOBasic._Vector2 0) (_ -> StdInt.zero_8)
<{layout._if;301;68_101}>::I !isVectorOffset_0::B v_1 = case isVectorOffset_0 (True -> select v_1::StdIOBasic._Vector2 0) (_ -> StdInt.zero_8)
<{layout._if;293;17_100}>::I !_x_0::B !sizeY_1::I t_2::I size1_3 = case _x_0 (True -> sizeY_1) (_ -> let x_1_0::I = <{StdInt.+_6}> t_2 (select size1_3::StdIOBasic._Size 1) in case (<{StdInt.<_17}> x_1_0 sizeY_1) (True -> sizeY_1) (False -> x_1_0) )
layout._f99_99::B !_x_0::B pos2_1 = case _x_0 (True -> True) (_ -> select (layout.IsFix pos2_1)::_Tuple2 0)
<{layout._if;304;31_98}>::I !isVectorOffset_0::B v_1 align_2 size2_3 size1_4 = case isVectorOffset_0 (True -> select v_1::StdIOBasic._Vector2 1) (_ -> <{layout._c;306;34_97}> align_2 size2_3 size1_4)
<{layout._c;306;34_97}>::I !align_0 size2_1 size1_2 = case align_0 (StdIOCommon.AlignTop -> StdInt.zero_8) (StdIOCommon.AlignCenter -> <{StdInt./_10}> (<{StdInt.-_7}> (select size2_1::StdIOBasic._Size 1) (select size1_2::StdIOBasic._Size 1)) 2) (StdIOCommon.AlignBottom -> <{StdInt.-_7}> (select size2_1::StdIOBasic._Size 1) (select size1_2::StdIOBasic._Size 1)) 
layout.removeRoot !id_0 !_x_1 = case _x_1 (_predefined._Cons item_1_0 items_1_1 -> case (layout.identifyRoot id_0 item_1_0) (True -> <{_Tuple3!5}> True item_1_0 items_1_1) (False -> case (commondef.contains (layout.identifyRelative id_0) (select item_1_0::layout._Root 2)) (True -> <{_Tuple3!5}> True item_1_0 items_1_1) (False -> let _x_4_0 = layout.removeRoot id_0 items_1_1 in <{_Tuple3!5}> (select _x_4_0::_Tuple3 0) (select _x_4_0::_Tuple3 1) (_predefined._Cons item_1_0 (select _x_4_0::_Tuple3 2))) ) ) (_ -> <{_Tuple3!5}> False StdMisc.undef _x_1)
layout.calcRootPosition !itemSpaces_0 !orientations_1 !item1_2 !sDone_3 = case sDone_3 (_Tuple2 sizeY_1_0 done_1_1 -> let pos1_2_0 = select item1_2::layout._LayoutItem 1, _x_2_1 = layout.IsFix pos1_2_0 in case (select _x_2_1::_Tuple2 0) (True -> <{_Tuple2!3}> sizeY_1_0 (_predefined._Cons (layout._Root item1_2 (<{StdIOBasic.-_10}> (<{layout._c;252;31_104}> (layout.itemPosOffset (select _x_2_1::_Tuple2 1) orientations_1)) (StdIOBasic.toVector_23 (select (StdList.hd orientations_1)::_Tuple2 1))) _predefined._Nil) done_1_1)) (False -> let _x_4_0 = layout.IsRelative pos1_2_0, isRelative_4_1 = select _x_4_0::_Tuple2 0, id2_4_2::B = select _x_4_0::_Tuple2 1, _x_4_3 = layout.removeRoot id2_4_2 done_1_1 in case (case isRelative_4_1 (True -> select _x_4_3::_Tuple3 0) (False -> False) ) (True -> let _x_6_0 = <{layout._if;260;31_105}> (layout.IsRelativeX pos1_2_0) itemSpaces_0 orientations_1 item1_2 id2_4_2 sizeY_1_0 item2_6_1, item2_6_1 = select _x_4_3::_Tuple3 1 in <{_Tuple2!3}> (select _x_6_0::_Tuple2 0) (_predefined._Cons (select _x_6_0::_Tuple2 1) (select _x_4_3::_Tuple3 2))) (False -> case isRelative_4_1 (True -> layout.layoutFatalError "calculating layout" "reference to unknown Id (not caught by sortLayoutItems)") (False -> case (layout.IsCorner pos1_2_0) (True -> <{_Tuple2!3}> sizeY_1_0 (_predefined._Cons (layout._Root item1_2 StdIOBasic.zero_11 _predefined._Nil) done_1_1)) (False -> let yOffset1_8_0::I = <{layout._if;277;31_107}> (<{StdInt.==_16}> sizeY_1_0 0) yOffset_8_4 itemSpaces_0, h_8_1 = select (select item1_2::layout._LayoutItem 2)::StdIOBasic._Size 1, y_8_2::I = <{StdInt.+_6}> (<{StdInt.+_6}> sizeY_1_0 yOffset1_8_0) h_8_1, itemoffset_8_3::I = <{layout._c;273;31_106}> (layout.itemPosOffset (select pos1_2_0::_Tuple2 1) orientations_1), yOffset_8_4::I = select itemoffset_8_3::StdIOBasic._Vector2 1 in <{_Tuple2!3}> (<{layout._c;51;16_108}> (<{StdInt.<_17}> sizeY_1_0 y_8_2) y_8_2 sizeY_1_0) (_predefined._Cons (layout._Root item1_2 (update StdIOBasic.zero_11::StdIOBasic._Vector2 [1:<{StdInt.+_6}> sizeY_1_0 yOffset1_8_0]) _predefined._Nil) done_1_1)) ) ) ) ) 
<{layout._c;51;16_108}>::I !_x_0::B y_1::I sizeY_2::I = case _x_0 (True -> y_1) (_ -> sizeY_2)
<{layout._if;277;31_107}>::I !_x_0::B !yOffset_1::I itemSpaces_2 = case _x_0 (True -> yOffset_1) (_ -> <{StdInt.+_6}> (select itemSpaces_2::_Tuple2 1) yOffset_1)
<{layout._c;273;31_106}> !_x_0 = case _x_0 (StdIOBasic.Alt1Of2 v_1_0 -> v_1_0) (_ -> layout.layoutFatalError "calcRootPosition" "root item with ItemPos in {Left,Center,Right} has illegal ItemOffset argument: OffsetAlign")
<{layout._if;260;31_105}> !_x_0::B !itemSpaces_1 !orientations_2 !item1_3 !id2_4 !sizeY_5::I !item2_6 = case _x_0 (True -> layout.calcXPosition_37 itemSpaces_1 orientations_2 item1_3 id2_4 sizeY_5 item2_6) (_ -> layout.calcYPosition_38 itemSpaces_1 orientations_2 item1_3 id2_4 sizeY_5 item2_6)
<{layout._c;252;31_104}> !_x_0 = case _x_0 (StdIOBasic.Alt1Of2 v_1_0 -> v_1_0) (_ -> layout.layoutFatalError "calcRootPosition" "root item with ItemPos=Fix has illegal ItemOffset argument: OffsetAlign")
layout.stretchSize_40 !size1_0 !size2_1 = let x_1_0::I = select size1_0::StdIOBasic._Size 0, y_1_1::I = select size2_1::StdIOBasic._Size 0, x_1_2::I = select size1_0::StdIOBasic._Size 1, y_1_3::I = select size2_1::StdIOBasic._Size 1 in StdIOBasic._Size (<{layout._c;51;16_109}> (<{StdInt.<_17}> x_1_0 y_1_1) y_1_1 x_1_0) (<{layout._c;51;16_110}> (<{StdInt.<_17}> x_1_2 y_1_3) y_1_3 x_1_2)
<{layout._c;51;16_110}>::I !_x_0::B y_1::I x_2::I = case _x_0 (True -> y_1) (_ -> x_2)
<{layout._c;51;16_109}>::I !_x_0::B y_1::I x_2::I = case _x_0 (True -> y_1) (_ -> x_2)
layout.mergeBoundingBox_29 !_x_0 !_x_1 = case _x_0 (ostypes._OSRect lR_1_0 tR_1_1 rR_1_2 bR_1_3 -> case _x_1 (ostypes._OSRect lB_2_0 tB_2_1 rB_2_2 bB_2_3 -> ostypes._OSRect (<{layout._c;48;16_111}> (<{StdInt.<_17}> lR_1_0 lB_2_0) lR_1_0 lB_2_0) (<{layout._c;48;16_112}> (<{StdInt.<_17}> tR_1_1 tB_2_1) tR_1_1 tB_2_1) (<{layout._c;51;16_113}> (<{StdInt.<_17}> rR_1_2 rB_2_2) rB_2_2 rR_1_2) (<{layout._c;51;16_114}> (<{StdInt.<_17}> bR_1_3 bB_2_3) bB_2_3 bR_1_3)) ) 
<{layout._c;51;16_114}>::I !_x_0::B bB_1::I bR_2::I = case _x_0 (True -> bB_1) (_ -> bR_2)
<{layout._c;51;16_113}>::I !_x_0::B rB_1::I rR_2::I = case _x_0 (True -> rB_1) (_ -> rR_2)
<{layout._c;48;16_112}>::I !_x_0::B tR_1::I tB_2::I = case _x_0 (True -> tR_1) (_ -> tB_2)
<{layout._c;48;16_111}>::I !_x_0::B lR_1::I lB_2::I = case _x_0 (True -> lR_1) (_ -> lB_2)
layout.getRelativeBoundingBox_30 !_x_0 !boundBox_1 = case _x_0 (_predefined._Cons item_1_0 items_1_1 -> let _x_2_0 = select item_1_0::layout._Relative 1 in layout.getRelativeBoundingBox_30 items_1_1 (layout.mergeBoundingBox_29 boundBox_1 (commondef.posSizeToRect (StdIOBasic._Point2 (select _x_2_0::StdIOBasic._Vector2 0) (select _x_2_0::StdIOBasic._Vector2 1)) (select (select item_1_0::layout._Relative 0)::layout._LayoutItem 2)))) (_ -> boundBox_1)
layout.getRootBoundingBox !item_0 = case item_0 (layout._Root root_1_0 rootPos_1_1 rootTree_1_2 -> case root_1_0 (layout._LayoutItem li_2_0 li_2_1 li_2_2 -> case rootPos_1_1 (StdIOBasic._Vector2 vx_3_0 vy_3_1 -> layout.getRelativeBoundingBox_30 rootTree_1_2 (commondef.posSizeToRect (StdIOBasic._Point2 vx_3_0 vy_3_1) li_2_2)) ) ) 
layout.delimit_39 origin_0 size_1 corner_2 v_3 !_x_4 !_x_5 = case _x_4 (StdIOCommon.Fix -> case _x_5 (ostypes._OSRect rleft_2_0 rtop_2_1 rright_2_2 rbottom_2_3 -> let <{r`_3_0}>::I = <{StdInt.-_7}> rright_2_2 (select origin_0::StdIOBasic._Point2 0), <{b`_3_1}>::I = <{StdInt.-_7}> rbottom_2_3 (select origin_0::StdIOBasic._Point2 1) in case (case (StdBool.not (<{StdInt.<_17}> 0 <{r`_3_0}>)) (True -> True) (False -> StdBool.not (<{StdInt.<_17}> 0 <{b`_3_1}>)) ) (True -> <{_Tuple2!3}> 0 0) (False -> <{_Tuple2!3}> <{r`_3_0}> <{b`_3_1}>) ) ) (StdIOCommon.LeftTop -> case _x_5 (ostypes._OSRect rleft_2_0 rtop_2_1 rright_2_2 rbottom_2_3 -> let lefttop_3_0 = <{StdIOBasic.-_10}> corner_2 v_3 in <{_Tuple2!3}> (<{StdInt.-_7}> rright_2_2 (select lefttop_3_0::StdIOBasic._Vector2 0)) (<{StdInt.-_7}> rbottom_2_3 (select lefttop_3_0::StdIOBasic._Vector2 1))) ) (StdIOCommon.RightTop -> case _x_5 (ostypes._OSRect rleft_2_0 rtop_2_1 rright_2_2 rbottom_2_3 -> let righttop_3_0 = <{StdIOBasic.-_10}> (<{StdIOBasic.+_9}> corner_2 (update StdIOBasic.zero_11::StdIOBasic._Vector2 [0:select size_1::StdIOBasic._Size 0])) v_3 in <{_Tuple2!3}> (<{StdInt.-_7}> (select righttop_3_0::StdIOBasic._Vector2 0) rleft_2_0) (<{StdInt.-_7}> rbottom_2_3 (select righttop_3_0::StdIOBasic._Vector2 1))) ) (StdIOCommon.LeftBottom -> case _x_5 (ostypes._OSRect rleft_2_0 rtop_2_1 rright_2_2 rbottom_2_3 -> let leftbottom_3_0 = <{StdIOBasic.-_10}> (<{StdIOBasic.+_9}> corner_2 (update StdIOBasic.zero_11::StdIOBasic._Vector2 [1:select size_1::StdIOBasic._Size 1])) v_3 in <{_Tuple2!3}> (<{StdInt.-_7}> rright_2_2 (select leftbottom_3_0::StdIOBasic._Vector2 0)) (<{StdInt.-_7}> (select leftbottom_3_0::StdIOBasic._Vector2 1) rtop_2_1)) ) (StdIOCommon.RightBottom -> case _x_5 (ostypes._OSRect rleft_2_0 rtop_2_1 rright_2_2 rbottom_2_3 -> let rightbottom_3_0 = <{StdIOBasic.-_10}> (<{StdIOBasic.+_9}> corner_2 (StdIOBasic.toVector_16 size_1)) v_3 in <{_Tuple2!3}> (<{StdInt.-_7}> (select rightbottom_3_0::StdIOBasic._Vector2 0) rleft_2_0) (<{StdInt.-_7}> (select rightbottom_3_0::StdIOBasic._Vector2 1) rtop_2_1)) ) (StdIOCommon.Left -> case _x_5 (ostypes._OSRect rleft_2_0 rtop_2_1 rright_2_2 rbottom_2_3 -> <{_Tuple2!3}> (<{StdInt.-_7}> rright_2_2 (<{StdInt.-_7}> (select corner_2::StdIOBasic._Vector2 0) (select v_3::StdIOBasic._Vector2 0))) rbottom_2_3) ) (StdIOCommon.Center -> case _x_5 (ostypes._OSRect rleft_2_0 rtop_2_1 rright_2_2 rbottom_2_3 -> <{_Tuple2!3}> (<{StdInt.-_7}> rright_2_2 rleft_2_0) rbottom_2_3) ) (StdIOCommon.Right -> case _x_5 (ostypes._OSRect rleft_2_0 rtop_2_1 rright_2_2 rbottom_2_3 -> <{_Tuple2!3}> (<{StdInt.-_7}> (<{StdInt.-_7}> (<{StdInt.+_6}> (select corner_2::StdIOBasic._Vector2 0) (select size_1::StdIOBasic._Size 0)) (select v_3::StdIOBasic._Vector2 1)) rleft_2_0) rbottom_2_3) ) 
layout.fitRootInArea_41 !origin_0 !orientations_1 !root_2 !frameSize_3 = let _x_1_0 = select (select root_2::layout._Root 0)::layout._LayoutItem 1, _x_1_1 = layout.delimit_39 origin_0 (select (select root_2::layout._Root 0)::layout._LayoutItem 2) (select root_2::layout._Root 1) (<{layout._c;377;27_115}> (layout.itemPosOffset (select _x_1_0::_Tuple2 1) orientations_1)) (select _x_1_0::_Tuple2 0) (layout.getRootBoundingBox root_2) in layout.stretchSize_40 frameSize_3 (StdIOBasic._Size (select _x_1_1::_Tuple2 0) (select _x_1_1::_Tuple2 1))
<{layout._c;377;27_115}> !_x_0 = case _x_0 (StdIOBasic.Alt1Of2 v_1_0 -> v_1_0) (_ -> layout.layoutFatalError "fitRootInArea" "root control has illegal ItemOffset argument")
layout.calcAreaSize !orientations_0 !roots_1 !reqSize_2 !minimumSize_3 = case (StdBool.not (<{StdIOBasic.==_14}> reqSize_2 StdIOBasic.zero_15)) (True -> layout.stretchSize_40 minimumSize_3 reqSize_2) (False -> commondef.stateMap2 (layout.fitRootInArea_41 (select (StdList.hd orientations_0)::_Tuple2 1) orientations_0) roots_1 minimumSize_3) 
layout.IsRenter::B !_x_0 = case _x_0 (_Tuple2 _x_1_0 _x_1_1 -> case _x_1_0 (StdIOCommon.Center -> True) (StdIOCommon.Right -> True) ) (_ -> False)
layout.lineShift_42::I orientations_0 !_x_1 !space_2::I = case _x_1 (_Tuple2 _x_1_0 offset_1_1 -> case _x_1_0 (StdIOCommon.Center -> <{layout._c;445;11_116}> (layout.itemPosOffset offset_1_1 orientations_0) space_2) (_ -> <{layout._c;448;11_117}> (layout.itemPosOffset offset_1_1 orientations_0) space_2)) 
<{layout._c;448;11_117}>::I !_x_0 !space_1::I = case _x_0 (StdIOBasic.Alt1Of2 _x_1_0 -> case _x_1_0 (StdIOBasic._Vector2 vx_2_0 vy_2_1 -> <{StdInt.+_6}> space_1 vx_2_0) ) 
<{layout._c;445;11_116}>::I !_x_0 !space_1::I = case _x_0 (StdIOBasic.Alt1Of2 _x_1_0 -> case _x_1_0 (StdIOBasic._Vector2 vx_2_0 vy_2_1 -> <{StdInt.+_6}> (<{StdInt./_10}> space_1 2) vx_2_0) ) 
layout.cornerShift_43 orientations_0 !_x_1 !_x_2 !_x_3 = case _x_1 (_Tuple2 _x_1_0 offset_1_1 -> case _x_1_0 (StdIOCommon.LeftTop -> <{layout._c;456;11_118}> (layout.itemPosOffset offset_1_1 orientations_0)) (StdIOCommon.RightTop -> case _x_2 (StdIOBasic._Size w_3_0 h_3_1 -> case _x_3 (StdIOBasic._Size w_4_0 h_4_1 -> <{layout._c;460;11_119}> (layout.itemPosOffset offset_1_1 orientations_0) w_4_0 w_3_0) ) ) (StdIOCommon.LeftBottom -> case _x_2 (StdIOBasic._Size w_3_0 h_3_1 -> case _x_3 (StdIOBasic._Size w_4_0 h_4_1 -> <{layout._c;464;11_120}> (layout.itemPosOffset offset_1_1 orientations_0) h_4_1 h_3_1) ) ) (StdIOCommon.RightBottom -> case _x_2 (StdIOBasic._Size w_3_0 h_3_1 -> case _x_3 (StdIOBasic._Size w_4_0 h_4_1 -> <{layout._c;468;11_121}> (layout.itemPosOffset offset_1_1 orientations_0) w_4_0 w_3_0 h_4_1 h_3_1) ) ) ) 
<{layout._c;468;11_121}> !_x_0 w_1::I w_2::I h_3::I h_4::I = case _x_0 (StdIOBasic.Alt1Of2 v_1_0 -> StdIOBasic._Vector2 (<{StdInt.+_6}> (<{StdInt.-_7}> w_1 w_2) (select v_1_0::StdIOBasic._Vector2 0)) (<{StdInt.+_6}> (<{StdInt.-_7}> h_3 h_4) (select v_1_0::StdIOBasic._Vector2 1))) (_ -> layout.layoutFatalError "cornerShift _ (RightBottom,_) _ _" "ItemOffset argument is an Alignment instead of a Vector2")
<{layout._c;464;11_120}> !_x_0 h_1::I h_2::I = case _x_0 (StdIOBasic.Alt1Of2 v_1_0 -> update v_1_0::StdIOBasic._Vector2 [1:<{StdInt.+_6}> (<{StdInt.-_7}> h_1 h_2) (select v_1_0::StdIOBasic._Vector2 1)]) (_ -> layout.layoutFatalError "cornerShift _ (LeftBottom,_) _ _" "ItemOffset argument is an Alignment instead of a Vector2")
<{layout._c;460;11_119}> !_x_0 w_1::I w_2::I = case _x_0 (StdIOBasic.Alt1Of2 v_1_0 -> update v_1_0::StdIOBasic._Vector2 [0:<{StdInt.+_6}> (<{StdInt.-_7}> w_1 w_2) (select v_1_0::StdIOBasic._Vector2 0)]) (_ -> layout.layoutFatalError "cornerShift _ (RightTop,_) _ _" "ItemOffset argument is an Alignment instead of a Vector2")
<{layout._c;456;11_118}> !_x_0 = case _x_0 (StdIOBasic.Alt1Of2 v_1_0 -> v_1_0) (_ -> layout.layoutFatalError "cornerShift _ (LeftTop,_) _ _" "ItemOffset argument is an Alignment instead of a Vector2")
layout.shiftRelative !v_0 !item_1 = case item_1 (layout._Relative relative_1_0 relativePos_1_1 -> update item_1::layout._Relative [1:<{StdIOBasic.+_9}> relativePos_1_1 v_0]) 
layout.shiftRoot !offset_0 !item_1 = case item_1 (layout._Root root_1_0 rootPos_1_1 rootTree_1_2 -> update item_1::layout._Root [1:<{StdIOBasic.+_9}> rootPos_1_1 offset_0,2:StdList.map (layout.shiftRelative offset_0) rootTree_1_2]) 
layout.calcFramePosition !hMargins_0 !vMargins_1 !orientations_2 !sizeArea_3 !item_4 !done_5 = case hMargins_0 (_Tuple2 lMargin_1_0 _x_1_1 -> case vMargins_1 (_Tuple2 tMargin_2_0 _x_2_1 -> case sizeArea_3 (StdIOBasic._Size width_3_0 height_3_1 -> let pos_4_0 = select (select item_4::layout._Root 0)::layout._LayoutItem 1 in case (case (layout.IsRenter pos_4_0) (True -> True) (False -> layout.IsCorner pos_4_0) ) (True -> let v_6_0 = <{layout._if;430;27_122}> (layout.IsCorner pos_4_0) orientations_2 pos_4_0 item_4 sizeArea_3 width_3_0 in _predefined._Cons (layout.shiftRoot (StdIOBasic._Vector2 (<{StdInt.+_6}> (select v_6_0::StdIOBasic._Vector2 0) lMargin_1_0) (<{StdInt.+_6}> (select v_6_0::StdIOBasic._Vector2 1) tMargin_2_0)) item_4) done_5) (False -> _predefined._Cons (layout.shiftRoot (StdIOBasic._Vector2 lMargin_1_0 tMargin_2_0) item_4) done_5) ) ) ) 
<{layout._if;430;27_122}> !_x_0::B orientations_1 !pos_2 !item_3 sizeArea_4 width_5::I = case _x_0 (True -> layout.cornerShift_43 orientations_1 pos_2 (select (select item_3::layout._Root 0)::layout._LayoutItem 2) sizeArea_4) (_ -> StdIOBasic._Vector2 (layout.lineShift_42 orientations_1 pos_2 (<{StdInt.-_7}> width_5 (select (select (select item_3::layout._Root 0)::layout._LayoutItem 2)::StdIOBasic._Size 0))) 0)
layout.layoutItems !hMargins_0 !vMargins_1 !itemSpaces_2 !reqSize_3 !minSize_4 !orientations_5 !layout_6 = case hMargins_0 (_Tuple2 lMargin_1_0 rMargin_1_1 -> case vMargins_1 (_Tuple2 tMargin_2_0 bMargin_2_1 -> let roots_3_0 = select (commondef.stateMap2 (layout.calcRootPosition itemSpaces_2 orientations_5) (layout.sortLayoutItems layout_6) (_Tuple2 0 _predefined._Nil))::_Tuple2 1, size_3_1 = layout.calcAreaSize orientations_5 roots_3_0 (<{layout._if;161;23_123}> (StdBool.not (<{StdIOBasic.==_14}> reqSize_3 StdIOBasic.zero_15)) reqSize_3 lMargin_1_0 rMargin_1_1 tMargin_2_0 bMargin_2_1) minSize_4 in <{_Tuple2!3}> (StdIOBasic._Size (<{StdInt.+_6}> (<{StdInt.+_6}> lMargin_1_0 (select size_3_1::StdIOBasic._Size 0)) rMargin_1_1) (<{StdInt.+_6}> (<{StdInt.+_6}> tMargin_2_0 (select size_3_1::StdIOBasic._Size 1)) bMargin_2_1)) (commondef.stateMap2 (layout.calcFramePosition hMargins_0 vMargins_1 orientations_5 size_3_1) roots_3_0 _predefined._Nil)) ) 
<{layout._if;161;23_123}> !_x_0::B !reqSize_1 lMargin_2::I rMargin_3::I tMargin_4::I bMargin_5::I = case _x_0 (True -> StdIOBasic._Size (<{StdInt.-_7}> (<{StdInt.-_7}> (select reqSize_1::StdIOBasic._Size 0) lMargin_2) rMargin_3) (<{StdInt.-_7}> (<{StdInt.-_7}> (select reqSize_1::StdIOBasic._Size 1) tMargin_4) bMargin_5)) (_ -> reqSize_1)
<{layout.TD;LayoutItem}> _x_0::B = _predefined._Nil
<{layout.TD;Root}> _x_0::B = _predefined._Nil
<{layout.TD;Relative}> _x_0::B = _predefined._Nil


|| Converted Records
:: layout._LayoutItem = {!layout.liId, !layout.liItemPos, !layout.liItemSize}

:: layout._Root = {!layout.rootItem, !layout.rootPos, !layout.rootTree}

:: layout._Relative = {!layout.relativeItem, !layout.relativePos}

:: <{layout.gEq_s;}> = {!layout.gEq_s}

:: <{layout.gEq_ss;}> = {!layout.gEq_ss}

:: <{layout.gEq_sss;}> = {!layout.gEq_sss}

:: <{layout.gEq_ssss;}> = {!layout.gEq_ssss}

:: <{layout.gEq_sssss;}> = {!layout.gEq_sssss}

:: <{layout.gEq_ssssss;}> = {!layout.gEq_ssssss}

:: <{layout.gEq_sssssss;}> = {!layout.gEq_sssssss}

:: <{layout.gEq_ssssssss;}> = {!layout.gEq_ssssssss}

:: <{layout.gEq_sssssssss;}> = {!layout.gEq_sssssssss}

:: <{layout.bimap_s;}> = {layout.bimap_s}

:: <{layout.bimap_ss;}> = {layout.bimap_ss}

:: <{layout.bimap_sss;}> = {layout.bimap_sss}

