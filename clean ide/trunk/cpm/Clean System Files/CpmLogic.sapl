|| ?module? CpmLogic


CpmLogic.foldr_36 op_0 r_1 !_x_2 = case _x_2 (_predefined._Nil -> r_1) (_predefined._Cons a_1_0 x_1_1 -> op_0 a_1_0 (CpmLogic.foldr_36 op_0 r_1 x_1_1)) 
CpmLogic.anon_19::B !entry_0 = Text.endsWith_2 ".prj" entry_0
CpmLogic.snd_34 !tuple_0 = select tuple_0::_Tuple2 1
CpmLogic.anon_33 !s_0 = StdFile.fwrites (<{StdString.+++_11}> s_0 "\n")
CpmLogic.showLines !lines_0 !world_1 = let _x_1_0 = StdFile.stdio_33 world_1 in <{Data.Func.$}> CpmLogic.snd_34 (StdFile.fclose_30 (Data.Func.seqSt CpmLogic.anon_33 lines_0 (select _x_1_0::_Tuple2 0)) (select _x_1_0::_Tuple2 1))
CpmLogic.getLine world_0 = let _x_1_0 = StdFile.stdio_33 world_0, _x_1_1 = StdFile.freadline (select _x_1_0::_Tuple2 0) in _Tuple2 (select _x_1_1::_Tuple2 0) (select (StdFile.fclose_30 (select _x_1_1::_Tuple2 1) (select _x_1_0::_Tuple2 1))::_Tuple2 1)
CpmLogic.error !message_0 !world_1 = set_return_code.set_return_code_world -1 (select (StdFile.fclose_30 (StdFile.fwrites message_0 StdFile.stderr) world_1)::_Tuple2 1)
CpmLogic.mkmod_27 !basenm_0 !mty_1 = <{StdString.+++_11}> mty_1 (<{StdString.+++_11}> "module " basenm_0)
CpmLogic.writemod_32 !basenm_0 !nm_1 !pref_2 errmsg_3 !world_4 = let _x_1_0 = System.File.writeFile (<{StdFile.FileSystem;}> StdFile.fclose_30 StdFile.fopen_31 StdFile.sfopen_32 StdFile.stdio_33) nm_1 (CpmLogic.mkmod_27 basenm_0 pref_2) world_4 in case (Data.Error.isError (select _x_1_0::_Tuple2 0)) (True -> CpmLogic.error errmsg_3 (select _x_1_0::_Tuple2 1)) (False -> select _x_1_0::_Tuple2 1) 
<{CpmLogic.writeicl`_30}> !iclnm_0 !basenm_1 !pref_2 !world_3 = CpmLogic.writemod_32 basenm_1 iclnm_0 pref_2 (<{StdString.+++_11}> "Failed to write implementation module '" (<{StdString.+++_11}> basenm_1 "'")) world_3
CpmLogic.writeicl_29 !iclnm_0 !basenm_1 !_x_2 !world_3 = case _x_2 (AbsSyn.ApplicationModule -> <{CpmLogic.writeicl`_30}> iclnm_0 basenm_1 "" world_3) (AbsSyn.LibraryModule -> <{CpmLogic.writeicl`_30}> iclnm_0 basenm_1 "implementation " world_3) 
CpmLogic.writedcl_31 !dclnm_0 !basenm_1 !world_2 = CpmLogic.writemod_32 basenm_1 dclnm_0 "definition " (<{StdString.+++_11}> "Failed to write definition module '" (<{StdString.+++_11}> basenm_1 "'")) world_2
CpmLogic.writeMods_28 !iclnm_0 dclnm_1 !basenm_2 !_x_3 !world_4 = case _x_3 (AbsSyn.ApplicationModule -> CpmLogic.writeicl_29 iclnm_0 basenm_2 AbsSyn.ApplicationModule world_4) (AbsSyn.LibraryModule -> CpmLogic.writedcl_31 dclnm_1 basenm_2 (CpmLogic.writeicl_29 iclnm_0 basenm_2 AbsSyn.ApplicationModule world_4)) 
CpmLogic.help !cmd_0 !lines_1 !world_2 = CpmLogic.showLines (_predefined._Cons "CPM: Clean Project Manager" (_predefined._Cons "" (_predefined._Cons (<{StdString.+++_11}> "Usage: " cmd_0) lines_1))) world_2
CpmLogic.doModuleAction _x_0 !mn_1 !_x_2 !world_3 = case _x_2 (AbsSyn.CreateModule mt_1_0 -> let basenm_2_0 = System.FilePath.dropExtension mn_1, dclnm_2_1 = System.FilePath.addExtension basenm_2_0 "dcl", _x_2_2 = System.File.fileExists dclnm_2_1 world_3 in case (select _x_2_2::_Tuple2 0) (True -> CpmLogic.error (<{StdString.+++_11}> "Definition module '" (<{StdString.+++_11}> dclnm_2_1 "' already exists.")) (select _x_2_2::_Tuple2 1)) (False -> let iclnm_4_0 = System.FilePath.addExtension basenm_2_0 "icl", world_4_1 = select _x_2_2::_Tuple2 1, _x_4_2 = System.File.fileExists iclnm_4_0 world_4_1 in case (select _x_4_2::_Tuple2 0) (True -> CpmLogic.error (<{StdString.+++_11}> "Implementation module '" (<{StdString.+++_11}> iclnm_4_0 "' already exists.")) (select _x_4_2::_Tuple2 1)) (False -> CpmLogic.writeMods_28 iclnm_4_0 dclnm_2_1 basenm_2_0 mt_1_0 (select _x_4_2::_Tuple2 1)) ) ) (_ -> CpmLogic.help "cpm module <modulename> <action>" (_predefined._Cons "Where <action> is one of the following" (_predefined._Cons "  create [application|library]  : create a new module. Optionally specify module type (default: 'library')" _predefined._Nil)) world_3)
CpmLogic.compilerOptions = PmCompilerOptions.DefaultCompilerOptions
CpmLogic.mkProjectFile !pn_0 = System.FilePath.addExtension (System.FilePath.dropExtension pn_0) "prj"
CpmLogic.mkProject_22 !cleanhome_0 !basefilename_1 !mainmodule_2 !world_3 = let projectfile_1_0 = CpmLogic.mkProjectFile basefilename_1, edit_options_1_1 = PmTypes._EditWdOptions (PmTypes._EditOptions UtilNewlinesFile.NewlineConventionUnix) PmTypes.NoWindowPosAndSize, prj_1_2 = PmProject.PR_NewProject mainmodule_2 edit_options_1_1 CpmLogic.compilerOptions PmTypes.DefCodeGenOptions PmTypes.DefApplicationOptions <{_predefined._!Nil!}> PmTypes.DefaultLinkOptions, project_1_3 = PmProject.PR_SetRoot mainmodule_2 edit_options_1_1 CpmLogic.compilerOptions prj_1_2, _x_1_4 = StdFile.accFiles_34 (PmProject.SaveProjectFile projectfile_1_0 project_1_3 cleanhome_0) world_3 in case (StdBool.not (select _x_1_4::_Tuple2 0)) (True -> CpmLogic.error (<{StdString.+++_11}> "Could not create project file " projectfile_1_0) (select _x_1_4::_Tuple2 1)) (False -> select _x_1_4::_Tuple2 1) 
CpmLogic.mkMainAndProject_21 !cleanhome_0 !basefilename_1 !mainmodule_2 !world_3 = CpmLogic.mkProject_22 cleanhome_0 basefilename_1 mainmodule_2 (CpmLogic.doModuleAction "" mainmodule_2 (AbsSyn.CreateModule AbsSyn.ApplicationModule) world_3)
CpmLogic.openProject !cleanhome_0 !projectfile_1 !world_2 = let _x_1_0 = StdFile.accFiles_34 (PmProject.ReadProjectFile projectfile_1 cleanhome_0) world_2, _x_1_1 = select _x_1_0::_Tuple2 0 in case (select _x_1_1::_Tuple3 1) (True -> <{_Tuple2!3}> (select _x_1_1::_Tuple3 0) (select _x_1_0::_Tuple2 1)) (False -> <{_Tuple2!3}> (select _x_1_1::_Tuple3 0) (CpmLogic.error (select _x_1_1::_Tuple3 2) (select _x_1_0::_Tuple2 1))) 
CpmLogic.f_25 !_vtoString_0 !_x_1 = case _x_1 (_Tuple2 n_1_0 p_1_1 -> <{StdString.+++_11}> "  [" (<{StdString.+++_11}> (select _vtoString_0::<{StdOverloaded.toString;}> 0 n_1_0) (<{StdString.+++_11}> "]  " p_1_1))) 
CpmLogic.f_80 !_x_0 = case _x_0 (_Tuple2 n_1_0 p_1_1 -> <{StdString.+++_11}> "  [" (<{StdString.+++_11}> (StdString.toString_5 n_1_0) (<{StdString.+++_11}> "]  " p_1_1))) 
CpmLogic.showPaths !project_0 = StdList.map CpmLogic.f_80 (StdList.zip2 (_SystemEnum._from_4 0) (UtilStrictLists.StrictListToList (PmProject.PR_GetPaths project_0)))
CpmLogic.cleanup_24 exepath_0 bool1_1 bool2_2 !ps_3 = IdeState.abortLog False "" ps_3
CpmLogic.pinit_23 !force_rebuild_0::B !gst_1 = PmDriver.BringProjectUptoDate force_rebuild_0 CpmLogic.cleanup_24 gst_1
<{CpmLogic.:!_35}> !h_0 !t_1 = <{_predefined._!Cons!}> h_0 t_1
CpmLogic.saveProject !cleanhome_0 !prj_1 !projectfile_2 !world_3 = let _x_1_0 = StdFile.accFiles_34 (PmProject.SaveProjectFile projectfile_2 prj_1 cleanhome_0) world_3 in case (StdBool.not (select _x_1_0::_Tuple2 0)) (True -> CpmLogic.error "Error saving project" (select _x_1_0::_Tuple2 1)) (False -> select _x_1_0::_Tuple2 1) 
CpmLogic.doModPaths !cleanhome_0 !pn_1 !project_2 !f_3 !world_4 = let paths_1_0 = PmProject.PR_GetPaths project_2 in CpmLogic.showLines (_predefined._Cons "Successfully modified project paths" _predefined._Nil) (CpmLogic.saveProject cleanhome_0 (PmProject.PR_SetPaths False paths_1_0 (f_3 paths_1_0) project_2) pn_1 world_4)
CpmLogic.rmStrictListIdx !_x_0::I !_x_1 = case _x_0 (0 -> case _x_1 (<{_predefined._!Cons!}> _x_2_0 t_2_1 -> t_2_1) ) (_ -> case _x_1 (<{_predefined._!Cons!}> h_1_0 t_1_1 -> case (<{StdInt.<_17}> 0 _x_0) (True -> <{_predefined._!Cons!}> h_1_0 (CpmLogic.rmStrictListIdx (<{StdInt.-_7}> _x_0 1) t_1_1)) ) (_ -> StdMisc.abort (<{StdString.+++_11}> "Index " (<{StdString.+++_11}> (StdString.toString_5 _x_0) " out of bounds"))))
CpmLogic.msl_26 !_x_0 !_x_1 = case _x_0 (AbsSyn.MovePathUp -> case _x_1 (_Tuple2 _x_2_0 xs_2_1 -> case _x_2_0 (_predefined._Nil -> xs_2_1) (_ -> case xs_2_1 (_predefined._Cons x_3_0 ys_3_1 -> <{StdList.++}> (StdList.init _x_2_0) (_predefined._Cons x_3_0 (_predefined._Cons (StdList.last _x_2_0) ys_3_1))) )) ) (AbsSyn.MovePathDown -> case _x_1 (_Tuple2 _x_2_0 _x_2_1 -> case _x_2_0 (_predefined._Nil -> case _x_2_1 (_predefined._Cons x_4_0 _x_4_1 -> case _x_4_1 (_predefined._Cons y_5_0 ys_5_1 -> _predefined._Cons y_5_0 (_predefined._Cons x_4_0 ys_5_1)) ) ) (_ -> case _x_2_1 (_predefined._Nil -> _x_2_0) (_predefined._Cons y_3_0 _x_3_1 -> case _x_3_1 (_predefined._Nil -> <{StdList.++}> _x_2_0 (_predefined._Cons y_3_0 _predefined._Nil)) (_predefined._Cons y_4_0 ys_4_1 -> <{StdList.++}> _x_2_0 (_predefined._Cons y_4_0 (_predefined._Cons y_3_0 ys_4_1))) ) )) ) (AbsSyn.MovePathTop -> case _x_1 (_Tuple2 xs_2_0 _x_2_1 -> case _x_2_1 (_predefined._Nil -> xs_2_0) (_predefined._Cons y_3_0 ys_3_1 -> <{StdList.++}> (_predefined._Cons y_3_0 xs_2_0) ys_3_1) ) ) (AbsSyn.MovePathBottom -> case _x_1 (_Tuple2 xs_2_0 _x_2_1 -> case _x_2_1 (_predefined._Nil -> xs_2_0) (_predefined._Cons y_3_0 ys_3_1 -> <{StdList.++}> xs_2_0 (<{StdList.++}> ys_3_1 (_predefined._Cons y_3_0 _predefined._Nil))) ) ) 
CpmLogic.moveStrictListIdx !i_0::I !dir_1 !xs_2 = case (case (<{StdInt.<_17}> i_0 0) (True -> True) (False -> <{StdInt.<_17}> (<{StdInt.-_7}> (UtilStrictLists.LLength xs_2) 1) i_0) ) (True -> StdMisc.abort (<{StdString.+++_11}> "Index " (<{StdString.+++_11}> (StdString.toString_5 i_0) " out of bounds"))) (False -> UtilStrictLists.ListToStrictList (CpmLogic.msl_26 dir_1 (StdList.splitAt i_0 (UtilStrictLists.StrictListToList xs_2)))) 
CpmLogic.doProjectPathAction cleanhome_0 pn_1 project_2 !_x_3 !world_4 = case _x_3 (AbsSyn.AddPathAction path_1_0 -> CpmLogic.doModPaths cleanhome_0 pn_1 project_2 (<{CpmLogic.:!_35}> path_1_0) world_4) (AbsSyn.RemovePathAction i_1_0 -> CpmLogic.doModPaths cleanhome_0 pn_1 project_2 (CpmLogic.rmStrictListIdx i_1_0) world_4) (AbsSyn.ListPathsAction -> CpmLogic.showLines (_predefined._Cons "Paths for project:" (CpmLogic.showPaths project_2)) world_4) (AbsSyn.MovePathAction i_1_0 pdir_1_1 -> CpmLogic.doModPaths cleanhome_0 pn_1 project_2 (CpmLogic.moveStrictListIdx i_1_0 pdir_1_1) world_4) (_ -> CpmLogic.help "cpm project <projectname.prj> path <action>" (_predefined._Cons "Where <action> is one of the following" (_predefined._Cons "  add <path>          : add a path to the project" (_predefined._Cons "  list                : list all project paths and their index" (_predefined._Cons "  remove <i>          : remove path <i> from the list of projects" (_predefined._Cons "  move <i> <up|down>  : move path <i> up or down one position" _predefined._Nil))))) world_4)
CpmLogic.withProject !cleanhome_0 !pn_1 !f_2 !world_3 = let projectfile_1_0 = CpmLogic.mkProjectFile pn_1, _x_1_1 = CpmLogic.openProject cleanhome_0 projectfile_1_0 world_3 in CpmLogic.saveProject cleanhome_0 (f_2 (select _x_1_1::_Tuple2 0)) projectfile_1_0 (select _x_1_1::_Tuple2 1)
CpmLogic.doProjectAction cleanhome_0 pwd_1 pn_2 !_x_3 !world_4 = case _x_3 (AbsSyn.CreateProject -> let basefilename_2_0 = System.FilePath.dropExtension pn_2, mainmodule_2_1 = System.FilePath.addExtension basefilename_2_0 "icl", _x_2_2 = System.File.fileExists mainmodule_2_1 world_4 in case (StdBool.not (select _x_2_2::_Tuple2 0)) (True -> let world_4_0 = select _x_2_2::_Tuple2 1, world_4_1 = CpmLogic.showLines (_predefined._Cons (<{StdString.+++_11}> "Main module " (<{StdString.+++_11}> mainmodule_2_1 " does not exist. Create it? [y/n]")) _predefined._Nil) world_4_0, _x_4_2 = CpmLogic.getLine world_4_1 in case (<{StdChar.==_18}> (_SystemArray.select_19 (select _x_4_2::_Tuple2 0) 0) 'y') (True -> CpmLogic.mkMainAndProject_21 cleanhome_0 basefilename_2_0 mainmodule_2_1 (select _x_4_2::_Tuple2 1)) (False -> CpmLogic.error (<{StdString.+++_11}> "Failed to create project. Need " mainmodule_2_1) (select _x_4_2::_Tuple2 1)) ) (False -> CpmLogic.mkProject_22 cleanhome_0 basefilename_2_0 mainmodule_2_1 (select _x_2_2::_Tuple2 1)) ) (AbsSyn.ShowProject -> let projectfile_2_0 = CpmLogic.mkProjectFile pn_2, _x_2_1 = CpmLogic.openProject cleanhome_0 projectfile_2_0 world_4, project_2_2 = select _x_2_1::_Tuple2 0 in CpmLogic.showLines (_predefined._Cons (<{StdString.+++_11}> "Content of " (<{StdString.+++_11}> projectfile_2_0 ":")) (_predefined._Cons (<{StdString.+++_11}> "ProjectRoot..: " (PmProject.PR_GetRelativeRootDir project_2_2)) (_predefined._Cons (<{StdString.+++_11}> "Target.......: " (PmProject.PR_GetTarget project_2_2)) (_predefined._Cons (<{StdString.+++_11}> "Executable...: " (PmProject.PR_GetExecPath project_2_2)) (_predefined._Cons "Paths........:" (CpmLogic.showPaths project_2_2)))))) (select _x_2_1::_Tuple2 1)) (AbsSyn.BuildProject force_1_0 ideenvs_1_1 -> let proj_path_2_0 = UtilIO.GetLongPathName (<{System.FilePath.</>}> pwd_1 pn_2), _x_2_1 = CpmPaths.readIDEEnvs cleanhome_0 ideenvs_1_1 world_4, world_2_2 = select _x_2_1::_Tuple2 1, _x_2_3 = StdFile.accFiles_34 (PmProject.ReadProjectFile proj_path_2_0 cleanhome_0) world_2_2, _x_2_4 = select _x_2_3::_Tuple2 0, err_2_5 = select _x_2_4::_Tuple3 2 in case (case (StdBool.not (select _x_2_4::_Tuple3 1)) (True -> True) (False -> StdBool.not (<{StdString.==_2}> err_2_5 "")) ) (True -> CpmLogic.error (<{StdString.+++_11}> "CPM failed while opening project: " (<{StdString.+++_11}> err_2_5 "\n")) (select _x_2_3::_Tuple2 1)) (False -> let _x_4_0 = StdFile.stdio_33 (select _x_2_3::_Tuple2 1) in select (CpmLogic.pinit_23 force_1_0 (IdeState._GeneralSt (IdeState.initGeneral True CpmLogic.compilerOptions cleanhome_0 proj_path_2_0 (select _x_2_4::_Tuple3 0) (select _x_2_1::_Tuple2 0) (select _x_4_0::_Tuple2 0)) (select _x_4_0::_Tuple2 1) False))::IdeState._GeneralSt 1) ) (AbsSyn.ProjectPath pa_1_0 -> let projectfile_2_0 = CpmLogic.mkProjectFile pn_2, _x_2_1 = CpmLogic.openProject cleanhome_0 projectfile_2_0 world_4 in CpmLogic.doProjectPathAction cleanhome_0 projectfile_2_0 (select _x_2_1::_Tuple2 0) pa_1_0 (select _x_2_1::_Tuple2 1)) (AbsSyn.SetRelativeRoot target_1_0 -> CpmLogic.withProject cleanhome_0 pn_2 (PmProject.PR_SetRelativeRootDir target_1_0) world_4) (AbsSyn.SetTarget target_1_0 -> CpmLogic.withProject cleanhome_0 pn_2 (PmProject.PR_SetTarget target_1_0) world_4) (AbsSyn.SetExec exec_1_0 -> CpmLogic.withProject cleanhome_0 pn_2 (PmProject.PR_SetExecPath exec_1_0) world_4) (_ -> CpmLogic.help "cpm project <projectname> <action>" (_predefined._Cons "Where <action> is one of the following" (_predefined._Cons "  create                              : create a new project" (_predefined._Cons "  show                                : show project information" (_predefined._Cons "  build [--force] [--envs=filename]   : build the project. Optionally force build (default: 'false')" (_predefined._Cons "                                        Optionally specify the environments file (default: 'IDEEnvs')" (_predefined._Cons "  path                                : manage project paths" (_predefined._Cons "  target <env>                        : set target environment to <env>" (_predefined._Cons "  exec <execname>                     : set executable name to <execname>" _predefined._Nil)))))))) world_4)
CpmLogic.anon_20 cleanhome_0 pwd_1 pn_2 = CpmLogic.doProjectAction cleanhome_0 pwd_1 pn_2 (AbsSyn.BuildProject False "IDEEnvs")
CpmLogic.foldr_81 cleanhome_0 pwd_1 !r_2 !_x_3 = case _x_3 (_predefined._Nil -> r_2) (_predefined._Cons a_1_0 x_1_1 -> CpmLogic.anon_20 cleanhome_0 pwd_1 a_1_0 (CpmLogic.foldr_81 cleanhome_0 pwd_1 r_2 x_1_1)) 
CpmLogic.doMake cleanhome_0 !pwd_1 !world_2 = let _x_1_0 = System.Directory.readDirectory pwd_1 world_2, world_1_1 = select _x_1_0::_Tuple2 1 in <{CpmLogic._c;52;5_83}> (select _x_1_0::_Tuple2 0) world_1_1 pwd_1 cleanhome_0
<{CpmLogic._c;52;5_83}> !_x_0 !world_1 pwd_2 cleanhome_3 = case _x_0 (Data.Error.Error _x_1_0 -> CpmLogic.error "Failed to read current directory" world_1) (Data.Error.Ok entries_1_0 -> let xs_2_0 = StdList.filter CpmLogic.anon_19 entries_1_0 in <{CpmLogic._c;54;22_82}> xs_2_0 pwd_2 world_1 cleanhome_3) 
<{CpmLogic._c;54;22_82}> !xs_0 pwd_1 !world_2 cleanhome_3 = case xs_0 (_predefined._Nil -> CpmLogic.error (<{StdString.+++_11}> "No project file found in " pwd_1) world_2) (_ -> CpmLogic.foldr_81 cleanhome_3 pwd_1 world_2 xs_0)
CpmLogic.doEnvironmentAction cleanhome_0 pwd_1 !_x_2 !world_3 = case _x_2 (AbsSyn.ListEnvironments -> CpmLogic.error "Not implemented" world_3) (AbsSyn.ImportEnvironment ef_1_0 -> CpmLogic.error "Not implemented" world_3) (AbsSyn.RemoveEnvironment en_1_0 -> CpmLogic.error "Not implemented" world_3) (AbsSyn.ShowEnvironment en_1_0 -> CpmLogic.error "Not implemented" world_3) (AbsSyn.ExportEnvironment en_1_0 -> CpmLogic.error "Not implemented" world_3) (AbsSyn.CreateEnvironment en_1_0 -> CpmLogic.error "Not implemented" world_3) (AbsSyn.RenameEnvironment en_1_0 en`_1_1 -> CpmLogic.error "Not implemented" world_3) (AbsSyn.SetEnvironmentCompiler en_1_0 cp_1_1 -> CpmLogic.error "Not implemented" world_3) (AbsSyn.SetEnvironmentCodeGen en_1_0 cp_1_1 -> CpmLogic.error "Not implemented" world_3) (_ -> CpmLogic.help "cpm environment <action>" (_predefined._Cons "Where <action> is one of the following" (_predefined._Cons "  list                                  : list all available environments" (_predefined._Cons "  import <filepath>                     : import an environement from file <filepath>" (_predefined._Cons "  create <envname>                      : create a new environment with name <envname>" (_predefined._Cons "  remove <envname>                      : remove evironment <envname>" (_predefined._Cons "  show <envname>                        : show environment <envname>" (_predefined._Cons "  export <envname>                      : export environment <envname>" (_predefined._Cons "  rename <envname> <envname`>           : rename environment <envname> to <envname`>" (_predefined._Cons "  setcompiler <envname> <compilername>  : set compiler for <envname> to <compilername>" (_predefined._Cons "  setcodegen <envname> <codegenname>    : set codegen for <envname> to <codegenname>" _predefined._Nil)))))))))) world_3)
CpmLogic.doCpmAction cleanhome_0 pwd_1 !_x_2 !world_3 = case _x_2 (AbsSyn.CpmMake -> CpmLogic.doMake cleanhome_0 pwd_1 world_3) (AbsSyn.Project pn_1_0 pa_1_1 -> CpmLogic.doProjectAction cleanhome_0 pwd_1 pn_1_0 pa_1_1 world_3) (AbsSyn.Module mn_1_0 ma_1_1 -> CpmLogic.doModuleAction cleanhome_0 mn_1_0 ma_1_1 world_3) (AbsSyn.Environment ea_1_0 -> CpmLogic.doEnvironmentAction cleanhome_0 pwd_1 ea_1_0 world_3) (_ -> CpmLogic.help "cpm <target>" (_predefined._Cons "Where <target> is one of the following:" (_predefined._Cons "  <projectname> [--force] [--envs=filename]  : build project <projectname>." (_predefined._Cons "                                               Optionally force build (default: 'false')" (_predefined._Cons "                                               Optionally specify the environments file (default: 'IDEEnvs')" (_predefined._Cons "  project <projectname>                      : project actions" (_predefined._Cons "  module <modulename>                        : module actions" (_predefined._Cons "  make                                       : build all projects in the current directory" (_predefined._Cons "" (_predefined._Cons "Execute `cpm <target> help` to get help for specific actions." _predefined._Nil))))))))) world_3)


|| Converted Records
:: <{CpmLogic.gEq_s;}> = {!CpmLogic.gEq_s}

:: <{CpmLogic.gEq_ss;}> = {!CpmLogic.gEq_ss}

:: <{CpmLogic.gEq_sss;}> = {!CpmLogic.gEq_sss}

:: <{CpmLogic.gEq_ssss;}> = {!CpmLogic.gEq_ssss}

:: <{CpmLogic.gEq_sssss;}> = {!CpmLogic.gEq_sssss}

:: <{CpmLogic.gEq_ssssss;}> = {!CpmLogic.gEq_ssssss}

:: <{CpmLogic.gEq_sssssss;}> = {!CpmLogic.gEq_sssssss}

:: <{CpmLogic.gEq_ssssssss;}> = {!CpmLogic.gEq_ssssssss}

:: <{CpmLogic.gEq_sssssssss;}> = {!CpmLogic.gEq_sssssssss}

:: <{CpmLogic.bimap_s;}> = {CpmLogic.bimap_s}

:: <{CpmLogic.bimap_ss;}> = {CpmLogic.bimap_ss}

:: <{CpmLogic.bimap_sss;}> = {CpmLogic.bimap_sss}

