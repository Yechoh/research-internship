implementation module PmAbcMagic

import StdArray, StdEnum, StdFile, StdOverloaded, StdInt, StdMisc
import StdBool, StdList
import StdMaybe

import UtilStrictLists
from PmPath import MakeImpPathname, MakeDefPathname

import PmFileInfo
import UtilNewlinesFile
import PmDirCache

from PmTypes import LinkObjFileName, LinkLibraryName

//import RWSDebug
(->>) l r :== l

//from dodebug import trace_n`
trace_n _ f :== f

fopen1 :== fopen
fopen2 :== fopen
fopen3 :== fopen
fopen4 :== fopen
fopen5 :== fopen
fopen6 :== fopen
/*
fopen1 :: {#.Char} .Int *a -> *(Bool,.File,*a) | FileSystem a;
fopen1 s i f
	= fopen s i f
fopen2 :: {#.Char} .Int *a -> *(Bool,.File,*a) | FileSystem a;
fopen2 s i f
	= fopen s i f
fopen3 :: {#.Char} .Int *a -> *(Bool,.File,*a) | FileSystem a;
fopen3 s i f
	= fopen s i f
fopen4 :: {#.Char} .Int *a -> *(Bool,.File,*a) | FileSystem a;
fopen4 s i f
	= fopen s i f
fopen5 :: {#.Char} .Int *a -> *(Bool,.File,*a) | FileSystem a;
fopen5 s i f
	= fopen s i f
fopen6 :: {#.Char} .Int *a -> *(Bool,.File,*a) | FileSystem a;
fopen6 s i f
	= fopen s i f
*/
//--	ABCOptions: Compiler options that are stored in the abc file

:: ABCOptions =
	{ abcMemoryProfile 			:: !Bool
	, abcTimeProfile			:: !Bool
	, abcStrictnessAnalysis		:: !Bool
	, abcGiveWarnings			:: !Bool
	, abcBeVerbose				:: !Bool
	, abcGenerateComments		:: !Bool
	, abcReuseUniqueNodes 		:: !Bool 
	}

DefaultABCOptions :: ABCOptions;
DefaultABCOptions =
	{ abcMemoryProfile			= False
	, abcTimeProfile			= False
	, abcStrictnessAnalysis		= True
	, abcGiveWarnings			= False
	, abcBeVerbose				= False
	, abcGenerateComments		= False
	, abcReuseUniqueNodes 		= False
	}

//-- abc file handling


//
//	Extract the following info from the ABC file:
//		- Does it contain sequential code and stack layout info
//		- Is it a system file
//		- Compiler version it was generated by
//		- Compiler options it was generated with
//

DebugMask					:== 0;
DontReuseUniqueNodesMask	:== 1;
ParallelMask				:== 2;
NoMemoryProfileMask			:== 3;
StrictnessMask				:== 4;
NoTimeProfileMask			:== 5;
VerboseMask					:== 6;
WarningsMask				:== 7;
SystemMask					:== 8;
	
NrOfOptions					:== 9;

Combined :: !Pathname !DATE !ABCCache !Files -> (!((!Bool, !Bool, !Int, !ABCOptions),(!List Modulename, !Maybe ModuleDate, !List ModuleDate, !List LinkObjFileName, !List LinkLibraryName),!ABCCache),!Files)
Combined path date abccache files
	# (opened, file, files)	= fopen2 path FReadData files
	| not opened
		= ((dummyCinf,dummyDinf,abccache),files)
	# (file,cInfo)
							= Read_Version_and_Options file
	# (file,dInfo)			= ParseABCDependencies file
	# (_,files)				= fclose file files
	# abccache = trace_n ("COMB_ADD",path,date) abccache
	#! abccache				= AC_Add path date dInfo abccache
	= ((cInfo,dInfo,abccache),files)
where
	dummyCinf = (False,False,-1,DefaultABCOptions)
	dummyDinf = dummyDepInfo

/*
everything in place to add abc_opts caching...
need to check if cache size doesn't increase dramatically and destroys OK behaviour...
*/
GetABCCompiledInfo :: !Bool !Pathname !ABCCache !Files -> ((!Bool, !Bool, !Int, !ABCOptions, !ABCCache),!Files)
GetABCCompiledInfo update path cache files
//	# files = trace_n path files
	| (not update) && in_cache
		= ((c_sys,c_seq,c_ver,c_opt,cache),files)
	#	(opened, file, files)	= fopen1 path FReadData files
	| not opened
		= ((False,False,-1,DefaultABCOptions,cache),files)
	// otherwise
	#	(file,(sys, stack_seq,version,options))	= Read_Version_and_Options file
		(_,files)								= fclose file files
	= ((sys, stack_seq,version,options,cache),files)
where
	in_cache = False
	c_sys = False
	c_seq = False
	c_ver = -1
	c_opt = DefaultABCOptions
	
Read_Version_and_Options :: !*File -> (!*File,!(!Bool,!Bool,!Int,!ABCOptions));
Read_Version_and_Options file
	#	(eof,file)										= fend file
	| eof
		= (file,(False,False,-1,DefaultABCOptions))
	#	(str,file)										= readLine file
	#	(end_of_info,sys,stack_seq,version,abcOptions)	= Find_Version_and_Options str;
	| end_of_info
		= (file,(sys,stack_seq,version,abcOptions))
	= Read_Version_and_Options file
where
	Find_Version_and_Options :: !String -> (!Bool,!Bool,!Bool,!Int,!ABCOptions);
	Find_Version_and_Options str
		| match_endinfo < len_str					= (True,False,False,-1,DefaultABCOptions);
		| match_options - start`` == NrOfOptions	= (True,sys,stack_seq,version,abcOptions);
		= (True,False,False,-1,DefaultABCOptions);
	where 
		len_str			= size str;
		start			= SkipSpaces 0 len_str str;
		stop_endinfo	= start + 7;
		stop_comp		= start + 4;
		match_endinfo	= MatchS start stop_endinfo 8 len_str ".endinfo" str;
		match_comp		= MatchS start stop_comp 5 len_str  ".comp" str;
		start`			= SkipSpaces match_comp len_str str;
		match_version	= SkipDigits start` len_str str;
		start``			= SkipSpaces match_version len_str str;
		match_options	= SkipBits start`` len_str str;
		version			= SubStringToInt 0 start` (dec match_version) str;
		abcOptions		= (StringToCompilerOptions start`` str);
		stack_seq		= ProjectABCFile start`` str;
		sys				= SystemABCFile start`` str;
	
StringToCompilerOptions :: !Int !String -> ABCOptions;
StringToCompilerOptions start opt
	= {	abcMemoryProfile 		= not (opt .[start+NoMemoryProfileMask]		== '1'),
		abcTimeProfile			= not (opt .[start+NoTimeProfileMask]		== '1'),
		abcStrictnessAnalysis	= opt .[start+StrictnessMask]				== '1',
		abcGiveWarnings			= opt .[start+WarningsMask]					== '1',
		abcBeVerbose			= opt .[start+VerboseMask]					== '1',
		abcGenerateComments		= opt .[start+DebugMask]					== '1',
		abcReuseUniqueNodes		= not (opt.[start+DontReuseUniqueNodesMask]	== '1') };

ProjectABCFile :: !Int !String -> Bool;
ProjectABCFile start opt =	opt .[start+ParallelMask] == '0';

SystemABCFile :: !Int !String -> Bool;
SystemABCFile start opt = opt .[start+SystemMask] == '1';

SubStringToInt :: !Int !Int !Int String -> Int;
SubStringToInt acc start stop str
	| start > stop	= acc;
	# curc	= str.[start];
	| isDigit curc
		# acc`	= 10 * acc + toInt curc - toInt '0';
		= SubStringToInt acc` (inc start) stop str;
	= acc;
	

SkipSpaces	:: !Int !Int !String -> Int;
SkipSpaces i len str | i >= len ||  str.[i]  <> ' '	=  i;
	                     								=  SkipSpaces (inc i) len str;
	                     										                     
SkipBits :: !Int !Int !String -> Int;
SkipBits i len str | i >= len || (c <> '0' && c <> '1')	= i;
	                    								= SkipBits (inc i) len str;
	where 
	c	= str.[i];
	
	
SkipDigits :: !Int !Int !String -> Int;
SkipDigits i len str | i >= len || c < '0' || '9' < c	= i;
														= SkipDigits (inc i) len str;
	where 
	c	= str.[i];
	
MatchS	:: !Int !Int !Int !Int !String !String -> Int;
MatchS start stop patlen strlen pat str
	| stop >= strlen					= stop;
	| MatchS2 0 start patlen pat str	= inc stop;
										= MatchS (inc start) (inc stop) patlen strlen pat str;
where
	MatchS2 :: !Int !Int !Int !String !String -> Bool;
	MatchS2 patpos strpos patlen pat str
		| patpos >= patlen					= True;
		| pat.[patpos] == str.[strpos]		= MatchS2 (inc patpos) (inc strpos) patlen pat str;
											= False;
										
//--

:: ModuleDate :== DateTime

//-- Cached parse

//:: *ABCCache :== [ABCStuff]
:: *ABCCache =
	{ cache	:: !*{!ABCStuff}
	, curi	:: !Int
	, maxi	:: !Int
	}
/*
reimplement as strict/unique array?
*/

ABCCacheSize :==  512//256//30	//1024

:: ABCStuff =
	{ c_path :: !Pathname
	, c_date :: !DATE
	, c_info :: !ABCInfo
	}

:: ABCInfo :==
	( !List Modulename			// dep mods
	, !Maybe ModuleDate			// mod date
	, !List ModuleDate			// dep dates
	, !List LinkObjFileName		// dep objs
	, !List LinkLibraryName		// dep libs
	)

EmptyABCS =
	{ c_path = ""
	, c_date = NoDate
	, c_info =
	( Nil
	, Nothing
	, Nil
	, Nil
	, Nil
	)
	}
AC_Init :: !ABCCache
//AC_Init = []
AC_Init =
	{ cache = createArray ABCCacheSize EmptyABCS//createArray
	, maxi	= -1
	, curi	= 0
	}

AC_Add :: !Pathname !DATE !ABCInfo !*ABCCache -> !*ABCCache
AC_Add path date info abccache//=:{maxi,curi}
//	= take ABCCacheSize ([{c_path=path,c_date=date,c_info=info}:cache])
//	#! (c,abccache) = abccache!cache
//	#! (i,abccache) = abccache!curi
	#! c = abccache.cache
	#! i = abccache.curi
	#! m = abccache.maxi
	#! c = {c & [i] = newstuff}
	= //trace_n (i,m)
		{ abccache
		& cache = c
		, curi = (inc i) mod ABCCacheSize
		, maxi = if (m < (dec ABCCacheSize)) i m
		}
where
	newstuff :: !ABCStuff
	newstuff = {c_path=path,c_date=date,c_info=info}

UCache :: !ABCStuff !Int !*{!ABCStuff} -> !*{!ABCStuff}
UCache e i a = {a & [i] = e}

/*
g :: (a -> .Bool) .(b a) -> (.Maybe a,.(b a)) | Array .b & select_u , size_u a;g h a = f 0 a
where
	m = size a
	f x a//=:[x=:y]
		| x >= m = (Nothing,a)
		#! y = a.[x]
		| h y = (Just y,a)
		= f (inc x) a
*/

ParseABCDependencies` :: !Pathname !DATE !*ABCCache !Files -> ((!Bool, !List Modulename, !Maybe ModuleDate, !List ModuleDate, !List LinkObjFileName, !List LinkLibraryName, !*ABCCache/*, !FileInfoCache*/), !Files);
ParseABCDependencies` path abcdate abccache files
	= AC_Look path abccache files
where
	AC_Look path abccache=:{maxi} files
		# date = abcdate
		# (foundl,abccache) = uSeqArray
								(\{c_path,c_date}-> c_path == path && eqDate c_date date)
								(\{c_info}->c_info)
								(maxi)
								abccache
		| isEmpty foundl
			# (opened,file,files)		= fopen3 path FReadData files
			| not opened
				# (b,c,d,e,f)			= dummyDepInfo
				# abccache = trace_n ("QUOTE_DUMMY",path,date) abccache
				= ((False,b,c,d,e,f,abccache),files)
			# (file,(b,c,d,e,f))		= ParseABCDependencies file
			# (_,files)					= fclose file files
			# abccache = trace_n ("QUOTE_ADD",path,date) abccache
			#! abccache					= AC_Add path date (b,c,d,e,f) abccache
			= ((True,b,c,d,e,f,abccache),files)
		# abccache = trace_n ("QUOTE_FOUND",path,date) abccache
		# (b,c,d,e,f) = hd foundl
		= ((True,b,c,d,e,f,abccache),files)

	uSeqList f g acc [] = ([],reverse acc)
	uSeqList f g acc [h:t]
		| f h		= ([g h],reverse acc ++ [h:t])
		= uSeqList f g [h:acc] t
	
	uSeqArray f g n c
		| n < 0		= ([],c)
		# (r,c)		= c!cache.[n]
		| f r		= ([g r],c)
		= uSeqArray f g (dec n) c
	
	eqDate l r
		=  l.exists == r.exists
		&& l.yy == r.yy
		&& l.mm == r.mm
		&& l.dd == r.dd
		&& l.DATE.h == r.DATE.h
		&& l.m == r.m
		&& l.s == r.s

//	Find the module depencies in the .abc files

dummyDepInfo = (Nil, Nothing, Nil, Nil, Nil)

ParseABCDependencies
	:: !*File
	-> (!*File, !(!List Modulename, !Maybe ModuleDate, !List ModuleDate, !List LinkObjFileName, !List LinkLibraryName))
ParseABCDependencies file
	= Parse_lines file dummyDepInfo
where 
	Parse_lines
		::  !*File  !(!(List Modulename), !(Maybe ModuleDate), !(List ModuleDate), !(List LinkObjFileName), !(List LinkLibraryName))
		-> (!*File, !(!List Modulename, !Maybe ModuleDate, !List ModuleDate, !List LinkObjFileName, !List LinkLibraryName))
	Parse_lines file depInfo
		# (eof, file)				= fend file
		| eof
			= (file, depInfo)
		# (line, file) 				= readLine file
		  (depInfo, end_of_info)	= Parse_line line depInfo
		| end_of_info
			= (file, depInfo)
		= Parse_lines file depInfo
	
	Parse_line
		:: !String !(!(List Modulename), !(Maybe ModuleDate), !(List ModuleDate), !(List LinkObjFileName), !(List LinkLibraryName))
		-> (!(!List Modulename, !Maybe ModuleDate, !List ModuleDate, !List LinkObjFileName, !List LinkLibraryName), !Bool);
	Parse_line str (modnames, mmoddate, depdates, objnames, libnames)
		| match_endinfo < len_str
			=  ((modnames, mmoddate, depdates, objnames, libnames), True)
		| match_depend < len_str && last_q_depdate < len_str
			= ((modname :! modnames, mmoddate, S2DT depdate :! depdates, objnames, libnames), False)
		| match_depend < len_str && last_q_depend < len_str
			= ((modname :! modnames, mmoddate, emptydate :! depdates, objnames, libnames), False)
		| match_impobj < len_str && last_q_impobj < len_str
			= ((modnames, mmoddate, depdates, objname :! objnames, libnames), False)
		| match_implib < len_str && last_q_implib < len_str
			= ((modnames, mmoddate, depdates, objnames, libname :! libnames), False)
//		| match_date < len_str && last_q_moddate < len_str
//			= ((modnames, Just (S2DT moddate), depdates, objnames, libnames), False)
		| match_module < len_str && last_q_moddate < len_str
			#! moddate = S2DT moddate
			= ((modnames, Just moddate, depdates, objnames, libnames), False)
		=  ((modnames, mmoddate, depdates, objnames, libnames), False)
	where 
		emptydate = ({year`=0,month`=0,day`=0,dayNr`=0},{hours`=0,minutes`=0,seconds`=0})
		len_str			= size str
		start			= SkipSpaces 0 len_str str
		stop_endinfo	= start +  7; // dec (size ".endinfo")
		stop_depend		= startplussix; // dec (size ".depend")
		stop_importobj	= startplussix; // dec (size ".impobj")
		stop_importlib	= startplussix; // dec (size ".implib")
//		stop_date		= start +  4; // dec (size ".date")
		stop_module		= startplussix; // dec (size ".module")
		startplussix	= start +  6;
		match_endinfo	= MatchS start stop_endinfo 8 len_str ".endinfo" str
		match_depend	= MatchS start stop_depend 7 len_str ".depend" str
		match_impobj	= MatchS start stop_importobj 7 len_str ".impobj" str
		match_implib	= MatchS start stop_importlib 7 len_str ".implib" str
//		match_date		= MatchS start stop_date 5 len_str ".date" str
		match_module	= MatchS start stop_module 7 len_str ".module" str
		(last_q_depend, modname)
						= characters_between_apostrophes match_depend len_str str
		(last_q_impobj, objname)
						= characters_between_apostrophes match_impobj len_str str	
		(last_q_implib, libname)
						= characters_between_apostrophes match_implib len_str str
		(last_q_depdate, depdate)
						= characters_between_apostrophes (inc last_q_depend) len_str str
//		(last_q_moddate, moddate)
//						= characters_between_apostrophes match_date len_str str
		(last_q_modname, mainmodname)
						= characters_between_apostrophes match_module len_str str
		(last_q_moddate, moddate)
						= characters_between_apostrophes (inc last_q_modname) len_str str

characters_between_apostrophes :: !.Int !.Int !.String -> .(!Int, !String)
characters_between_apostrophes after_keyword_pos len_str str
	= (last_q, str % (inc first_q, dec last_q))
where
	start`			= SkipSpaces after_keyword_pos len_str str
	first_q			= FindQuoteChar str len_str start`
	last_q			= FindQuoteChar str len_str (inc first_q)
	
FindChar	:: !Char !.String !.Int !Int -> Int;
FindChar c line linelen pos
	| pos >= linelen		=  pos;
	| c ==  line.[pos]		=  pos;
							=  FindChar c line linelen (inc pos);
	
//	FindQuoteChar	:: !String !Int !Int -> Int;
FindQuoteChar str len pos	:== FindChar '\"' str len pos;
	
//--

/*
ABC dates format:
.date "module.icl modified date,time"
.depend "modulename" "dcl modified date,time"
*/
DT2S :: !DateTime -> String
DT2S (date,time) = "\"" +++ yyyymmddnhhmmss +++"\""
where
	yyyymmddnhhmmss = yyyy +++ mm +++ dd /*+++ nn*/ +++ hs +++ ms +++ ss
	yyyy = pad 4 date.year`
	mm = pad 2 date.month`
	dd = pad 2 date.day`
//	nn = pad 1 date.dayNr`
	hs = pad 2 time.hours`
	ms = pad 2 time.minutes`
	ss = pad 2 time.seconds`
	pad n x
		# s = toString x
		# l = size s
		# p = {'0' \\ i <- [1..n-l]}
		= p+++s

S2DT :: !String -> DateTime
S2DT s = (date,time)
where
	date = {year`=yy,month`=mm,day`=dd,dayNr`=nn}
	time = {hours`=hs,minutes`=ms,seconds`=ss}
	yy = toInt (s%(0,3))
	mm = toInt (s%(4,5))
	dd = toInt (s%(6,7))
	nn = 0//toInt (s%(8,8))
	hs = toInt (s%(8,9))	//(s%(9,10))
	ms = toInt (s%(10,11))	//(s%(11,12))
	ss = toInt (s%(12,13))	//(s%(13,14))

//--

PatchABCDates :: !Pathname !*DirCache !*Files -> ((Bool,*DirCache),*Files)
PatchABCDates abcpath dircache files
	#! (opened,file,files)		= fopen4 abcpath FReadData files
	| not opened
		=  ((False, dircache),files)
	# (file, lines,dircache)	= Patch_lines False file Nil dircache
	# (closed,files)			= fclose file files
	| not closed
		=  ((False, dircache),files)
	#! (opened,file,files)		= fopen5 abcpath FWriteData files
	| not opened
		= ((False, dircache),files)
	#! (written,file)			= Write_lines file lines
	#! (closed,files)			= fclose file files
	=  ((written && closed, dircache),files)
where
	modname = RemovePath (MakeImpPathname abcpath)

	dateline modname dircache
		# (_,_,moddate,dircache) = DC_Search modname dircache
		= ("|| .module "+++ modname +++ " \"" +++ modname+++ "\" "+++DT2S moddate+++"\n",dircache)
//		= ("|| .date "+++DT2S moddate+++"\n",dircache)

	dependline depname dircache
		# (_,_,depdate,dircache) = DC_Search (MakeDefPathname depname) dircache
		= (".depend \""+++depname+++"\" || "+++DT2S depdate+++"\n",dircache)

	Patch_lines datedone file lines dircache
		#	(eof, file)									= fend file
		| eof
			| datedone
				# lines = Reverse lines
				= (file, lines,dircache)
			# (dl,dircache) = dateline modname dircache
			# lines = dl :! lines
			# lines = Reverse lines
			= (file, lines,dircache)
		#	(line, file) 								= readLine file
			(end_of_info,datedone,line,dircache)		= Patch_line datedone line dircache
		| end_of_info
			| datedone
				# lines = line :! lines
				= Copy_lines file lines dircache
			# (dl,dircache) = dateline modname dircache
			# lines = dl :! lines
			# lines = line :! lines
			= Copy_lines file lines dircache
		= Patch_lines datedone file (line :! lines) dircache
	Copy_lines file lines dircache
		#	(eof, file)									= fend file
		| eof
			# lines = Reverse lines
			= (file, lines,dircache)
		#	(line, file) 								= readLine file
		= Copy_lines file (line :! lines) dircache
	Write_lines file Nil
		= (True,file)
	Write_lines file (line :! lines)
		# file = file <<< line
		= Write_lines file lines
	Patch_line datedone str dircache
		| match_endinfo < len_str
			=  (True,datedone,str,dircache)
		| match_depend < len_str && last_q_depend < len_str
			# (line,dircache) = dependline modname dircache
			= (False,datedone,line,dircache)	// patch on mod date
		| match_date < len_str && last_q_date < len_str
			# (line,dircache) = dateline modname dircache
			= (False,True,line,dircache)
		=  (False,datedone,str,dircache)
	where 
		len_str			= size str
		start			= SkipSpaces 0 len_str str
		stop_endinfo	= start +  7; // dec (size ".endinfo")
		stop_depend		= start +  6; // dec (size ".depend")
		stop_date		= start +  4; // dec (size ".date")
		match_endinfo	= MatchS start stop_endinfo 8 len_str ".endinfo" str
		match_depend	= MatchS start stop_depend 7 len_str ".depend" str
		match_date		= MatchS start stop_date 5 len_str ".date" str
		(last_q_depend, modname)
						= characters_between_apostrophes match_depend len_str str
		(last_q_date, _/*date*/)
						= characters_between_apostrophes match_date len_str str
		characters_between_apostrophes :: !Int !Int !String -> (!Int, !String)
		characters_between_apostrophes after_keyword_pos len_str str
			= (last_q, str % (inc first_q, dec last_q))
		where
			start`			= SkipSpaces after_keyword_pos len_str str
			first_q			= FindQuoteChar str len_str start`
			last_q			= FindQuoteChar str len_str (inc first_q)

// patch abc file of system module for change in profiling settings

PatchSystemABC :: !Int !Bool !Pathname /*!Bool*/ !Bool !*Files -> (!Bool, !*Files)
PatchSystemABC version doPatch abcPath /*memoryProfile*/ timeProfile files
	| not doPatch
		=	(True, files)
	# (opened, file, files)
		=	fopen6 abcPath FReadData files
	| not opened
		=	(False, files)  ->> (abcPath +++ " not opened\n")
	# (patched, file)
		=	patchFile file
	# (closed, files)
		=	fclose file files
	= (patched && closed, files)
where
	patchFile :: *File -> (Bool, *File)
	patchFile file
		# (firstLine, file)
			=	freadline file	//readLine file
		# (patched, firstLine)
			=	patchLine firstLine//(RemoveNewlineChar firstLine)	// ??? RemoveNewlineChar ???
		| not patched
			=	(False, file)  ->> (abcPath +++ " not patched\n")
		# (reopened, file)
			=	freopen file FAppendData
		| not reopened
			=	(False, file)  ->> (abcPath +++ " not reopened\n")

		# (sought, file)
			=	fseek file 0 FSeekSet
		| not sought
			=	(False, file)  ->> (abcPath +++ " not sought\n")
		# file
			=	fwrites firstLine file
		=	(True, file)
/*
	RemoveNewlineChar :: *{#Char} -> *{#Char}
	RemoveNewlineChar string
		| stringSize > 0 && string.[stringSize - 1] == '\n'
			=	string
		=	string
	where
		stringSize
			=	size string
*/
	patchLine :: {#Char} -> (Bool, {#Char})
	patchLine line
		| found
			/* sanity checks ...
			| abcNoMemoryProfile <> '0' && abcNoMemoryProfile <> '1'
				=	(False, line) ->> abcPath +++ " incorrect memory offset\n" 
			| abcNoTimeProfile <> '0' && abcNoTimeProfile <> '1'
				=	(False, line) ->> abcPath +++ " incorrect time offset\n" 
			| /*(abcNoMemoryProfile == '0') == memoryProfile &&*/ (abcNoTimeProfile == '0') == timeProfile
				=	(False, line) ->> abcPath +++ " unnecessary patch\n"
			... sanity checks */
			// otherwise
				=	(found, {copy line & /*[offset+NoMemoryProfileMask] = if memoryProfile '0' '1',*/
				                         [offset+NoTimeProfileMask] = if timeProfile '0' '1'})
//		| otherwise
			=	(False, line)
	where
		(found, offset)
			=	findOptionStringOffset line
		/* sanity checks ...
		abcNoMemoryProfile
			=	line.[offset+NoMemoryProfileMask]
		abcNoTimeProfile
			=	line.[offset+NoTimeProfileMask]
		... sanity checks */


	copy array
		=	{el \\ el <-: array}

	findOptionStringOffset :: {#Char} -> (Bool, Int)
	findOptionStringOffset string
		=	(offset+NrOfOptions < stringLength, offset)
		where
		
			offset
				=	skipSpaces (match (toString version) (skipSpaces (match ".comp" (skipSpaces 0))))
			stringLength
//				=	size string - 1
				=	size string			// onduidelijk welke we hier moeten hebben...

			skipSpaces :: Int -> Int
			skipSpaces offset
				| offset >= stringLength || string.[offset] <> ' '
					=	offset
				| otherwise
					=	skipSpaces (offset+1)

			match :: {#Char} Int -> Int
			match matchString offset
				| offset + matchLength <= stringLength && string % (offset, offset+matchLength-1) == matchString
					=	offset + matchLength
				| otherwise
					=	stringLength
					where
						matchLength
							=	size matchString
