20170216-133333["Bin",4,["TaskId",45,3087],[{"taskId":["TaskId",45,3088],"index":0,"detached":false,"attributes":["Tip"],"value":["NoValue"],"createdAt":7,"lastEvent":7}],["Bin",1,["TaskId",45,3071],[],["Tip"],["Tip"]],["Bin",2,["TaskId",45,3088],[{"taskId":["TaskId",45,3089],"index":0,"detached":false,"attributes":["Tip"],"value":["Value",["Left",["implementation module directoryBrowsing\r\n\r\nimport iTasks\r\n\r\nimport iTasks.API.Extensions.Admin.WorkflowAdmin\r\nimport iTasks.UI.Layout, iTasks.UI.Definition, iTasks.UI.Editor.Builtin\r\nimport iTasks.API.Extensions.Editors.Ace\r\nimport StdFile, System.File\r\nimport System.Directory\r\nimport System.FilePath\r\nimport Data.Error\r\n\r\n\r\n:: Directory = Dir FileName [Directory] [FileName]\r\n:: FileName :== String \t\t\t\t\t\t\t\t\t\/\/ File name without path, but with extension\r\n\r\nderive class iTask Directory\r\nderive class iTask ChoiceNode\r\n\r\nselectIcon pwd _ \t = Nothing\t\/\/ don't know where to store icons yet\r\nselectIcon pwd \"icl\" = Just (pwd <\/> \"WebPublic\" <\/> \"Clean.icl.ico\")\r\nselectIcon pwd \"dcl\" = Just (pwd <\/> \"WebPublic\" <\/> \"Clean.dcl.ico\")\r\nselectIcon pwd \"prj\" = Just (pwd <\/> \"WebPublic\" <\/> \"Clean.prj.ico\")\r\nselectIcon pwd \"abc\" = Just (pwd <\/> \"WebPublic\" <\/> \"Clean.abc.ico\")\r\nselectIcon pwd _ \t = Nothing\r\n\r\n\r\n\/\/ Directory & file selection using a tree\r\n\r\nselectFromTree :: FilePath (FileName -> Bool) -> Task FilePath\r\nselectFromTree pwd isWantedFile\r\n\t=\t\t\t\tfetchDirectories pwd isWantedFile\r\n\t>>= \\dirs ->\twithShared dirs (\\dir -> (editSelectionWithShared \"dirs\" False (SelectInTree (\\d -> fst (conv 0 d)) (\\_ idx -> idx)) dir (\\_ -> []) ))\r\n\t>&> \\mbsel ->\tviewSharedInformation \"Selected: \" [ViewAs (findSelected pwd (conv 0 dirs))] mbsel\t\t\t\r\n\t>>= \\mbsel -> \treturn (findSelected pwd (conv 0 dirs) mbsel)\r\n\r\nwhere\r\n\tedit dirs =\teditSelection \"dirs\" False (SelectInTree toTree fromTree) dirs [0..n]\r\n\twhere\r\n\t\t(toTree,n) \t \t= conv 0 dirs\r\n\t\tfromTree _ idx \t= idx\r\n\r\n\tconv :: Int Directory -> ([ChoiceNode],Int)\r\n\tconv i (Dir pwd dirs files) = convDirs i pwd dirs files\r\n\twhere\r\n\t\tconvDirs i pwd dirs files\r\n\t\t# (cds,ii)\t= convAllDirs (i+1) dirs\r\n\t\t# (cfs,iii)\t= convFiles ii files\r\n\t\t= ([{id = i, label = dropDirectory pwd, icon = Nothing, expanded = False, children = cds ++ cfs}],iii)\r\n\t\r\n\t\tconvAllDirs\ti [] = ([],i)\r\n\t\tconvAllDirs i [Dir pwd dirs fils:ds]\r\n\t\t# (cd,ii) \t= convDirs i pwd dirs fils\r\n\t\t# (cds,iii)\t= convAllDirs ii ds\r\n\t\t= (cd++cds,iii)\r\n\t\r\n\t\tconvFiles i [] \r\n\t\t\t\t\t= ([],i)\r\n\t\tconvFiles i [f:fs]\r\n\t\t# cf\t\t= {id = i, label = f, icon = selectIcon pwd (takeExtension f), expanded = False, children = []}\r\n\t\t# (cfs,j) \t= convFiles (i+1) fs\r\n\t\t= ([cf:cfs],j) \r\n\r\nfindSelected :: FilePath ([ChoiceNode],Int) (Maybe [Int]) -> String\r\nfindSelected pwd (nodes,i) Nothing  =  pwd\r\nfindSelected pwd (nodes,i) (Just idx)\r\n| idx == [] \t\t\t\t= pwd\r\n| i < hd idx \t\t\t\t= pwd\r\n| hd idx == 0\t\t\t\t= pwd\r\n= travers (takeDirectory pwd) nodes (hd idx)\r\nwhere\r\n\ttravers pwd [] _\t\t\t= pwd\r\n\ttravers pwd [n1] i\r\n\t| n1.ChoiceNode.id == i \t= pwd <\/> n1.ChoiceNode.label\r\n\t| otherwise\t\t\t\t\t= travers (pwd <\/> n1.ChoiceNode.label) n1.ChoiceNode.children i\r\n\ttravers pwd [n1,n2:ns] i \r\n\t| i >= n2.ChoiceNode.id \t= travers pwd [n2:ns] i\r\n\t| otherwise\t\t\t\t\t= travers pwd [n1] i\r\n\r\n\r\n\/\/ directory browsing\r\n\r\n\r\nbrowseDirectory :: (FilePath -> Bool) -> Task ((FilePath,[FilePath]),Maybe FilePath)\r\nbrowseDirectory pred\r\n \t=\t\t\t\t\t\t\t\t\tgetPwdName\r\n \t>>- \\pwd -> \t\t\t\t\t\tselectFile pwd pred\r\n\t>>- \\((pwd,paths),chosen)\t->\t\treturn ((pwd,paths),chosen)\r\nwhere\r\n\tselectFile :: FilePath (FilePath -> Bool) -> Task ((FilePath,[FilePath]),Maybe FilePath)\r\n\tselectFile pwd pred\r\n\t \t=\t\t\t\t\treadDir pwd\r\n\t\t>>- \\all ->\t\t\tselectDirs pwd all pred \/\/ only show wanted files \r\n\t\t>>- \\(dirs,files) ->\r\n\t\tlet all = dirs ++ files in\t\t\r\n\t\t(\t\t\t\t\tenterChoice  pwd [ChooseFromGrid id] all \r\n\t\t>>*\t\t\t\t\t[ OnAction (Action \"Up\") (always (selectFile (takeDirectory pwd) pred))\t\r\n\t\t\t\t\t\t\t, OnAction  ActionCancel (always (return ((pwd,all),Nothing)))\r\n\t\t\t\t\t\t\t, OnAction  ActionOpen   (hasValue (continue pwd dirs files pred))\r\n\t\t\t\t\t\t\t, OnAction  ActionNew    (always (createNewFile pwd >>| selectFile pwd pred))\r\n\t\t \t\t\t\t\t]\r\n\t\t)\r\n\twhere\r\n\t continue pwd dirs files pred chosen\r\n\t\t= if (isMember chosen dirs)  \t\r\n\t\t\t\t(selectFile (pwd <\/> chosen) pred)\r\n\t\t\t\t(return ((pwd,dirs ++ files),Just chosen))\r\n\t\t\t\t\r\n\t createNewFile pwd \r\n\t \t= \t\t\t\tupdateInformation \"Give new file name: \" [] \"name.icl\"\r\n\t \t>>= \\name ->\tcreateFile pwd name \"\"\r\n\r\nfetchDirectories ::  FilePath (FileName -> Bool) -> Task Directory\r\nfetchDirectories pwd pred\r\n\t= \t\t\t\t\t\treadDir pwd\r\n\t>>= \\fnames ->\t\t\tselectDirs pwd fnames pred\r\n\t>>= \\(dnames,fnames) ->\tfetch pwd dnames\r\n\t>>= \\dirs -> \t\t\treturn (Dir pwd dirs fnames)\r\nwhere\r\n  fetch pwd []  \r\n\t= \t\t\t\t\t\treturn []\r\n  fetch pwd [d:ds]   \r\n\t=\t\t\t\t\t\tfetchDirectories (pwd <\/> d) pred\r\n\t>>= \\dir ->\t\t\t\tfetch pwd ds \r\n\t>>= \\dirs ->\t\t\treturn [dir:dirs]\r\n\t\r\nselectDirs :: FilePath [FileName] (FileName -> Bool) -> Task ([FileName],[FileName])\r\nselectDirs pwd paths pred = selDirs` paths ([],[]) \r\nwhere\r\n\tselDirs` [] (dirs,nodirs) \r\n\t\t= return (drop 2 (reverse dirs),sort (filter pred nodirs))\r\n\tselDirs` [f:fs] (dirs,nodirs)\r\n\t\t=\t\t\tisDirectory (pwd <\/> f)\r\n\t\t>>= \\yes -> if yes (selDirs` fs ([f:dirs],nodirs))\r\n\t\t\t\t\t\t   (selDirs` fs (dirs,[f:nodirs]))\r\n\r\nisDirectory :: FilePath -> Task Bool\r\nisDirectory file = worldIO isDir\r\nwhere\r\n\tisDir world\r\n\t# (res,world) \t=\tgetFileInfo file world\r\n\t| isError res\t=\t(Error (\"Cannot get directory info from file: \" +++ file), world) \r\n\t= (Ok (fromOk res).directory,world)\r\n\r\nreadDir :: FilePath  -> Task [FileName]  \/\/ returns file names (no path)\r\nreadDir pwd  = worldIO readDir`\r\nwhere\r\n\treadDir` world\r\n\t# (res,\tworld)\t\t= readDirectory pwd world\r\n\t| isError res\t\t= (Error (\"Cannot read directory: \" +++ pwd), world)\r\n\t# names\t\t\t\t= fromOk res\r\n\t= (Ok names, world)\t\t\/\/ includes \".\" and \"..\"\r\n\r\ngetPwdName :: Task FilePath\r\ngetPwdName\r\n\t=\t\t\t\t\tworldIO getPwd`\r\nwhere\r\n\tgetPwd` world \t\r\n\t# (res, world)\t= \tgetCurrentDirectory world \r\n\t| isError res\t= \t(Error \"Cannot open current directory\", world)\r\n\t# pwd\t\t\t= \tfromOk res\r\n\t= (Ok pwd, world)\r\n\r\ncreateFile :: FilePath FileName String -> Task ()\r\ncreateFile path name content = worldIO (create (path <\/> name) content)\r\nwhere\r\n\tcreate filename content world\r\n\t# (ok,file,world)\t\t\t= fopen filename FWriteText world\r\n\t| not ok\t\t\t\t\t= (Error (\"Cannot open file: \" +++ filename),world)\r\n\t# file\t\t\t\t\t\t= fwrites content file\r\n\t# (ok,world)\t\t\t\t= fclose file world\r\n\t| not ok\t\t\t\t\t= (Error (\"Cannot open file: \" +++ filename),world)\r\n\t= (Ok (),world)\t\r\n\t\r\nreadFromFile :: String -> Task String\r\nreadFromFile path = worldIO (read path) \r\nwhere \r\n\tread path world\r\n\t# (ok,file,world)\t\t\t= fopen path FReadData world\r\n\t| not ok\t\t\t\t\t= (Error (\"Cannot find file: \" +++ path), world) \r\n\t# (res,file)\t\t\t\t= readAll file\r\n\t# (ok,world)\t\t\t\t= fclose file world\r\n\t| not ok\t\t\t\t\t= (Error (\"Cannot close file: \" +++ path), world)\r\n    = case res of\r\n        Error e                 = (Error (\"Cannot read File:\" +++ path), world)\r\n        Ok content              = (Ok content, world)\r\n\r\nwriteToFile :: String String -> Task String\r\nwriteToFile path content = worldIO (write path content) \r\nwhere \r\n\twrite path content world\r\n\t# (ok,file,world)\t\t\t= fopen path FWriteText world\r\n\t| not ok\t\t\t\t\t= (Error (\"Cannot open file: \" +++ path), world)\r\n\t# file\t\t\t\t\t\t= fwrites content file\r\n\t# (ok,world)\t\t\t\t= fclose file world\r\n\t| not ok\t\t\t\t\t= (Error (\"Cannot close file: \" +++ path) ,world)\r\n\t= (Ok content, world)\r\n\r\n\r\n\r\n","15:03:20Error [directoryBrowsing.dcl,3]: iTasks.dcl could not be imported\r\nError [directoryBrowsing.icl,9]: iTasks.API.Extensions.Admin.WorkflowAdmin.dcl could not be imported\r\nError [directoryBrowsing.icl,11]: iTasks.UI.Layout.dcl could not be imported\r\nError [directoryBrowsing.icl,11]: iTasks.UI.Definition.dcl could not be imported\r\nError [directoryBrowsing.icl,11]: iTasks.UI.Editor.Builtin.dcl could not be imported\r\nError [directoryBrowsing.icl,13]: iTasks.API.Extensions.Editors.Ace.dcl could not be imported\r\nError [directoryBrowsing.icl,15]: System.File.dcl could not be imported\r\nError [directoryBrowsing.icl,17]: System.Directory.dcl could not be imported\r\nError [directoryBrowsing.icl,19]: System.FilePath.dcl could not be imported\r\nError [directoryBrowsing.icl,21]: Data.Error.dcl could not be imported\r\n"]],false],"createdAt":7,"lastEvent":7},{"taskId":["TaskId",45,3090],"index":1,"detached":false,"attributes":["Tip"],"value":["NoValue"],"createdAt":7,"lastEvent":7}],["Tip"],["Bin",1,["TaskId",45,3089],[{"taskId":["TaskId",45,3091],"index":0,"detached":false,"attributes":["Tip"],"value":["Value",["Left","implementation module directoryBrowsing\r\n\r\nimport iTasks\r\n\r\nimport iTasks.API.Extensions.Admin.WorkflowAdmin\r\nimport iTasks.UI.Layout, iTasks.UI.Definition, iTasks.UI.Editor.Builtin\r\nimport iTasks.API.Extensions.Editors.Ace\r\nimport StdFile, System.File\r\nimport System.Directory\r\nimport System.FilePath\r\nimport Data.Error\r\n\r\n\r\n:: Directory = Dir FileName [Directory] [FileName]\r\n:: FileName :== String \t\t\t\t\t\t\t\t\t\/\/ File name without path, but with extension\r\n\r\nderive class iTask Directory\r\nderive class iTask ChoiceNode\r\n\r\nselectIcon pwd _ \t = Nothing\t\/\/ don't know where to store icons yet\r\nselectIcon pwd \"icl\" = Just (pwd <\/> \"WebPublic\" <\/> \"Clean.icl.ico\")\r\nselectIcon pwd \"dcl\" = Just (pwd <\/> \"WebPublic\" <\/> \"Clean.dcl.ico\")\r\nselectIcon pwd \"prj\" = Just (pwd <\/> \"WebPublic\" <\/> \"Clean.prj.ico\")\r\nselectIcon pwd \"abc\" = Just (pwd <\/> \"WebPublic\" <\/> \"Clean.abc.ico\")\r\nselectIcon pwd _ \t = Nothing\r\n\r\n\r\n\/\/ Directory & file selection using a tree\r\n\r\nselectFromTree :: FilePath (FileName -> Bool) -> Task FilePath\r\nselectFromTree pwd isWantedFile\r\n\t=\t\t\t\tfetchDirectories pwd isWantedFile\r\n\t>>= \\dirs ->\twithShared dirs (\\dir -> (editSelectionWithShared \"dirs\" False (SelectInTree (\\d -> fst (conv 0 d)) (\\_ idx -> idx)) dir (\\_ -> []) ))\r\n\t>&> \\mbsel ->\tviewSharedInformation \"Selected: \" [ViewAs (findSelected pwd (conv 0 dirs))] mbsel\t\t\t\r\n\t>>= \\mbsel -> \treturn (findSelected pwd (conv 0 dirs) mbsel)\r\n\r\nwhere\r\n\tedit dirs =\teditSelection \"dirs\" False (SelectInTree toTree fromTree) dirs [0..n]\r\n\twhere\r\n\t\t(toTree,n) \t \t= conv 0 dirs\r\n\t\tfromTree _ idx \t= idx\r\n\r\n\tconv :: Int Directory -> ([ChoiceNode],Int)\r\n\tconv i (Dir pwd dirs files) = convDirs i pwd dirs files\r\n\twhere\r\n\t\tconvDirs i pwd dirs files\r\n\t\t# (cds,ii)\t= convAllDirs (i+1) dirs\r\n\t\t# (cfs,iii)\t= convFiles ii files\r\n\t\t= ([{id = i, label = dropDirectory pwd, icon = Nothing, expanded = False, children = cds ++ cfs}],iii)\r\n\t\r\n\t\tconvAllDirs\ti [] = ([],i)\r\n\t\tconvAllDirs i [Dir pwd dirs fils:ds]\r\n\t\t# (cd,ii) \t= convDirs i pwd dirs fils\r\n\t\t# (cds,iii)\t= convAllDirs ii ds\r\n\t\t= (cd++cds,iii)\r\n\t\r\n\t\tconvFiles i [] \r\n\t\t\t\t\t= ([],i)\r\n\t\tconvFiles i [f:fs]\r\n\t\t# cf\t\t= {id = i, label = f, icon = selectIcon pwd (takeExtension f), expanded = False, children = []}\r\n\t\t# (cfs,j) \t= convFiles (i+1) fs\r\n\t\t= ([cf:cfs],j) \r\n\r\nfindSelected :: FilePath ([ChoiceNode],Int) (Maybe [Int]) -> String\r\nfindSelected pwd (nodes,i) Nothing  =  pwd\r\nfindSelected pwd (nodes,i) (Just idx)\r\n| idx == [] \t\t\t\t= pwd\r\n| i < hd idx \t\t\t\t= pwd\r\n| hd idx == 0\t\t\t\t= pwd\r\n= travers (takeDirectory pwd) nodes (hd idx)\r\nwhere\r\n\ttravers pwd [] _\t\t\t= pwd\r\n\ttravers pwd [n1] i\r\n\t| n1.ChoiceNode.id == i \t= pwd <\/> n1.ChoiceNode.label\r\n\t| otherwise\t\t\t\t\t= travers (pwd <\/> n1.ChoiceNode.label) n1.ChoiceNode.children i\r\n\ttravers pwd [n1,n2:ns] i \r\n\t| i >= n2.ChoiceNode.id \t= travers pwd [n2:ns] i\r\n\t| otherwise\t\t\t\t\t= travers pwd [n1] i\r\n\r\n\r\n\/\/ directory browsing\r\n\r\n\r\nbrowseDirectory :: (FilePath -> Bool) -> Task ((FilePath,[FilePath]),Maybe FilePath)\r\nbrowseDirectory pred\r\n \t=\t\t\t\t\t\t\t\t\tgetPwdName\r\n \t>>- \\pwd -> \t\t\t\t\t\tselectFile pwd pred\r\n\t>>- \\((pwd,paths),chosen)\t->\t\treturn ((pwd,paths),chosen)\r\nwhere\r\n\tselectFile :: FilePath (FilePath -> Bool) -> Task ((FilePath,[FilePath]),Maybe FilePath)\r\n\tselectFile pwd pred\r\n\t \t=\t\t\t\t\treadDir pwd\r\n\t\t>>- \\all ->\t\t\tselectDirs pwd all pred \/\/ only show wanted files \r\n\t\t>>- \\(dirs,files) ->\r\n\t\tlet all = dirs ++ files in\t\t\r\n\t\t(\t\t\t\t\tenterChoice  pwd [ChooseFromGrid id] all \r\n\t\t>>*\t\t\t\t\t[ OnAction (Action \"Up\") (always (selectFile (takeDirectory pwd) pred))\t\r\n\t\t\t\t\t\t\t, OnAction  ActionCancel (always (return ((pwd,all),Nothing)))\r\n\t\t\t\t\t\t\t, OnAction  ActionOpen   (hasValue (continue pwd dirs files pred))\r\n\t\t\t\t\t\t\t, OnAction  ActionNew    (always (createNewFile pwd >>| selectFile pwd pred))\r\n\t\t \t\t\t\t\t]\r\n\t\t)\r\n\twhere\r\n\t continue pwd dirs files pred chosen\r\n\t\t= if (isMember chosen dirs)  \t\r\n\t\t\t\t(selectFile (pwd <\/> chosen) pred)\r\n\t\t\t\t(return ((pwd,dirs ++ files),Just chosen))\r\n\t\t\t\t\r\n\t createNewFile pwd \r\n\t \t= \t\t\t\tupdateInformation \"Give new file name: \" [] \"name.icl\"\r\n\t \t>>= \\name ->\tcreateFile pwd name \"\"\r\n\r\nfetchDirectories ::  FilePath (FileName -> Bool) -> Task Directory\r\nfetchDirectories pwd pred\r\n\t= \t\t\t\t\t\treadDir pwd\r\n\t>>= \\fnames ->\t\t\tselectDirs pwd fnames pred\r\n\t>>= \\(dnames,fnames) ->\tfetch pwd dnames\r\n\t>>= \\dirs -> \t\t\treturn (Dir pwd dirs fnames)\r\nwhere\r\n  fetch pwd []  \r\n\t= \t\t\t\t\t\treturn []\r\n  fetch pwd [d:ds]   \r\n\t=\t\t\t\t\t\tfetchDirectories (pwd <\/> d) pred\r\n\t>>= \\dir ->\t\t\t\tfetch pwd ds \r\n\t>>= \\dirs ->\t\t\treturn [dir:dirs]\r\n\t\r\nselectDirs :: FilePath [FileName] (FileName -> Bool) -> Task ([FileName],[FileName])\r\nselectDirs pwd paths pred = selDirs` paths ([],[]) \r\nwhere\r\n\tselDirs` [] (dirs,nodirs) \r\n\t\t= return (drop 2 (reverse dirs),sort (filter pred nodirs))\r\n\tselDirs` [f:fs] (dirs,nodirs)\r\n\t\t=\t\t\tisDirectory (pwd <\/> f)\r\n\t\t>>= \\yes -> if yes (selDirs` fs ([f:dirs],nodirs))\r\n\t\t\t\t\t\t   (selDirs` fs (dirs,[f:nodirs]))\r\n\r\nisDirectory :: FilePath -> Task Bool\r\nisDirectory file = worldIO isDir\r\nwhere\r\n\tisDir world\r\n\t# (res,world) \t=\tgetFileInfo file world\r\n\t| isError res\t=\t(Error (\"Cannot get directory info from file: \" +++ file), world) \r\n\t= (Ok (fromOk res).directory,world)\r\n\r\nreadDir :: FilePath  -> Task [FileName]  \/\/ returns file names (no path)\r\nreadDir pwd  = worldIO readDir`\r\nwhere\r\n\treadDir` world\r\n\t# (res,\tworld)\t\t= readDirectory pwd world\r\n\t| isError res\t\t= (Error (\"Cannot read directory: \" +++ pwd), world)\r\n\t# names\t\t\t\t= fromOk res\r\n\t= (Ok names, world)\t\t\/\/ includes \".\" and \"..\"\r\n\r\ngetPwdName :: Task FilePath\r\ngetPwdName\r\n\t=\t\t\t\t\tworldIO getPwd`\r\nwhere\r\n\tgetPwd` world \t\r\n\t# (res, world)\t= \tgetCurrentDirectory world \r\n\t| isError res\t= \t(Error \"Cannot open current directory\", world)\r\n\t# pwd\t\t\t= \tfromOk res\r\n\t= (Ok pwd, world)\r\n\r\ncreateFile :: FilePath FileName String -> Task ()\r\ncreateFile path name content = worldIO (create (path <\/> name) content)\r\nwhere\r\n\tcreate filename content world\r\n\t# (ok,file,world)\t\t\t= fopen filename FWriteText world\r\n\t| not ok\t\t\t\t\t= (Error (\"Cannot open file: \" +++ filename),world)\r\n\t# file\t\t\t\t\t\t= fwrites content file\r\n\t# (ok,world)\t\t\t\t= fclose file world\r\n\t| not ok\t\t\t\t\t= (Error (\"Cannot open file: \" +++ filename),world)\r\n\t= (Ok (),world)\t\r\n\t\r\nreadFromFile :: String -> Task String\r\nreadFromFile path = worldIO (read path) \r\nwhere \r\n\tread path world\r\n\t# (ok,file,world)\t\t\t= fopen path FReadData world\r\n\t| not ok\t\t\t\t\t= (Error (\"Cannot find file: \" +++ path), world) \r\n\t# (res,file)\t\t\t\t= readAll file\r\n\t# (ok,world)\t\t\t\t= fclose file world\r\n\t| not ok\t\t\t\t\t= (Error (\"Cannot close file: \" +++ path), world)\r\n    = case res of\r\n        Error e                 = (Error (\"Cannot read File:\" +++ path), world)\r\n        Ok content              = (Ok content, world)\r\n\r\nwriteToFile :: String String -> Task String\r\nwriteToFile path content = worldIO (write path content) \r\nwhere \r\n\twrite path content world\r\n\t# (ok,file,world)\t\t\t= fopen path FWriteText world\r\n\t| not ok\t\t\t\t\t= (Error (\"Cannot open file: \" +++ path), world)\r\n\t# file\t\t\t\t\t\t= fwrites content file\r\n\t# (ok,world)\t\t\t\t= fclose file world\r\n\t| not ok\t\t\t\t\t= (Error (\"Cannot close file: \" +++ path) ,world)\r\n\t= (Ok content, world)\r\n\r\n\r\n\r\n"],false],"createdAt":7,"lastEvent":7},{"taskId":["TaskId",45,3092],"index":1,"detached":false,"attributes":["Tip"],"value":["Value",["Right","15:03:20Error [directoryBrowsing.dcl,3]: iTasks.dcl could not be imported\r\nError [directoryBrowsing.icl,9]: iTasks.API.Extensions.Admin.WorkflowAdmin.dcl could not be imported\r\nError [directoryBrowsing.icl,11]: iTasks.UI.Layout.dcl could not be imported\r\nError [directoryBrowsing.icl,11]: iTasks.UI.Definition.dcl could not be imported\r\nError [directoryBrowsing.icl,11]: iTasks.UI.Editor.Builtin.dcl could not be imported\r\nError [directoryBrowsing.icl,13]: iTasks.API.Extensions.Editors.Ace.dcl could not be imported\r\nError [directoryBrowsing.icl,15]: System.File.dcl could not be imported\r\nError [directoryBrowsing.icl,17]: System.Directory.dcl could not be imported\r\nError [directoryBrowsing.icl,19]: System.FilePath.dcl could not be imported\r\nError [directoryBrowsing.icl,21]: Data.Error.dcl could not be imported\r\n"],false],"createdAt":7,"lastEvent":7}],["Tip"],["Tip"]]]]