|| ?module? mergecases


mergecases.fold_st_48 op_0 !_x_1 st_2 = case _x_1 (_predefined._Nil -> st_2) (_predefined._Cons a_1_0 x_1_1 -> mergecases.fold_st_48 op_0 x_1_1 (op_0 a_1_0 st_2)) 
mergecases.skip_alias_21 !var_info_ptr_0 !var_heap_1 = <{mergecases._c;149;11_64}> (Heap.sreadPtr var_info_ptr_0 var_heap_1) var_info_ptr_0
<{mergecases._c;149;11_64}> !_x_0 var_info_ptr_1 = case _x_0 (syntax.VI_Alias bv_1_0 -> select bv_1_0::syntax._BoundVar 1) (_ -> var_info_ptr_1)
mergecases.has_no_default_20::B !_x_0 = case _x_0 (general.No -> True) (general.Yes _x_1_0 -> False) 
mergecases.anon_5 !this_case_0 !type_1 newtype_pattern_2 guard_expr_3 = update this_case_0::syntax._Case [1:syntax.NewTypePatterns type_1 (_predefined._Cons (update newtype_pattern_2::syntax._AlgebraicPattern [2:guard_expr_3]) _predefined._Nil)]
mergecases.map_st_47 f_0 !_x_1 s_2 = case _x_1 (_predefined._Cons x_1_0 xs_1_1 -> let !s_2_0 = _predefined._dummyForStrictAlias (select _x_2_2::_Tuple2 1), _x_2_1 = f_0 x_1_0 s_2, _x_2_2 = mergecases.map_st_47 f_0 xs_1_1 (select _x_2_1::_Tuple2 1) in _Tuple2 (_predefined._Cons (select _x_2_1::_Tuple2 0) (select _x_2_2::_Tuple2 0)) s_2_0) (_predefined._Nil -> let !s_2_0 = _predefined._dummyForStrictAlias s_2 in _Tuple2 _predefined._Nil s_2_0) 
mergecases.new_case_10 expr_fun_0 expr_1 symbol_heap_2 = let cees_1_0 = expr_fun_0 expr_1, _x_1_1 = Heap.readPtr (select cees_1_0::syntax._Case 4) symbol_heap_2, _x_1_2 = Heap.newPtr (select _x_1_1::_Tuple2 0) (select _x_1_1::_Tuple2 1) in _Tuple2 (syntax.Case (update cees_1_0::syntax._Case [4:select _x_1_2::_Tuple2 0])) (select _x_1_2::_Tuple2 1)
mergecases.f_6 !_vGetSetPatternRhs_0 expr_fun_1 algpattern_2 symbol_heap_3 = let _x_1_0 = mergecases.new_case_10 expr_fun_1 (select _vGetSetPatternRhs_0::<{mergecases.GetSetPatternRhs;}> 0 algpattern_2) symbol_heap_3 in _Tuple2 (select _vGetSetPatternRhs_0::<{mergecases.GetSetPatternRhs;}> 1 algpattern_2 (select _x_1_0::_Tuple2 0)) (select _x_1_0::_Tuple2 1)
mergecases.map_st_49 !_vGetSetPatternRhs_0 expr_fun_1 !_x_2 !s_3 = case _x_2 (_predefined._Cons x_1_0 xs_1_1 -> let !s_2_0 = _predefined._dummyForStrictAlias (select _x_2_2::_Tuple2 1), _x_2_1 = mergecases.f_6 _vGetSetPatternRhs_0 expr_fun_1 x_1_0 s_3, _x_2_2 = mergecases.map_st_49 _vGetSetPatternRhs_0 expr_fun_1 xs_1_1 (select _x_2_1::_Tuple2 1) in _Tuple2 (_predefined._Cons (select _x_2_1::_Tuple2 0) (select _x_2_2::_Tuple2 0)) s_2_0) (_predefined._Nil -> let !s_2_0 = _predefined._dummyForStrictAlias s_3 in _Tuple2 _predefined._Nil s_2_0) 
mergecases.push_expression_into_patterns_9 !_vGetSetPatternRhs_0 expr_fun_1 !_x_2 symbol_heap_3 = case _x_2 (_predefined._Nil -> _Tuple2 _predefined._Nil symbol_heap_3) (_predefined._Cons pattern_1_0 patterns_1_1 -> let _x_2_0 = mergecases.map_st_49 _vGetSetPatternRhs_0 expr_fun_1 patterns_1_1 symbol_heap_3 in _Tuple2 (_predefined._Cons (select _vGetSetPatternRhs_0::<{mergecases.GetSetPatternRhs;}> 1 pattern_1_0 (syntax.Case (expr_fun_1 (select _vGetSetPatternRhs_0::<{mergecases.GetSetPatternRhs;}> 0 pattern_1_0)))) (select _x_2_0::_Tuple2 0)) (select _x_2_0::_Tuple2 1)) 
mergecases.get_pattern_rhs_38 !p_0 = select p_0::syntax._AlgebraicPattern 2
mergecases.set_pattern_rhs_39 !p_0 !expr_1 = update p_0::syntax._AlgebraicPattern [2:expr_1]
mergecases.get_pattern_rhs_40 !p_0 = select p_0::syntax._BasicPattern 1
mergecases.set_pattern_rhs_41 !p_0 !expr_1 = update p_0::syntax._BasicPattern [1:expr_1]
mergecases.get_pattern_rhs_42 !p_0 = select p_0::syntax._DynamicPattern 3
mergecases.set_pattern_rhs_43 !p_0 !expr_1 = update p_0::syntax._DynamicPattern [3:expr_1]
mergecases.f_58 expr_fun_0 algpattern_1 symbol_heap_2 = let _x_1_0 = mergecases.new_case_10 expr_fun_0 (mergecases.get_pattern_rhs_42 algpattern_1) symbol_heap_2 in _Tuple2 (mergecases.set_pattern_rhs_43 algpattern_1 (select _x_1_0::_Tuple2 0)) (select _x_1_0::_Tuple2 1)
mergecases.map_st_57 expr_fun_0 !_x_1 !s_2 = case _x_1 (_predefined._Cons x_1_0 xs_1_1 -> let !s_2_0 = _predefined._dummyForStrictAlias (select _x_2_2::_Tuple2 1), _x_2_1 = mergecases.f_58 expr_fun_0 x_1_0 s_2, _x_2_2 = mergecases.map_st_57 expr_fun_0 xs_1_1 (select _x_2_1::_Tuple2 1) in _Tuple2 (_predefined._Cons (select _x_2_1::_Tuple2 0) (select _x_2_2::_Tuple2 0)) s_2_0) (_predefined._Nil -> let !s_2_0 = _predefined._dummyForStrictAlias s_2 in _Tuple2 _predefined._Nil s_2_0) 
mergecases.push_expression_into_patterns_56 expr_fun_0 !_x_1 symbol_heap_2 = case _x_1 (_predefined._Nil -> _Tuple2 _predefined._Nil symbol_heap_2) (_predefined._Cons pattern_1_0 patterns_1_1 -> let _x_2_0 = mergecases.map_st_57 expr_fun_0 patterns_1_1 symbol_heap_2 in _Tuple2 (_predefined._Cons (mergecases.set_pattern_rhs_43 pattern_1_0 (syntax.Case (expr_fun_0 (mergecases.get_pattern_rhs_42 pattern_1_0)))) (select _x_2_0::_Tuple2 0)) (select _x_2_0::_Tuple2 1)) 
mergecases.f_52 expr_fun_0 algpattern_1 symbol_heap_2 = let _x_1_0 = mergecases.new_case_10 expr_fun_0 (mergecases.get_pattern_rhs_38 algpattern_1) symbol_heap_2 in _Tuple2 (mergecases.set_pattern_rhs_39 algpattern_1 (select _x_1_0::_Tuple2 0)) (select _x_1_0::_Tuple2 1)
mergecases.map_st_51 expr_fun_0 !_x_1 !s_2 = case _x_1 (_predefined._Cons x_1_0 xs_1_1 -> let !s_2_0 = _predefined._dummyForStrictAlias (select _x_2_2::_Tuple2 1), _x_2_1 = mergecases.f_52 expr_fun_0 x_1_0 s_2, _x_2_2 = mergecases.map_st_51 expr_fun_0 xs_1_1 (select _x_2_1::_Tuple2 1) in _Tuple2 (_predefined._Cons (select _x_2_1::_Tuple2 0) (select _x_2_2::_Tuple2 0)) s_2_0) (_predefined._Nil -> let !s_2_0 = _predefined._dummyForStrictAlias s_2 in _Tuple2 _predefined._Nil s_2_0) 
mergecases.push_expression_into_patterns_50 expr_fun_0 !_x_1 symbol_heap_2 = case _x_1 (_predefined._Nil -> _Tuple2 _predefined._Nil symbol_heap_2) (_predefined._Cons pattern_1_0 patterns_1_1 -> let _x_2_0 = mergecases.map_st_51 expr_fun_0 patterns_1_1 symbol_heap_2 in _Tuple2 (_predefined._Cons (mergecases.set_pattern_rhs_39 pattern_1_0 (syntax.Case (expr_fun_0 (mergecases.get_pattern_rhs_38 pattern_1_0)))) (select _x_2_0::_Tuple2 0)) (select _x_2_0::_Tuple2 1)) 
mergecases.f_55 expr_fun_0 algpattern_1 symbol_heap_2 = let _x_1_0 = mergecases.new_case_10 expr_fun_0 (mergecases.get_pattern_rhs_40 algpattern_1) symbol_heap_2 in _Tuple2 (mergecases.set_pattern_rhs_41 algpattern_1 (select _x_1_0::_Tuple2 0)) (select _x_1_0::_Tuple2 1)
mergecases.map_st_54 expr_fun_0 !_x_1 !s_2 = case _x_1 (_predefined._Cons x_1_0 xs_1_1 -> let !s_2_0 = _predefined._dummyForStrictAlias (select _x_2_2::_Tuple2 1), _x_2_1 = mergecases.f_55 expr_fun_0 x_1_0 s_2, _x_2_2 = mergecases.map_st_54 expr_fun_0 xs_1_1 (select _x_2_1::_Tuple2 1) in _Tuple2 (_predefined._Cons (select _x_2_1::_Tuple2 0) (select _x_2_2::_Tuple2 0)) s_2_0) (_predefined._Nil -> let !s_2_0 = _predefined._dummyForStrictAlias s_2 in _Tuple2 _predefined._Nil s_2_0) 
mergecases.push_expression_into_patterns_53 expr_fun_0 !_x_1 symbol_heap_2 = case _x_1 (_predefined._Nil -> _Tuple2 _predefined._Nil symbol_heap_2) (_predefined._Cons pattern_1_0 patterns_1_1 -> let _x_2_0 = mergecases.map_st_54 expr_fun_0 patterns_1_1 symbol_heap_2 in _Tuple2 (_predefined._Cons (mergecases.set_pattern_rhs_41 pattern_1_0 (syntax.Case (expr_fun_0 (mergecases.get_pattern_rhs_40 pattern_1_0)))) (select _x_2_0::_Tuple2 0)) (select _x_2_0::_Tuple2 1)) 
mergecases.push_expression_into_guards_8 expr_fun_0 !split_case_1 symbol_heap_2 = case split_case_1 (syntax._Case case_expr_1_0 case_guards_1_1 case_default_1_2 case_ident_1_3 case_info_ptr_1_4 case_explicit_1_5 case_default_pos_1_6 -> case case_guards_1_1 (syntax.AlgebraicPatterns type_2_0 patterns_2_1 -> let _x_3_0 = mergecases.push_expression_into_patterns_50 expr_fun_0 patterns_2_1 symbol_heap_2 in _Tuple2 (update split_case_1::syntax._Case [1:syntax.AlgebraicPatterns type_2_0 (select _x_3_0::_Tuple2 0)]) (select _x_3_0::_Tuple2 1)) (syntax.BasicPatterns type_2_0 patterns_2_1 -> let _x_3_0 = mergecases.push_expression_into_patterns_53 expr_fun_0 patterns_2_1 symbol_heap_2 in _Tuple2 (update split_case_1::syntax._Case [1:syntax.BasicPatterns type_2_0 (select _x_3_0::_Tuple2 0)]) (select _x_3_0::_Tuple2 1)) (syntax.OverloadedListPatterns type_2_0 decons_expr_2_1 patterns_2_2 -> let _x_3_0 = mergecases.push_expression_into_patterns_50 expr_fun_0 patterns_2_2 symbol_heap_2 in _Tuple2 (update split_case_1::syntax._Case [1:syntax.OverloadedListPatterns type_2_0 decons_expr_2_1 (select _x_3_0::_Tuple2 0)]) (select _x_3_0::_Tuple2 1)) (syntax.NewTypePatterns type_2_0 patterns_2_1 -> let _x_3_0 = mergecases.push_expression_into_patterns_50 expr_fun_0 patterns_2_1 symbol_heap_2 in _Tuple2 (update split_case_1::syntax._Case [1:syntax.NewTypePatterns type_2_0 (select _x_3_0::_Tuple2 0)]) (select _x_3_0::_Tuple2 1)) (syntax.DynamicPatterns patterns_2_0 -> let _x_3_0 = mergecases.push_expression_into_patterns_56 expr_fun_0 patterns_2_0 symbol_heap_2 in _Tuple2 (update split_case_1::syntax._Case [1:syntax.DynamicPatterns (select _x_3_0::_Tuple2 0)]) (select _x_3_0::_Tuple2 1)) ) 
mergecases.push_expression_into_guards_and_default_7 expr_fun_0 !split_case_1 symbol_heap_2 = case split_case_1 (syntax._Case case_expr_1_0 case_guards_1_1 case_default_1_2 case_ident_1_3 case_info_ptr_1_4 case_explicit_1_5 case_default_pos_1_6 -> case case_default_1_2 (general.No -> mergecases.push_expression_into_guards_8 expr_fun_0 split_case_1 symbol_heap_2) (general.Yes default_expr_2_0 -> let _x_3_0 = mergecases.new_case_10 expr_fun_0 default_expr_2_0 symbol_heap_2 in mergecases.push_expression_into_guards_8 expr_fun_0 (update split_case_1::syntax._Case [2:general.Yes (select _x_3_0::_Tuple2 0)]) (select _x_3_0::_Tuple2 1)) ) 
mergecases.push_expression_into_guards_and_default_23 expr_fun_0 !split_case_1 symbol_heap_2 = mergecases.push_expression_into_guards_and_default_7 expr_fun_0 split_case_1 symbol_heap_2
mergecases.anon_4 !this_case_0 !type_1 !decons_expr_2 overloaded_list_pattern_3 guard_expr_4 = update this_case_0::syntax._Case [1:syntax.OverloadedListPatterns type_1 decons_expr_2 (_predefined._Cons (update overloaded_list_pattern_3::syntax._AlgebraicPattern [2:guard_expr_4]) _predefined._Nil)]
mergecases.anon_3 !this_case_0 !type_1 basic_pattern_2 guard_expr_3 = update this_case_0::syntax._Case [1:syntax.BasicPatterns type_1 (_predefined._Cons (update basic_pattern_2::syntax._BasicPattern [1:guard_expr_3]) _predefined._Nil)]
mergecases.anon_2 !this_case_0 !type_1 alg_pattern_2 guard_expr_3 = update this_case_0::syntax._Case [1:syntax.AlgebraicPatterns type_1 (_predefined._Cons (update alg_pattern_2::syntax._AlgebraicPattern [2:guard_expr_3]) _predefined._Nil)]
mergecases.set_alias_22 !_x_0 !var_heap_1 = case _x_0 (syntax._LetBind _x_1_0 _x_1_1 lb_position_1_2 -> case _x_1_0 (syntax._FreeVar fv_def_level_2_0 fv_ident_2_1 fv_info_ptr_2_2 fv_count_2_3 -> case _x_1_1 (syntax.Var var_3_0 -> let ptr_and_val_4_0 = _Tuple2 fv_info_ptr_2_2 (syntax.VI_Alias var_3_0) in Heap.writePtr (select ptr_and_val_4_0::_Tuple2 0) (select ptr_and_val_4_0::_Tuple2 1) var_heap_1) ) ) (_ -> var_heap_1)
mergecases.fold_st_46 op_0 !_x_1 st_2 = case _x_1 (_predefined._Nil -> st_2) (_predefined._Cons a_1_0 x_1_1 -> mergecases.fold_st_46 op_0 x_1_1 (op_0 a_1_0 st_2)) 
mergecases.fold_st_45 op_0 !_x_1 st_2 = case _x_1 (_predefined._Nil -> st_2) (_predefined._Cons a_1_0 x_1_1 -> mergecases.fold_st_45 op_0 x_1_1 (op_0 a_1_0 st_2)) 
mergecases.new_variable_25 !fv_0 var_heap_1 = case fv_0 (syntax._FreeVar fv_def_level_1_0 fv_ident_1_1 fv_info_ptr_1_2 fv_count_1_3 -> let _x_2_0 = Heap.newPtr syntax.VI_Empty var_heap_1, new_info_ptr_2_1 = select _x_2_0::_Tuple2 0, ptr_and_val_2_2 = _Tuple2 fv_info_ptr_1_2 (syntax.VI_Variable fv_ident_1_1 new_info_ptr_2_1) in _Tuple2 (update fv_0::syntax._FreeVar [2:new_info_ptr_2_1]) (Heap.writePtr (select ptr_and_val_2_2::_Tuple2 0) (select ptr_and_val_2_2::_Tuple2 1) (select _x_2_0::_Tuple2 1))) 
mergecases.renew_let_var_11 !bind_0 !_x_1 = case bind_0 (syntax._LetBind lb_dst_1_0 lb_src_1_1 lb_position_1_2 -> case _x_1 (_Tuple2 rev_binds_2_0 var_heap_2_1 -> let _x_3_0 = mergecases.new_variable_25 lb_dst_1_0 var_heap_2_1 in _Tuple2 (_predefined._Cons (update bind_0::syntax._LetBind [0:select _x_3_0::_Tuple2 0]) rev_binds_2_0) (select _x_3_0::_Tuple2 1)) ) 
mergecases.replace_variables_in_expression_24 !_vunfold_0 expr_1 var_heap_2 symbol_heap_3 = let _x_1_0 = select _vunfold_0::<{transform.unfold;}> 0 expr_1 (transform._UnfoldState var_heap_2 symbol_heap_3 general.No), us_1_1 = select _x_1_0::_Tuple2 1 in _Tuple3 (select _x_1_0::_Tuple2 0) (select us_1_1::transform._UnfoldState 0) (select us_1_1::transform._UnfoldState 1)
mergecases.replace_variables_in_expression_59 expr_0 var_heap_1 symbol_heap_2 = let _x_1_0 = transform.unfold_7 expr_0 (transform._UnfoldState var_heap_1 symbol_heap_2 general.No), us_1_1 = select _x_1_0::_Tuple2 1 in _Tuple3 (select _x_1_0::_Tuple2 0) (select us_1_1::transform._UnfoldState 0) (select us_1_1::transform._UnfoldState 1)
mergecases.replace_variables_in_bound_expression_12 !bind_0 !_x_1 = case bind_0 (syntax._LetBind lb_dst_1_0 lb_src_1_1 lb_position_1_2 -> case _x_1 (_Tuple3 rev_binds_2_0 var_heap_2_1 expr_heap_2_2 -> let _x_3_0 = mergecases.replace_variables_in_expression_59 lb_src_1_1 var_heap_2_1 expr_heap_2_2 in _Tuple3 (_predefined._Cons (update bind_0::syntax._LetBind [1:select _x_3_0::_Tuple3 0]) rev_binds_2_0) (select _x_3_0::_Tuple3 1) (select _x_3_0::_Tuple3 2)) ) 
mergecases.fold_st_60 !_x_0 !st_1 = case _x_0 (_predefined._Nil -> st_1) (_predefined._Cons a_1_0 x_1_1 -> mergecases.fold_st_60 x_1_1 (mergecases.renew_let_var_11 a_1_0 st_1)) 
mergecases.fold_st_61 !_x_0 !st_1 = case _x_0 (_predefined._Nil -> st_1) (_predefined._Cons a_1_0 x_1_1 -> mergecases.fold_st_61 x_1_1 (mergecases.replace_variables_in_bound_expression_12 a_1_0 st_1)) 
mergecases.rebuild_let_expression_26 lad_0 expr_1 var_heap_2 expr_heap_3 = let _x_1_0 = mergecases.fold_st_60 (select lad_0::syntax._Let 1) (_Tuple2 _predefined._Nil var_heap_2), _x_1_1 = Heap.newPtr syntax.EI_Empty expr_heap_3, _x_1_2 = mergecases.replace_variables_in_expression_59 expr_1 (select _x_1_0::_Tuple2 1) (select _x_1_1::_Tuple2 1), _x_1_3 = mergecases.fold_st_61 (select _x_1_0::_Tuple2 0) (_Tuple3 _predefined._Nil (select _x_1_2::_Tuple3 1) (select _x_1_2::_Tuple3 2)) in _Tuple3 (syntax.Let (update lad_0::syntax._Let [1:select _x_1_3::_Tuple3 0,2:select _x_1_2::_Tuple3 0,3:select _x_1_1::_Tuple2 0])) (select _x_1_3::_Tuple3 1) (select _x_1_3::_Tuple3 2)
mergecases.push_let_expression_into_algebraic_pattern_28 lad_0 !_x_1 var_heap_2 expr_heap_3 = case _x_1 (_predefined._Cons pattern_1_0 _x_1_1 -> case pattern_1_0 (syntax._AlgebraicPattern ap_symbol_2_0 ap_vars_2_1 ap_expr_2_2 ap_position_2_3 -> case _x_1_1 (_predefined._Nil -> _Tuple3 (_predefined._Cons (update pattern_1_0::syntax._AlgebraicPattern [2:syntax.Let (update lad_0::syntax._Let [2:ap_expr_2_2])]) _predefined._Nil) var_heap_2 expr_heap_3) (_ -> let _x_3_0 = mergecases.rebuild_let_expression_26 lad_0 ap_expr_2_2 var_heap_2 expr_heap_3, _x_3_1 = mergecases.push_let_expression_into_algebraic_pattern_28 lad_0 _x_1_1 (select _x_3_0::_Tuple3 1) (select _x_3_0::_Tuple3 2) in _Tuple3 (_predefined._Cons (update pattern_1_0::syntax._AlgebraicPattern [2:select _x_3_0::_Tuple3 0]) (select _x_3_1::_Tuple3 0)) (select _x_3_1::_Tuple3 1) (select _x_3_1::_Tuple3 2))) ) 
mergecases.push_let_expression_into_basic_pattern_13 lad_0 !_x_1 var_heap_2 expr_heap_3 = case _x_1 (_predefined._Cons pattern_1_0 _x_1_1 -> case pattern_1_0 (syntax._BasicPattern bp_value_2_0 bp_expr_2_1 bp_position_2_2 -> case _x_1_1 (_predefined._Nil -> _Tuple3 (_predefined._Cons (update pattern_1_0::syntax._BasicPattern [1:syntax.Let (update lad_0::syntax._Let [2:bp_expr_2_1])]) _predefined._Nil) var_heap_2 expr_heap_3) (_ -> let _x_3_0 = mergecases.rebuild_let_expression_26 lad_0 bp_expr_2_1 var_heap_2 expr_heap_3, _x_3_1 = mergecases.push_let_expression_into_basic_pattern_13 lad_0 _x_1_1 (select _x_3_0::_Tuple3 1) (select _x_3_0::_Tuple3 2) in _Tuple3 (_predefined._Cons (update pattern_1_0::syntax._BasicPattern [1:select _x_3_0::_Tuple3 0]) (select _x_3_1::_Tuple3 0)) (select _x_3_1::_Tuple3 1) (select _x_3_1::_Tuple3 2))) ) 
mergecases.push_let_expression_into_dynamic_pattern_14 lad_0 !_x_1 var_heap_2 expr_heap_3 = case _x_1 (_predefined._Cons pattern_1_0 _x_1_1 -> case pattern_1_0 (syntax._DynamicPattern dp_var_2_0 dp_type_2_1 dp_type_code_2_2 dp_rhs_2_3 dp_position_2_4 -> case _x_1_1 (_predefined._Nil -> _Tuple3 (_predefined._Cons (update pattern_1_0::syntax._DynamicPattern [3:syntax.Let (update lad_0::syntax._Let [2:dp_rhs_2_3])]) _predefined._Nil) var_heap_2 expr_heap_3) (_ -> let _x_3_0 = mergecases.rebuild_let_expression_26 lad_0 dp_rhs_2_3 var_heap_2 expr_heap_3, _x_3_1 = mergecases.push_let_expression_into_dynamic_pattern_14 lad_0 _x_1_1 (select _x_3_0::_Tuple3 1) (select _x_3_0::_Tuple3 2) in _Tuple3 (_predefined._Cons (update pattern_1_0::syntax._DynamicPattern [3:select _x_3_0::_Tuple3 0]) (select _x_3_1::_Tuple3 0)) (select _x_3_1::_Tuple3 1) (select _x_3_1::_Tuple3 2))) ) 
mergecases.push_let_expression_into_guards_27 lad_0 !_x_1 var_heap_2 expr_heap_3 = case _x_1 (syntax.AlgebraicPatterns type_1_0 patterns_1_1 -> let _x_2_0 = mergecases.push_let_expression_into_algebraic_pattern_28 lad_0 patterns_1_1 var_heap_2 expr_heap_3 in _Tuple3 (syntax.AlgebraicPatterns type_1_0 (select _x_2_0::_Tuple3 0)) (select _x_2_0::_Tuple3 1) (select _x_2_0::_Tuple3 2)) (syntax.BasicPatterns type_1_0 patterns_1_1 -> let _x_2_0 = mergecases.push_let_expression_into_basic_pattern_13 lad_0 patterns_1_1 var_heap_2 expr_heap_3 in _Tuple3 (syntax.BasicPatterns type_1_0 (select _x_2_0::_Tuple3 0)) (select _x_2_0::_Tuple3 1) (select _x_2_0::_Tuple3 2)) (syntax.OverloadedListPatterns type_1_0 decons_expr_1_1 patterns_1_2 -> let _x_2_0 = mergecases.push_let_expression_into_algebraic_pattern_28 lad_0 patterns_1_2 var_heap_2 expr_heap_3 in _Tuple3 (syntax.OverloadedListPatterns type_1_0 decons_expr_1_1 (select _x_2_0::_Tuple3 0)) (select _x_2_0::_Tuple3 1) (select _x_2_0::_Tuple3 2)) (syntax.NewTypePatterns type_1_0 patterns_1_1 -> let _x_2_0 = mergecases.push_let_expression_into_algebraic_pattern_28 lad_0 patterns_1_1 var_heap_2 expr_heap_3 in _Tuple3 (syntax.NewTypePatterns type_1_0 (select _x_2_0::_Tuple3 0)) (select _x_2_0::_Tuple3 1) (select _x_2_0::_Tuple3 2)) (syntax.DynamicPatterns patterns_1_0 -> let _x_2_0 = mergecases.push_let_expression_into_dynamic_pattern_14 lad_0 patterns_1_0 var_heap_2 expr_heap_3 in _Tuple3 (syntax.DynamicPatterns (select _x_2_0::_Tuple3 0)) (select _x_2_0::_Tuple3 1) (select _x_2_0::_Tuple3 2)) 
mergecases.fold_st_62 !_x_0 !st_1 = case _x_0 (_predefined._Nil -> st_1) (_predefined._Cons a_1_0 x_1_1 -> mergecases.fold_st_62 x_1_1 (mergecases.set_alias_22 a_1_0 st_1)) 
mergecases.split_case_19 split_var_info_ptr_0 !_x_1 var_heap_2 symbol_heap_3 = case _x_1 (syntax.Case this_case_1_0 -> case this_case_1_0 (syntax._Case case_expr_2_0 case_guards_2_1 case_default_2_2 case_ident_2_3 case_info_ptr_2_4 case_explicit_2_5 case_default_pos_2_6 -> case case_expr_2_0 (syntax.Var _x_3_0 -> case _x_3_0 (syntax._BoundVar var_ident_4_0 var_info_ptr_4_1 var_expr_ptr_4_2 -> case (<{Heap.==_10}> split_var_info_ptr_0 (mergecases.skip_alias_21 var_info_ptr_4_1 var_heap_2)) (True -> _Tuple3 (general.Yes this_case_1_0) var_heap_2 symbol_heap_3) (False -> case (mergecases.has_no_default_20 case_default_2_2) (True -> <{mergecases._c;50;15_69}> case_guards_2_1 split_var_info_ptr_0 var_heap_2 symbol_heap_3 this_case_1_0) (False -> _Tuple3 general.No var_heap_2 symbol_heap_3) ) ) ) ) ) (syntax.Let lad_1_0 -> case lad_1_0 (syntax._Let let_strict_binds_2_0 let_lazy_binds_2_1 let_expr_2_2 let_info_ptr_2_3 let_expr_position_2_4 -> case (StdList.isEmpty let_strict_binds_2_0) (True -> let var_heap_4_0 = mergecases.fold_st_62 let_lazy_binds_2_1 var_heap_2, _x_4_1 = mergecases.split_case_19 split_var_info_ptr_0 let_expr_2_2 var_heap_4_0 symbol_heap_3, symbol_heap_4_2 = select _x_4_1::_Tuple3 2, var_heap_4_3 = select _x_4_1::_Tuple3 1 in <{mergecases._c;135;15_70}> (select _x_4_1::_Tuple3 0) lad_1_0 var_heap_4_3 symbol_heap_4_2) (False -> _Tuple3 general.No var_heap_2 symbol_heap_3) ) ) (_ -> _Tuple3 general.No var_heap_2 symbol_heap_3)
<{mergecases._c;135;15_70}> !_x_0 lad_1 var_heap_2 symbol_heap_3 = case _x_0 (general.Yes split_case_1_0 -> let _x_2_0 = mergecases.push_let_expression_into_guards_27 lad_1 (select split_case_1_0::syntax._Case 1) var_heap_2 symbol_heap_3 in _Tuple3 (general.Yes (update split_case_1_0::syntax._Case [1:select _x_2_0::_Tuple3 0])) (select _x_2_0::_Tuple3 1) (select _x_2_0::_Tuple3 2)) (general.No -> _Tuple3 general.No var_heap_2 symbol_heap_3) 
<{mergecases._c;50;15_69}> !case_guards_0 split_var_info_ptr_1 var_heap_2 symbol_heap_3 this_case_4 = case case_guards_0 (syntax.AlgebraicPatterns type_1_0 _x_1_1 -> case _x_1_1 (_predefined._Cons alg_pattern_2_0 _x_2_1 -> case _x_2_1 (_predefined._Nil -> let _x_4_0 = mergecases.split_case_19 split_var_info_ptr_1 (select alg_pattern_2_0::syntax._AlgebraicPattern 2) var_heap_2 symbol_heap_3, symbol_heap_4_1 = select _x_4_0::_Tuple3 2, var_heap_4_2 = select _x_4_0::_Tuple3 1 in <{mergecases._c;53;24_65}> (select _x_4_0::_Tuple3 0) this_case_4 type_1_0 alg_pattern_2_0 symbol_heap_4_1 var_heap_4_2) ) ) (syntax.BasicPatterns type_1_0 _x_1_1 -> case _x_1_1 (_predefined._Cons basic_pattern_2_0 _x_2_1 -> case _x_2_1 (_predefined._Nil -> let _x_4_0 = mergecases.split_case_19 split_var_info_ptr_1 (select basic_pattern_2_0::syntax._BasicPattern 1) var_heap_2 symbol_heap_3, symbol_heap_4_1 = select _x_4_0::_Tuple3 2, var_heap_4_2 = select _x_4_0::_Tuple3 1 in <{mergecases._c;65;24_66}> (select _x_4_0::_Tuple3 0) this_case_4 type_1_0 basic_pattern_2_0 symbol_heap_4_1 var_heap_4_2) ) ) (syntax.OverloadedListPatterns type_1_0 decons_expr_1_1 _x_1_2 -> case _x_1_2 (_predefined._Cons overloaded_list_pattern_2_0 _x_2_1 -> case _x_2_1 (_predefined._Nil -> let _x_4_0 = mergecases.split_case_19 split_var_info_ptr_1 (select overloaded_list_pattern_2_0::syntax._AlgebraicPattern 2) var_heap_2 symbol_heap_3, symbol_heap_4_1 = select _x_4_0::_Tuple3 2, var_heap_4_2 = select _x_4_0::_Tuple3 1 in <{mergecases._c;77;24_67}> (select _x_4_0::_Tuple3 0) this_case_4 type_1_0 decons_expr_1_1 overloaded_list_pattern_2_0 symbol_heap_4_1 var_heap_4_2) ) ) (syntax.NewTypePatterns type_1_0 _x_1_1 -> case _x_1_1 (_predefined._Cons newtype_pattern_2_0 _x_2_1 -> case _x_2_1 (_predefined._Nil -> let _x_4_0 = mergecases.split_case_19 split_var_info_ptr_1 (select newtype_pattern_2_0::syntax._AlgebraicPattern 2) var_heap_2 symbol_heap_3, symbol_heap_4_1 = select _x_4_0::_Tuple3 2, var_heap_4_2 = select _x_4_0::_Tuple3 1 in <{mergecases._c;89;24_68}> (select _x_4_0::_Tuple3 0) this_case_4 type_1_0 newtype_pattern_2_0 symbol_heap_4_1 var_heap_4_2) ) ) (syntax.DynamicPatterns _x_1_0 -> case _x_1_0 (_predefined._Cons dynamic_pattern_2_0 _x_2_1 -> case _x_2_1 (_predefined._Nil -> _Tuple3 general.No var_heap_2 symbol_heap_3) ) ) (_ -> _Tuple3 general.No var_heap_2 symbol_heap_3)
<{mergecases._c;89;24_68}> !_x_0 this_case_1 type_2 newtype_pattern_3 symbol_heap_4 var_heap_5 = case _x_0 (general.Yes split_case_1_0 -> case (StdBool.not (select split_case_1_0::syntax._Case 5)) (True -> let _x_3_0 = mergecases.push_expression_into_guards_and_default_23 (mergecases.anon_5 this_case_1 type_2 newtype_pattern_3) split_case_1_0 symbol_heap_4 in _Tuple3 (general.Yes (select _x_3_0::_Tuple2 0)) var_heap_5 (select _x_3_0::_Tuple2 1)) (False -> _Tuple3 general.No var_heap_5 symbol_heap_4) ) (general.No -> _Tuple3 general.No var_heap_5 symbol_heap_4) 
<{mergecases._c;77;24_67}> !_x_0 this_case_1 type_2 decons_expr_3 overloaded_list_pattern_4 symbol_heap_5 var_heap_6 = case _x_0 (general.Yes split_case_1_0 -> case (StdBool.not (select split_case_1_0::syntax._Case 5)) (True -> let _x_3_0 = mergecases.push_expression_into_guards_and_default_23 (mergecases.anon_4 this_case_1 type_2 decons_expr_3 overloaded_list_pattern_4) split_case_1_0 symbol_heap_5 in _Tuple3 (general.Yes (select _x_3_0::_Tuple2 0)) var_heap_6 (select _x_3_0::_Tuple2 1)) (False -> _Tuple3 general.No var_heap_6 symbol_heap_5) ) (general.No -> _Tuple3 general.No var_heap_6 symbol_heap_5) 
<{mergecases._c;65;24_66}> !_x_0 this_case_1 type_2 basic_pattern_3 symbol_heap_4 var_heap_5 = case _x_0 (general.Yes split_case_1_0 -> case (StdBool.not (select split_case_1_0::syntax._Case 5)) (True -> let _x_3_0 = mergecases.push_expression_into_guards_and_default_23 (mergecases.anon_3 this_case_1 type_2 basic_pattern_3) split_case_1_0 symbol_heap_4 in _Tuple3 (general.Yes (select _x_3_0::_Tuple2 0)) var_heap_5 (select _x_3_0::_Tuple2 1)) (False -> _Tuple3 general.No var_heap_5 symbol_heap_4) ) (general.No -> _Tuple3 general.No var_heap_5 symbol_heap_4) 
<{mergecases._c;53;24_65}> !_x_0 this_case_1 type_2 alg_pattern_3 symbol_heap_4 var_heap_5 = case _x_0 (general.Yes split_case_1_0 -> case (StdBool.not (select split_case_1_0::syntax._Case 5)) (True -> let _x_3_0 = mergecases.push_expression_into_guards_and_default_23 (mergecases.anon_2 this_case_1 type_2 alg_pattern_3) split_case_1_0 symbol_heap_4 in _Tuple3 (general.Yes (select _x_3_0::_Tuple2 0)) var_heap_5 (select _x_3_0::_Tuple2 1)) (False -> _Tuple3 general.No var_heap_5 symbol_heap_4) ) (general.No -> _Tuple3 general.No var_heap_5 symbol_heap_4) 
mergecases.build_aliases_17 !_x_0 !_x_1 !var_heap_2 = case _x_0 (_predefined._Cons var1_1_0 vars1_1_1 -> case _x_1 (_predefined._Cons _x_2_0 vars2_2_1 -> case _x_2_0 (syntax._FreeVar fv_def_level_3_0 fv_ident_3_1 fv_info_ptr_3_2 fv_count_3_3 -> mergecases.build_aliases_17 vars1_1_1 vars2_2_1 (Heap.writePtr (select var1_1_0::syntax._FreeVar 2) (syntax.VI_Variable fv_ident_3_1 fv_info_ptr_3_2) var_heap_2)) ) ) (_predefined._Nil -> case _x_1 (_predefined._Nil -> var_heap_2) ) 
mergecases.replace_variables_34 !_vunfold_0 vars_1 expr_2 ap_vars_3 var_heap_4 symbol_heap_5 = let _x_1_0 = select _vunfold_0::<{transform.unfold;}> 0 expr_2 (transform._UnfoldState (mergecases.build_aliases_17 vars_1 ap_vars_3 var_heap_4) symbol_heap_5 general.No), us_1_1 = select _x_1_0::_Tuple2 1 in _Tuple3 (select _x_1_0::_Tuple2 0) (select us_1_1::transform._UnfoldState 0) (select us_1_1::transform._UnfoldState 1)
mergecases.incompatible_patterns_in_case_error_37 !error_0 = checksupport.checkError (<{StdFile.<<<;}> <{StdFile.<<<_38}>) (<{StdFile.<<<;}> <{StdFile.<<<_38}>) "" "incompatible patterns in case" error_0
mergecases.replace_overloaded_symbol_in_pattern_18 !pattern_0 pd_cons_symbol_1::I pd_nil_symbol_2::I = case pattern_0 (syntax._AlgebraicPattern ap_symbol_1_0 ap_vars_1_1 ap_expr_1_2 ap_position_1_3 -> case ap_symbol_1_0 (syntax._Global glob_object_2_0 glob_module_2_1 -> case (<{StdInt.==_16}> glob_module_2_1 1) (True -> let index_4_0::I = <{StdInt.+_6}> (select glob_object_2_0::syntax._DefinedSymbol 2) 44 in case (<{StdInt.==_16}> index_4_0 50) (True -> update pattern_0::syntax._AlgebraicPattern [0:update (select pattern_0::syntax._AlgebraicPattern 0)::syntax._Global [0:update glob_object_2_0::syntax._DefinedSymbol [0:_SystemArray.select_3 predef.predefined_idents pd_cons_symbol_1,2:<{StdInt.-_7}> pd_cons_symbol_1 44]]]) (False -> case (<{StdInt.==_16}> index_4_0 57) (True -> update pattern_0::syntax._AlgebraicPattern [0:update (select pattern_0::syntax._AlgebraicPattern 0)::syntax._Global [0:update glob_object_2_0::syntax._DefinedSymbol [0:_SystemArray.select_3 predef.predefined_idents pd_nil_symbol_2,2:<{StdInt.-_7}> pd_nil_symbol_2 44]]]) (False -> StdMisc.abort "replace_overloaded_symbol_in_pattern") ) ) ) ) 
mergecases.replace_overloaded_symbols_in_patterns_36 !_x_0 pd_cons_symbol_1::I pd_nil_symbol_2::I = case _x_0 (_predefined._Nil -> _predefined._Nil) (_predefined._Cons pattern_1_0 patterns_1_1 -> case pattern_1_0 (syntax._AlgebraicPattern ap_symbol_2_0 ap_vars_2_1 ap_expr_2_2 ap_position_2_3 -> case ap_symbol_2_0 (syntax._Global glob_object_3_0 glob_module_3_1 -> _predefined._Cons (mergecases.replace_overloaded_symbol_in_pattern_18 pattern_1_0 pd_cons_symbol_1 pd_nil_symbol_2) (mergecases.replace_overloaded_symbols_in_patterns_36 patterns_1_1 pd_cons_symbol_1 pd_nil_symbol_2)) ) ) 
mergecases.merge_dynamic_patterns_35 patterns1_0 patterns2_1 var_heap_2 symbol_heap_3 error_4 = _Tuple4 (<{StdList.++}> patterns1_0 patterns2_1) var_heap_2 symbol_heap_3 error_4
mergecases.isOverloaded::B !_x_0 = case _x_0 (syntax.OverloadedList _x_1_0 _x_1_1 _x_1_2 _x_1_3 -> True) (_ -> False)
mergecases.replace_variables_63 vars_0 expr_1 ap_vars_2 var_heap_3 symbol_heap_4 = let _x_1_0 = transform.unfold_7 expr_1 (transform._UnfoldState (mergecases.build_aliases_17 vars_0 ap_vars_2 var_heap_3) symbol_heap_4 general.No), us_1_1 = select _x_1_0::_Tuple2 1 in _Tuple3 (select _x_1_0::_Tuple2 0) (select us_1_1::transform._UnfoldState 0) (select us_1_1::transform._UnfoldState 1)
mergecases.merge_basic_pattern_with_patterns_16 new_pattern_0 !_x_1 var_heap_2 symbol_heap_3 error_4 = case _x_1 (_predefined._Cons pattern_1_0 patterns_1_1 -> case pattern_1_0 (syntax._BasicPattern bp_value_2_0 bp_expr_2_1 bp_position_2_2 -> case (<{compare_types.==_18}> (select new_pattern_0::syntax._BasicPattern 0) bp_value_2_0) (True -> let _x_4_0 = mergecases.mergeCases (_Tuple2 bp_expr_2_1 syntax.NoPos) (_predefined._Cons (_Tuple2 (select new_pattern_0::syntax._BasicPattern 1) syntax.NoPos) _predefined._Nil) var_heap_2 symbol_heap_3 error_4 in _Tuple4 (_predefined._Cons (update pattern_1_0::syntax._BasicPattern [1:select (select _x_4_0::_Tuple4 0)::_Tuple2 0]) patterns_1_1) (select _x_4_0::_Tuple4 1) (select _x_4_0::_Tuple4 2) (select _x_4_0::_Tuple4 3)) (False -> let _x_4_0 = mergecases.merge_basic_pattern_with_patterns_16 new_pattern_0 patterns_1_1 var_heap_2 symbol_heap_3 error_4 in _Tuple4 (_predefined._Cons pattern_1_0 (select _x_4_0::_Tuple4 0)) (select _x_4_0::_Tuple4 1) (select _x_4_0::_Tuple4 2) (select _x_4_0::_Tuple4 3)) ) ) (_predefined._Nil -> _Tuple4 (_predefined._Cons new_pattern_0 _predefined._Nil) var_heap_2 symbol_heap_3 error_4) 
mergecases.merge_basic_patterns_33 patterns_0 !_x_1 var_heap_2 symbol_heap_3 error_4 = case _x_1 (_predefined._Nil -> _Tuple4 patterns_0 var_heap_2 symbol_heap_3 error_4) (_predefined._Cons alg_pattern_1_0 alg_patterns_1_1 -> let _x_2_0 = mergecases.merge_basic_pattern_with_patterns_16 alg_pattern_1_0 patterns_0 var_heap_2 symbol_heap_3 error_4 in mergecases.merge_basic_patterns_33 (select _x_2_0::_Tuple4 0) alg_patterns_1_1 (select _x_2_0::_Tuple4 1) (select _x_2_0::_Tuple4 2) (select _x_2_0::_Tuple4 3)) 
mergecases.merge_overloaded_list_patterns_31 type_0 decons_expr_1 patterns1_2 patterns2_3 var_heap_4 symbol_heap_5 error_6 = let _x_1_0 = mergecases.merge_algebraic_or_overloaded_list_patterns_32 patterns1_2 patterns2_3 var_heap_4 symbol_heap_5 error_6 in _Tuple4 (syntax.OverloadedListPatterns type_0 decons_expr_1 (select _x_1_0::_Tuple4 0)) (select _x_1_0::_Tuple4 1) (select _x_1_0::_Tuple4 2) (select _x_1_0::_Tuple4 3)
mergecases.merge_algebraic_patterns_30 type_0 patterns1_1 patterns2_2 var_heap_3 symbol_heap_4 error_5 = let _x_1_0 = mergecases.merge_algebraic_or_overloaded_list_patterns_32 patterns1_1 patterns2_2 var_heap_3 symbol_heap_4 error_5 in _Tuple4 (syntax.AlgebraicPatterns type_0 (select _x_1_0::_Tuple4 0)) (select _x_1_0::_Tuple4 1) (select _x_1_0::_Tuple4 2) (select _x_1_0::_Tuple4 3)
mergecases.merge_algebraic_pattern_with_patterns_15 new_pattern_0 !_x_1 var_heap_2 symbol_heap_3 error_4 = case _x_1 (_predefined._Cons pattern_1_0 patterns_1_1 -> case pattern_1_0 (syntax._AlgebraicPattern ap_symbol_2_0 ap_vars_2_1 ap_expr_2_2 ap_position_2_3 -> case (<{compare_types.==_20}> (<{StdOverloaded.==;}> <{compare_types.==_16}>) (select new_pattern_0::syntax._AlgebraicPattern 0) ap_symbol_2_0) (True -> case (StdList.isEmpty (select new_pattern_0::syntax._AlgebraicPattern 1)) (True -> let _x_5_0 = mergecases.mergeCases (_Tuple2 ap_expr_2_2 syntax.NoPos) (_predefined._Cons (_Tuple2 (select new_pattern_0::syntax._AlgebraicPattern 2) syntax.NoPos) _predefined._Nil) var_heap_2 symbol_heap_3 error_4 in _Tuple4 (_predefined._Cons (update pattern_1_0::syntax._AlgebraicPattern [2:select (select _x_5_0::_Tuple4 0)::_Tuple2 0]) patterns_1_1) (select _x_5_0::_Tuple4 1) (select _x_5_0::_Tuple4 2) (select _x_5_0::_Tuple4 3)) (False -> let _x_5_0 = mergecases.replace_variables_63 (select new_pattern_0::syntax._AlgebraicPattern 1) (select new_pattern_0::syntax._AlgebraicPattern 2) ap_vars_2_1 var_heap_2 symbol_heap_3, _x_5_1 = mergecases.mergeCases (_Tuple2 ap_expr_2_2 syntax.NoPos) (_predefined._Cons (_Tuple2 (select _x_5_0::_Tuple3 0) syntax.NoPos) _predefined._Nil) (select _x_5_0::_Tuple3 1) (select _x_5_0::_Tuple3 2) error_4 in _Tuple4 (_predefined._Cons (update pattern_1_0::syntax._AlgebraicPattern [2:select (select _x_5_1::_Tuple4 0)::_Tuple2 0]) patterns_1_1) (select _x_5_1::_Tuple4 1) (select _x_5_1::_Tuple4 2) (select _x_5_1::_Tuple4 3)) ) (False -> let _x_4_0 = mergecases.merge_algebraic_pattern_with_patterns_15 new_pattern_0 patterns_1_1 var_heap_2 symbol_heap_3 error_4 in _Tuple4 (_predefined._Cons pattern_1_0 (select _x_4_0::_Tuple4 0)) (select _x_4_0::_Tuple4 1) (select _x_4_0::_Tuple4 2) (select _x_4_0::_Tuple4 3)) ) ) (_predefined._Nil -> _Tuple4 (_predefined._Cons new_pattern_0 _predefined._Nil) var_heap_2 symbol_heap_3 error_4) 
mergecases.merge_algebraic_or_overloaded_list_patterns_32 patterns_0 !_x_1 var_heap_2 symbol_heap_3 error_4 = case _x_1 (_predefined._Nil -> _Tuple4 patterns_0 var_heap_2 symbol_heap_3 error_4) (_predefined._Cons alg_pattern_1_0 alg_patterns_1_1 -> let _x_2_0 = mergecases.merge_algebraic_pattern_with_patterns_15 alg_pattern_1_0 patterns_0 var_heap_2 symbol_heap_3 error_4 in mergecases.merge_algebraic_or_overloaded_list_patterns_32 (select _x_2_0::_Tuple4 0) alg_patterns_1_1 (select _x_2_0::_Tuple4 1) (select _x_2_0::_Tuple4 2) (select _x_2_0::_Tuple4 3)) 
mergecases.merge_guards_29 !guards_0 _x_1 var_heap_2 symbol_heap_3 error_4 = case guards_0 (syntax.AlgebraicPatterns type1_1_0 patterns1_1_1 -> case _x_1 (syntax.AlgebraicPatterns type2_2_0 patterns2_2_1 -> case (<{syntax.==_74}> type1_1_0 type2_2_0) (True -> mergecases.merge_algebraic_patterns_30 type1_1_0 patterns1_1_1 patterns2_2_1 var_heap_2 symbol_heap_3 error_4) (False -> _Tuple4 guards_0 var_heap_2 symbol_heap_3 (mergecases.incompatible_patterns_in_case_error_37 error_4)) ) (syntax.OverloadedListPatterns type2_2_0 decons_expr2_2_1 patterns2_2_2 -> case (case (<{StdInt.==_16}> (select type1_1_0::syntax._GlobalIndex 0) 1) (True -> mergecases.isOverloaded type2_2_0) (False -> False) ) (True -> let index_4_0::I = <{StdInt.+_6}> (select type1_1_0::syntax._GlobalIndex 1) 1 in case (<{StdInt.==_16}> index_4_0 2) (True -> mergecases.merge_algebraic_patterns_30 type1_1_0 patterns1_1_1 (mergecases.replace_overloaded_symbols_in_patterns_36 patterns2_2_2 44 51) var_heap_2 symbol_heap_3 error_4) (False -> case (<{StdInt.==_16}> index_4_0 3) (True -> mergecases.merge_algebraic_patterns_30 type1_1_0 patterns1_1_1 (mergecases.replace_overloaded_symbols_in_patterns_36 patterns2_2_2 45 52) var_heap_2 symbol_heap_3 error_4) (False -> case (<{StdInt.==_16}> index_4_0 5) (True -> mergecases.merge_algebraic_patterns_30 type1_1_0 patterns1_1_1 (mergecases.replace_overloaded_symbols_in_patterns_36 patterns2_2_2 47 54) var_heap_2 symbol_heap_3 error_4) (False -> case (<{StdInt.==_16}> index_4_0 6) (True -> mergecases.merge_algebraic_patterns_30 type1_1_0 patterns1_1_1 (mergecases.replace_overloaded_symbols_in_patterns_36 patterns2_2_2 48 55) var_heap_2 symbol_heap_3 error_4) (False -> _Tuple4 guards_0 var_heap_2 symbol_heap_3 (mergecases.incompatible_patterns_in_case_error_37 error_4)) ) ) ) ) ) ) (syntax.BasicPatterns basic_type1_1_0 patterns1_1_1 -> case _x_1 (syntax.BasicPatterns basic_type2_2_0 patterns2_2_1 -> case (<{compare_types.==_11}> basic_type1_1_0 basic_type2_2_0) (True -> let _x_4_0 = mergecases.merge_basic_patterns_33 patterns1_1_1 patterns2_2_1 var_heap_2 symbol_heap_3 error_4 in _Tuple4 (syntax.BasicPatterns basic_type1_1_0 (select _x_4_0::_Tuple4 0)) (select _x_4_0::_Tuple4 1) (select _x_4_0::_Tuple4 2) (select _x_4_0::_Tuple4 3)) (False -> _Tuple4 guards_0 var_heap_2 symbol_heap_3 (mergecases.incompatible_patterns_in_case_error_37 error_4)) ) ) (syntax.OverloadedListPatterns type1_1_0 decons_expr1_1_1 patterns1_1_2 -> case _x_1 (syntax.OverloadedListPatterns type2_2_0 decons_expr2_2_1 patterns2_2_2 -> case (<{syntax.==_13}> type1_1_0 type2_2_0) (True -> mergecases.merge_overloaded_list_patterns_31 type1_1_0 decons_expr1_1_1 patterns1_1_2 patterns2_2_2 var_heap_2 symbol_heap_3 error_4) (False -> <{mergecases._c;274;11_73}> (_Tuple2 type1_1_0 type2_2_0) type2_2_0 decons_expr2_2_1 patterns1_1_2 patterns2_2_2 var_heap_2 symbol_heap_3 error_4 type1_1_0 decons_expr1_1_1 guards_0) ) (syntax.AlgebraicPatterns type2_2_0 patterns2_2_1 -> case (case (<{StdInt.==_16}> (select type2_2_0::syntax._GlobalIndex 0) 1) (True -> mergecases.isOverloaded type1_1_0) (False -> False) ) (True -> let index_4_0::I = <{StdInt.+_6}> (select type2_2_0::syntax._GlobalIndex 1) 1 in case (<{StdInt.==_16}> index_4_0 2) (True -> mergecases.merge_algebraic_patterns_30 type2_2_0 (mergecases.replace_overloaded_symbols_in_patterns_36 patterns1_1_2 44 51) patterns2_2_1 var_heap_2 symbol_heap_3 error_4) (False -> case (<{StdInt.==_16}> index_4_0 3) (True -> mergecases.merge_algebraic_patterns_30 type2_2_0 (mergecases.replace_overloaded_symbols_in_patterns_36 patterns1_1_2 45 52) patterns2_2_1 var_heap_2 symbol_heap_3 error_4) (False -> case (<{StdInt.==_16}> index_4_0 5) (True -> mergecases.merge_algebraic_patterns_30 type2_2_0 (mergecases.replace_overloaded_symbols_in_patterns_36 patterns1_1_2 47 54) patterns2_2_1 var_heap_2 symbol_heap_3 error_4) (False -> case (<{StdInt.==_16}> index_4_0 6) (True -> mergecases.merge_algebraic_patterns_30 type2_2_0 (mergecases.replace_overloaded_symbols_in_patterns_36 patterns1_1_2 48 55) patterns2_2_1 var_heap_2 symbol_heap_3 error_4) (False -> _Tuple4 guards_0 var_heap_2 symbol_heap_3 (mergecases.incompatible_patterns_in_case_error_37 error_4)) ) ) ) ) ) ) (syntax.NewTypePatterns type1_1_0 patterns1_1_1 -> case _x_1 (syntax.NewTypePatterns type2_2_0 patterns2_2_1 -> case (<{syntax.==_74}> type1_1_0 type2_2_0) (True -> let _x_4_0 = mergecases.merge_algebraic_or_overloaded_list_patterns_32 patterns1_1_1 patterns2_2_1 var_heap_2 symbol_heap_3 error_4 in _Tuple4 (syntax.NewTypePatterns type1_1_0 (select _x_4_0::_Tuple4 0)) (select _x_4_0::_Tuple4 1) (select _x_4_0::_Tuple4 2) (select _x_4_0::_Tuple4 3)) (False -> _Tuple4 guards_0 var_heap_2 symbol_heap_3 (mergecases.incompatible_patterns_in_case_error_37 error_4)) ) ) (syntax.DynamicPatterns patterns1_1_0 -> case _x_1 (syntax.DynamicPatterns patterns2_2_0 -> let _x_3_0 = mergecases.merge_dynamic_patterns_35 patterns1_1_0 patterns2_2_0 var_heap_2 symbol_heap_3 error_4 in _Tuple4 (syntax.DynamicPatterns (select _x_3_0::_Tuple4 0)) (select _x_3_0::_Tuple4 1) (select _x_3_0::_Tuple4 2) (select _x_3_0::_Tuple4 3)) ) (_ -> _Tuple4 guards_0 var_heap_2 symbol_heap_3 (mergecases.incompatible_patterns_in_case_error_37 error_4))
mergecases.mergeCases !expr_and_pos_0 !_x_1 !var_heap_2 !symbol_heap_3 !error_4 = case _x_1 (_predefined._Nil -> <{_Tuple4!15}> expr_and_pos_0 var_heap_2 symbol_heap_3 error_4) (_ -> case expr_and_pos_0 (_Tuple2 _x_1_0 pos_1_1 -> case _x_1_0 (syntax.Let lad_2_0 -> case lad_2_0 (syntax._Let let_strict_binds_3_0 let_lazy_binds_3_1 let_expr_3_2 let_info_ptr_3_3 let_expr_position_3_4 -> let _x_4_0 = mergecases.mergeCases (_Tuple2 let_expr_3_2 syntax.NoPos) _x_1 var_heap_2 symbol_heap_3 error_4 in <{_Tuple4!15}> (_Tuple2 (syntax.Let (update lad_2_0::syntax._Let [2:select (select _x_4_0::_Tuple4 0)::_Tuple2 0])) pos_1_1) (select _x_4_0::_Tuple4 1) (select _x_4_0::_Tuple4 2) (select _x_4_0::_Tuple4 3)) ) (syntax.Case first_case_2_0 -> case first_case_2_0 (syntax._Case case_expr_3_0 case_guards_3_1 case_default_3_2 case_ident_3_3 case_info_ptr_3_4 case_explicit_3_5 case_default_pos_3_6 -> case case_expr_3_0 (syntax.Var _x_4_0 -> case _x_4_0 (syntax._BoundVar var_ident_5_0 var_info_ptr_5_1 var_expr_ptr_5_2 -> case case_default_3_2 (general.No -> case _x_1 (_predefined._Cons _x_7_0 exprs_7_1 -> case _x_7_0 (_Tuple2 expr_8_0 expr_pos_8_1 -> case (StdBool.not case_explicit_3_5) (True -> let _x_10_0 = mergecases.split_case_19 var_info_ptr_5_1 expr_8_0 var_heap_2 symbol_heap_3, symbol_heap_10_1 = select _x_10_0::_Tuple3 2, var_heap_10_2 = select _x_10_0::_Tuple3 1 in <{mergecases._c;36;11_71}> (select _x_10_0::_Tuple3 0) first_case_2_0 var_heap_10_2 symbol_heap_10_1 error_4 exprs_7_1 expr_8_0 expr_pos_8_1 pos_1_1) ) ) ) ) ) (_ -> case _x_1 (_predefined._Cons expr_4_0 exprs_4_1 -> case (StdBool.not case_explicit_3_5) (True -> <{mergecases._c;415;11_72}> case_default_3_2 case_default_pos_3_6 expr_4_0 exprs_4_1 var_heap_2 symbol_heap_3 error_4 first_case_2_0 pos_1_1) ) )) ) (_ -> <{_Tuple4!15}> expr_and_pos_0 var_heap_2 symbol_heap_3 (checksupport.checkWarning (<{StdFile.<<<;}> <{StdFile.<<<_38}>) (<{StdFile.<<<;}> <{StdFile.<<<_38}>) "" " alternative will never match" error_4))) )
<{mergecases._c;274;11_73}> !_x_0 type2_1 decons_expr2_2 patterns1_3 patterns2_4 var_heap_5 symbol_heap_6 error_7 type1_8 decons_expr1_9 guards_10 = case _x_0 (_Tuple2 _x_1_0 _x_1_1 -> case _x_1_0 (syntax.OverloadedList _x_2_0 _x_2_1 _x_2_2 _x_2_3 -> case _x_1_1 (syntax.UnboxedList type_symbol_3_0 stdStrictLists_index_3_1 decons_index_3_2 nil_index_3_3 -> mergecases.merge_overloaded_list_patterns_31 type2_1 decons_expr2_2 (mergecases.replace_overloaded_symbols_in_patterns_36 patterns1_3 46 53) patterns2_4 var_heap_5 symbol_heap_6 error_7) (syntax.UnboxedTailStrictList type_symbol_3_0 stdStrictLists_index_3_1 decons_index_3_2 nil_index_3_3 -> mergecases.merge_overloaded_list_patterns_31 type2_1 decons_expr2_2 (mergecases.replace_overloaded_symbols_in_patterns_36 patterns1_3 49 56) patterns2_4 var_heap_5 symbol_heap_6 error_7) ) (syntax.UnboxedList type_symbol_2_0 stdStrictLists_index_2_1 decons_index_2_2 nil_index_2_3 -> case _x_1_1 (syntax.OverloadedList _x_3_0 _x_3_1 _x_3_2 _x_3_3 -> mergecases.merge_overloaded_list_patterns_31 type1_8 decons_expr1_9 patterns1_3 (mergecases.replace_overloaded_symbols_in_patterns_36 patterns2_4 46 53) var_heap_5 symbol_heap_6 error_7) ) (syntax.UnboxedTailStrictList type_symbol_2_0 stdStrictLists_index_2_1 decons_index_2_2 nil_index_2_3 -> case _x_1_1 (syntax.OverloadedList _x_3_0 _x_3_1 _x_3_2 _x_3_3 -> mergecases.merge_overloaded_list_patterns_31 type1_8 decons_expr1_9 patterns1_3 (mergecases.replace_overloaded_symbols_in_patterns_36 patterns2_4 49 56) var_heap_5 symbol_heap_6 error_7) ) ) (_ -> _Tuple4 guards_10 var_heap_5 symbol_heap_6 (mergecases.incompatible_patterns_in_case_error_37 error_7))
<{mergecases._c;415;11_72}> !case_default_0 case_default_pos_1 expr_2 exprs_3 !var_heap_4 !symbol_heap_5 !error_6 !first_case_7 !pos_8 = case case_default_0 (general.Yes default_expr_1_0 -> let _x_2_0 = mergecases.mergeCases (_Tuple2 default_expr_1_0 case_default_pos_1) (_predefined._Cons expr_2 exprs_3) var_heap_4 symbol_heap_5 error_6, _x_2_1 = select _x_2_0::_Tuple4 0 in <{_Tuple4!15}> (_Tuple2 (syntax.Case (update first_case_7::syntax._Case [2:general.Yes (select _x_2_1::_Tuple2 0),6:select _x_2_1::_Tuple2 1])) pos_8) (select _x_2_0::_Tuple4 1) (select _x_2_0::_Tuple4 2) (select _x_2_0::_Tuple4 3)) (general.No -> let _x_2_0 = mergecases.mergeCases expr_2 exprs_3 var_heap_4 symbol_heap_5 error_6, _x_2_1 = select _x_2_0::_Tuple4 0 in <{_Tuple4!15}> (_Tuple2 (syntax.Case (update first_case_7::syntax._Case [2:general.Yes (select _x_2_1::_Tuple2 0),6:select _x_2_1::_Tuple2 1])) pos_8) (select _x_2_0::_Tuple4 1) (select _x_2_0::_Tuple4 2) (select _x_2_0::_Tuple4 3)) 
<{mergecases._c;36;11_71}> !_x_0 !first_case_1 var_heap_2 symbol_heap_3 error_4 !exprs_5 expr_6 expr_pos_7 pos_8 = case _x_0 (general.Yes _x_1_0 -> case _x_1_0 (syntax._Case case_expr_2_0 case_guards_2_1 case_default_2_2 case_ident_2_3 case_info_ptr_2_4 case_explicit_2_5 case_default_pos_2_6 -> let _x_3_0 = mergecases.merge_guards_29 (select first_case_1::syntax._Case 1) case_guards_2_1 var_heap_2 symbol_heap_3 error_4 in mergecases.mergeCases (_Tuple2 (syntax.Case (update first_case_1::syntax._Case [1:select _x_3_0::_Tuple4 0,2:case_default_2_2,3:case_ident_2_3,5:case_explicit_2_5])) syntax.NoPos) exprs_5 (select _x_3_0::_Tuple4 1) (select _x_3_0::_Tuple4 2) (select _x_3_0::_Tuple4 3)) ) (general.No -> let _x_2_0 = mergecases.mergeCases (_Tuple2 expr_6 expr_pos_7) exprs_5 var_heap_2 symbol_heap_3 error_4, _x_2_1 = select _x_2_0::_Tuple4 0 in <{_Tuple4!15}> (_Tuple2 (syntax.Case (update first_case_1::syntax._Case [2:general.Yes (select _x_2_1::_Tuple2 0),6:select _x_2_1::_Tuple2 1])) pos_8) (select _x_2_0::_Tuple4 1) (select _x_2_0::_Tuple4 2) (select _x_2_0::_Tuple4 3)) 
<{mergecases.TD;GetSetPatternRhs;}> _x_0::B = _predefined._Nil


|| Converted Records
:: <{mergecases.GetSetPatternRhs;}> = {!mergecases.get_pattern_rhs, !mergecases.set_pattern_rhs}

