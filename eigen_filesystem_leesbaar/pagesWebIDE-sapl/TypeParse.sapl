|| ?module? TypeParse


TypeParse.anon_5 c_0 !f_1 = f_1 c_0
TypeParse.isIdentChar_7::B c_0::C = StdList.any (TypeParse.anon_5 c_0) (_predefined._Cons StdChar.isLower (_predefined._Cons StdChar.isUpper (_predefined._Cons StdChar.isDigit (_predefined._Cons (<{StdChar.==_18}> '_') (_predefined._Cons (<{StdChar.==_18}> '`') _predefined._Nil)))))
TypeParse.isFunny_8::B c_0::C = StdList.isMember_52 c_0 (_predefined._Cons '~' (_predefined._Cons '@' (_predefined._Cons '#' (_predefined._Cons '$' (_predefined._Cons '%' (_predefined._Cons '^' (_predefined._Cons '?' (_predefined._Cons '!' (_predefined._Cons '+' (_predefined._Cons '-' (_predefined._Cons '*' (_predefined._Cons '<' (_predefined._Cons '>' (_predefined._Cons '\\' (_predefined._Cons '/' (_predefined._Cons '|' (_predefined._Cons '&' (_predefined._Cons '=' (_predefined._Cons ':' _predefined._Nil)))))))))))))))))))
TypeParse.tkz_6 tks_0 !_x_1 = case _x_1 (_predefined._Nil -> Data.Maybe.Just tks_0) (_predefined._Cons _x_1_0 _x_1_1 -> case _x_1_0 ('-' -> case _x_1_1 (_predefined._Cons _x_3_0 cs_3_1 -> case _x_3_0 ('>' -> TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons TypeParse.TArrow _predefined._Nil)) cs_3_1) ) ) (',' -> TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons TypeParse.TComma _predefined._Nil)) _x_1_1) ('*' -> TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons TypeParse.TUnique _predefined._Nil)) _x_1_1) ('.' -> TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons TypeParse.TAnonymous _predefined._Nil)) _x_1_1) ('#' -> TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons TypeParse.TUnboxed _predefined._Nil)) _x_1_1) ('!' -> TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons TypeParse.TStrict _predefined._Nil)) _x_1_1) ('(' -> TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons TypeParse.TParenOpen _predefined._Nil)) _x_1_1) (')' -> TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons TypeParse.TParenClose _predefined._Nil)) _x_1_1) ('[' -> TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons TypeParse.TBrackOpen _predefined._Nil)) _x_1_1) (']' -> TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons TypeParse.TBrackClose _predefined._Nil)) _x_1_1) ('{' -> TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons TypeParse.TBraceOpen _predefined._Nil)) _x_1_1) ('}' -> TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons TypeParse.TBraceClose _predefined._Nil)) _x_1_1) ('A' -> case _x_1_1 (_predefined._Cons _x_3_0 cs_3_1 -> case _x_3_0 ('.' -> TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons TypeParse.TUniversalQuantifier _predefined._Nil)) cs_3_1) ) ) (':' -> TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons TypeParse.TColon _predefined._Nil)) _x_1_1) (_ -> case (StdChar.isSpace _x_1_0) (True -> TypeParse.tkz_6 tks_0 _x_1_1) (False -> case (StdChar.isUpper _x_1_0) (True -> let _x_4_0 = StdList.span TypeParse.isIdentChar_7 _x_1_1 in TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons (TypeParse.TIdent (StdList.toString_79 (_predefined._Cons _x_1_0 (select _x_4_0::_Tuple2 0)))) _predefined._Nil)) (select _x_4_0::_Tuple2 1)) (False -> case (TypeParse.isFunny_8 _x_1_0) (True -> let _x_5_0 = StdList.span TypeParse.isFunny_8 _x_1_1 in TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons (TypeParse.TIdent (StdList.toString_79 (_predefined._Cons _x_1_0 (select _x_5_0::_Tuple2 0)))) _predefined._Nil)) (select _x_5_0::_Tuple2 1)) (False -> case (StdChar.isLower _x_1_0) (True -> let _x_6_0 = StdList.span TypeParse.isIdentChar_7 _x_1_1 in TypeParse.tkz_6 (<{StdList.++}> tks_0 (_predefined._Cons (TypeParse.TVar (StdList.toString_79 (_predefined._Cons _x_1_0 (select _x_6_0::_Tuple2 0)))) _predefined._Nil)) (select _x_6_0::_Tuple2 1)) ) ) ) )) (_ -> Data.Maybe.Nothing)
TypeParse.tokenize = TypeParse.tkz_6 _predefined._Nil
TypeParse.anon_16 !es_0 e_1 = <{StdList.++}> es_0 (_predefined._Cons e_1 _predefined._Nil)
TypeParse.seplist_21 !_vEq_0 sep_1 p_2 = <{Yard.<|>_15}> (<{Yard.<|>_15}> (Control.Monad.liftM2 (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) TypeParse.anon_16 (Control.Applicative.some (<{Control.Applicative.Alternative;}> <{Yard.<|>_15}> Yard.empty_16 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) (<{Control.Applicative.<*}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) p_2 (Yard.item _vEq_0 sep_1))) p_2) (Control.Monad.liftM (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) Control.Applicative.pure_17 p_2)) (Yard.pure_13 Control.Applicative.empty_21)
TypeParse.anon_13 ts_0 = TypeDef.Type (<{StdString.+++_11}> "_Tuple" (StdString.toString_5 (StdList.length_47 ts_0))) ts_0
TypeParse.anon_12 t_0 = TypeDef.Type "_List" (_predefined._Cons t_0 _predefined._Nil)
TypeParse.anon_11 t_0 = TypeDef.Type "_Array" (_predefined._Cons t_0 _predefined._Nil)
TypeParse.anon_10 t_0 = TypeDef.Type "_#Array" (_predefined._Cons t_0 _predefined._Nil)
TypeParse.toGenericToken_60 !x_0 = case x_0 (TypeParse.TIdent x11_1_0 -> StdGeneric.OBJECT (StdGeneric.LEFT (StdGeneric.LEFT (StdGeneric.LEFT (StdGeneric.LEFT (StdGeneric.CONS x11_1_0)))))) (TypeParse.TVar x21_1_0 -> StdGeneric.OBJECT (StdGeneric.LEFT (StdGeneric.LEFT (StdGeneric.LEFT (StdGeneric.RIGHT (StdGeneric.CONS x21_1_0)))))) (TypeParse.TArrow -> StdGeneric.OBJECT (StdGeneric.LEFT (StdGeneric.LEFT (StdGeneric.RIGHT (StdGeneric.LEFT (StdGeneric.CONS StdGeneric.UNIT)))))) (TypeParse.TComma -> StdGeneric.OBJECT (StdGeneric.LEFT (StdGeneric.LEFT (StdGeneric.RIGHT (StdGeneric.RIGHT (StdGeneric.CONS StdGeneric.UNIT)))))) (TypeParse.TUnique -> StdGeneric.OBJECT (StdGeneric.LEFT (StdGeneric.RIGHT (StdGeneric.LEFT (StdGeneric.LEFT (StdGeneric.CONS StdGeneric.UNIT)))))) (TypeParse.TAnonymous -> StdGeneric.OBJECT (StdGeneric.LEFT (StdGeneric.RIGHT (StdGeneric.LEFT (StdGeneric.RIGHT (StdGeneric.CONS StdGeneric.UNIT)))))) (TypeParse.TUnboxed -> StdGeneric.OBJECT (StdGeneric.LEFT (StdGeneric.RIGHT (StdGeneric.RIGHT (StdGeneric.LEFT (StdGeneric.CONS StdGeneric.UNIT)))))) (TypeParse.TStrict -> StdGeneric.OBJECT (StdGeneric.LEFT (StdGeneric.RIGHT (StdGeneric.RIGHT (StdGeneric.RIGHT (StdGeneric.CONS StdGeneric.UNIT)))))) (TypeParse.TColon -> StdGeneric.OBJECT (StdGeneric.RIGHT (StdGeneric.LEFT (StdGeneric.LEFT (StdGeneric.LEFT (StdGeneric.CONS StdGeneric.UNIT)))))) (TypeParse.TUniversalQuantifier -> StdGeneric.OBJECT (StdGeneric.RIGHT (StdGeneric.LEFT (StdGeneric.LEFT (StdGeneric.RIGHT (StdGeneric.CONS StdGeneric.UNIT)))))) (TypeParse.TParenOpen -> StdGeneric.OBJECT (StdGeneric.RIGHT (StdGeneric.LEFT (StdGeneric.RIGHT (StdGeneric.LEFT (StdGeneric.CONS StdGeneric.UNIT)))))) (TypeParse.TParenClose -> StdGeneric.OBJECT (StdGeneric.RIGHT (StdGeneric.LEFT (StdGeneric.RIGHT (StdGeneric.RIGHT (StdGeneric.CONS StdGeneric.UNIT)))))) (TypeParse.TBrackOpen -> StdGeneric.OBJECT (StdGeneric.RIGHT (StdGeneric.RIGHT (StdGeneric.LEFT (StdGeneric.LEFT (StdGeneric.CONS StdGeneric.UNIT)))))) (TypeParse.TBrackClose -> StdGeneric.OBJECT (StdGeneric.RIGHT (StdGeneric.RIGHT (StdGeneric.LEFT (StdGeneric.RIGHT (StdGeneric.CONS StdGeneric.UNIT)))))) (TypeParse.TBraceOpen -> StdGeneric.OBJECT (StdGeneric.RIGHT (StdGeneric.RIGHT (StdGeneric.RIGHT (StdGeneric.LEFT (StdGeneric.CONS StdGeneric.UNIT)))))) (TypeParse.TBraceClose -> StdGeneric.OBJECT (StdGeneric.RIGHT (StdGeneric.RIGHT (StdGeneric.RIGHT (StdGeneric.RIGHT (StdGeneric.CONS StdGeneric.UNIT)))))) 
TypeParse.gEq_Token_23::B x1_0 x2_1 = GenEq.gEq_OBJECT_13 (GenEq.gEq_EITHER_9 (GenEq.gEq_EITHER_9 (GenEq.gEq_EITHER_9 (GenEq.gEq_EITHER_9 (GenEq.gEq_CONS_10 GenEq.gEq__String_6) (GenEq.gEq_CONS_10 GenEq.gEq__String_6)) (GenEq.gEq_EITHER_9 (GenEq.gEq_CONS_10 GenEq.gEq_UNIT_7) (GenEq.gEq_CONS_10 GenEq.gEq_UNIT_7))) (GenEq.gEq_EITHER_9 (GenEq.gEq_EITHER_9 (GenEq.gEq_CONS_10 GenEq.gEq_UNIT_7) (GenEq.gEq_CONS_10 GenEq.gEq_UNIT_7)) (GenEq.gEq_EITHER_9 (GenEq.gEq_CONS_10 GenEq.gEq_UNIT_7) (GenEq.gEq_CONS_10 GenEq.gEq_UNIT_7)))) (GenEq.gEq_EITHER_9 (GenEq.gEq_EITHER_9 (GenEq.gEq_EITHER_9 (GenEq.gEq_CONS_10 GenEq.gEq_UNIT_7) (GenEq.gEq_CONS_10 GenEq.gEq_UNIT_7)) (GenEq.gEq_EITHER_9 (GenEq.gEq_CONS_10 GenEq.gEq_UNIT_7) (GenEq.gEq_CONS_10 GenEq.gEq_UNIT_7))) (GenEq.gEq_EITHER_9 (GenEq.gEq_EITHER_9 (GenEq.gEq_CONS_10 GenEq.gEq_UNIT_7) (GenEq.gEq_CONS_10 GenEq.gEq_UNIT_7)) (GenEq.gEq_EITHER_9 (GenEq.gEq_CONS_10 GenEq.gEq_UNIT_7) (GenEq.gEq_CONS_10 GenEq.gEq_UNIT_7))))) (TypeParse.toGenericToken_60 x1_0) (TypeParse.toGenericToken_60 x2_1)
<{TypeParse.==_22}>::B !a_0 !b_1 = <{GenEq.===}> (<{TypeParse.gEq_s;}> TypeParse.gEq_Token_23) a_0 b_1
TypeParse.isTVar::B !_x_0 = case _x_0 (TypeParse.TVar _x_1_0 -> True) (_ -> False)
TypeParse.anon_15 !_x_0 = case _x_0 (TypeParse.TVar var_1_0 -> var_1_0) 
TypeParse.var_19 = <{Data.Functor.<$>}> (<{Data.Functor.Functor;}> Yard.fmap_11) TypeParse.anon_15 (Yard.satisfy TypeParse.isTVar)
TypeParse.isTIdent::B !_x_0 = case _x_0 (TypeParse.TIdent _x_1_0 -> True) (_ -> False)
TypeParse.anon_14 !_x_0 = case _x_0 (TypeParse.TIdent id_1_0 -> id_1_0) 
TypeParse.ident_18 = <{Data.Functor.<$>}> (<{Data.Functor.Functor;}> Yard.fmap_11) TypeParse.anon_14 (Yard.satisfy TypeParse.isTIdent)
TypeParse.anon_9 t_0 = TypeDef.Type t_0 _predefined._Nil
TypeParse.seplist_105 sep_0 p_1 = <{Yard.<|>_15}> (<{Yard.<|>_15}> (Control.Monad.liftM2 (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) TypeParse.anon_16 (Control.Applicative.some (<{Control.Applicative.Alternative;}> <{Yard.<|>_15}> Yard.empty_16 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) (<{Control.Applicative.<*}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) p_1 (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) sep_0))) p_1) (Control.Monad.liftM (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) Control.Applicative.pure_17 p_1)) (Yard.pure_13 Control.Applicative.empty_21)
TypeParse.uniq_20 unqvar_0 = <{Control.Applicative.*>}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TUnique) (TypeParse.argtype_17 unqvar_0)
TypeParse.argtype_17 unqvar_0 = <{Yard.<|>_15}> (<{Yard.<|>_15}> (<{Yard.<|>_15}> (<{Yard.<|>_15}> (<{Yard.<|>_15}> (<{Yard.<|>_15}> (<{Yard.<|>_15}> (<{Yard.<|>_15}> (<{Yard.<|>_15}> (<{Yard.<|>_15}> (<{Yard.<|>_15}> (<{Yard.<|>_15}> (<{Yard.<|>_15}> (<{Control.Monad.>>|}> (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) (<{Control.Applicative.*>}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TParenOpen) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TParenClose)) (Yard.pure_13 (TypeDef.Type "_Unit" _predefined._Nil))) (<{Control.Applicative.<*}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (<{Control.Applicative.*>}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TParenOpen) TypeParse.type) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TParenClose))) (<{Control.Monad.>>|}> (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) (TypeParse.TIdent "String")) (Yard.pure_13 (TypeDef.Type "_#Array" (_predefined._Cons (TypeDef.Type "Char" _predefined._Nil) _predefined._Nil))))) (Control.Monad.liftM (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) TypeParse.anon_9 TypeParse.ident_18)) (Control.Monad.liftM (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) TypeDef.Var TypeParse.var_19)) (Control.Monad.liftM (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) TypeDef.Uniq (TypeParse.uniq_20 unqvar_0))) (Control.Monad.liftM (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) TypeParse.anon_10 (<{Control.Applicative.<*}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (<{Control.Applicative.*>}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (Yard.list (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) (_predefined._Cons TypeParse.TBraceOpen (_predefined._Cons TypeParse.TUnboxed _predefined._Nil))) TypeParse.type) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TBraceClose)))) (Control.Monad.liftM (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) TypeParse.anon_11 (<{Control.Applicative.<*}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (<{Control.Applicative.*>}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TBraceOpen) TypeParse.type) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TBraceClose)))) (Control.Monad.liftM (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) TypeParse.anon_12 (<{Control.Applicative.<*}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (<{Control.Applicative.*>}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TBrackOpen) TypeParse.type) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TBrackClose)))) (Control.Monad.liftM (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) TypeParse.anon_13 (<{Control.Applicative.<*}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (<{Control.Applicative.*>}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TParenOpen) (TypeParse.seplist_105 TypeParse.TComma TypeParse.type)) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TParenClose)))) (<{Control.Applicative.*>}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TStrict) (TypeParse.argtype_17 unqvar_0))) (<{Control.Applicative.*>}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TUnboxed) (TypeParse.argtype_17 unqvar_0))) (<{Control.Applicative.*>}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TAnonymous) (TypeParse.argtype_17 unqvar_0))) (<{Control.Applicative.*>}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (<{Control.Applicative.*>}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) unqvar_0 (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TColon)) (TypeParse.argtype_17 unqvar_0))
TypeParse.type = let unqvar_1_0 = TypeParse.var_19 in <{Yard.<|>_15}> (<{Yard.<|>_15}> (<{Yard.<|>_15}> (<{Yard.<|>_15}> (<{Yard.<|>_15}> (Control.Monad.liftM3 (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) TypeDef.Func (Control.Applicative.some (<{Control.Applicative.Alternative;}> <{Yard.<|>_15}> Yard.empty_16 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) (TypeParse.argtype_17 unqvar_1_0)) (<{Control.Applicative.*>}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TArrow) TypeParse.type) (Yard.pure_13 _predefined._Nil)) (Control.Monad.liftM2 (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) TypeDef.Cons TypeParse.var_19 (Control.Applicative.some (<{Control.Applicative.Alternative;}> <{Yard.<|>_15}> Yard.empty_16 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) (TypeParse.argtype_17 unqvar_1_0)))) (<{Control.Monad.>>|}> (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) (TypeParse.TIdent "String")) (Yard.pure_13 (TypeDef.Type "_#Array" (_predefined._Cons (TypeDef.Type "Char" _predefined._Nil) _predefined._Nil))))) (Control.Monad.liftM2 (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) TypeDef.Type TypeParse.ident_18 (Control.Applicative.many (<{Control.Applicative.Alternative;}> <{Yard.<|>_15}> Yard.empty_16 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) (TypeParse.argtype_17 unqvar_1_0)))) (Control.Monad.liftM3 (<{Control.Monad.Monad;}> Yard.bind_14 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) TypeDef.Forall (<{Control.Applicative.<*}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (<{Control.Applicative.*>}> (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11)) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TUniversalQuantifier) (Control.Applicative.some (<{Control.Applicative.Alternative;}> <{Yard.<|>_15}> Yard.empty_16 (<{Control.Applicative.Applicative;}> <{Yard.<*>_12}> Yard.pure_13 (<{Data.Functor.Functor;}> Yard.fmap_11))) (TypeParse.argtype_17 unqvar_1_0))) (Yard.item (<{StdClass.Eq;}> (<{StdOverloaded.==;}> <{TypeParse.==_22}>)) TypeParse.TColon)) TypeParse.type (Yard.pure_13 _predefined._Nil))) (TypeParse.argtype_17 unqvar_1_0)
TypeParse.parseType !cs_0 = let mbTokens_1_0 = TypeParse.tokenize cs_0 in case (Data.Maybe.isNothing mbTokens_1_0) (True -> Data.Maybe.Nothing) (False -> <{TypeParse._c;130;3_106}> (Yard.runParser TypeParse.type (Data.Maybe.fromJust mbTokens_1_0))) 
<{TypeParse._c;130;3_106}> !_x_0 = case _x_0 (_Tuple2 _x_1_0 _x_1_1 -> case _x_1_0 (Data.Either.Right t_2_0 -> case _x_1_1 (_predefined._Nil -> Data.Maybe.Just t_2_0) ) ) (_ -> Data.Maybe.Nothing)
<{TypeParse.TD;Token}> _x_0::B = _predefined._Nil

:: TypeParse.Token = TypeParse.TIdent a1 | TypeParse.TVar a1 | TypeParse.TArrow | TypeParse.TComma | TypeParse.TUnique | TypeParse.TAnonymous | TypeParse.TUnboxed | TypeParse.TStrict | TypeParse.TColon | TypeParse.TUniversalQuantifier | TypeParse.TParenOpen | TypeParse.TParenClose | TypeParse.TBrackOpen | TypeParse.TBrackClose | TypeParse.TBraceOpen | TypeParse.TBraceClose

|| Converted Records
:: <{TypeParse.gEq_s;}> = {!TypeParse.gEq_s}

:: <{TypeParse.gEq_ss;}> = {!TypeParse.gEq_ss}

:: <{TypeParse.gEq_sss;}> = {!TypeParse.gEq_sss}

:: <{TypeParse.gEq_ssss;}> = {!TypeParse.gEq_ssss}

:: <{TypeParse.gEq_sssss;}> = {!TypeParse.gEq_sssss}

:: <{TypeParse.gEq_ssssss;}> = {!TypeParse.gEq_ssssss}

:: <{TypeParse.gEq_sssssss;}> = {!TypeParse.gEq_sssssss}

:: <{TypeParse.gEq_ssssssss;}> = {!TypeParse.gEq_ssssssss}

:: <{TypeParse.gEq_sssssssss;}> = {!TypeParse.gEq_sssssssss}

:: <{TypeParse.bimap_s;}> = {TypeParse.bimap_s}

:: <{TypeParse.bimap_ss;}> = {TypeParse.bimap_ss}

:: <{TypeParse.bimap_sss;}> = {TypeParse.bimap_sss}

