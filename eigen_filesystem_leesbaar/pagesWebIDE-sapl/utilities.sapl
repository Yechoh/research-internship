|| ?module? utilities


<{utilities.StringToCharList`}> !string_0 !_x_1::I !index_2::I = case _x_1 (0 -> _predefined._Nil) (_ -> _predefined._Cons (_SystemArray.select_19 string_0 index_2) (<{utilities.StringToCharList`}> string_0 (<{StdInt.-_7}> _x_1 StdInt.one_11) (<{StdInt.+_6}> index_2 StdInt.one_11)))
utilities.stringToCharList !string_0 = <{utilities.StringToCharList`}> string_0 (_SystemArray.size_20 string_0) 0
utilities.charListToString !_x_0 = case _x_0 (_predefined._Cons hd_1_0 tl_1_1 -> <{StdString.+++_11}> (StdString.toString_6 hd_1_0) (utilities.charListToString tl_1_1)) (_predefined._Nil -> "") 
utilities.fill_string_25 !n_0::I !_x_1 !string_2 = case _x_1 (_predefined._Cons char_1_0 rest_1_1 -> utilities.fill_string_25 (<{StdInt.-_7}> n_0 1) rest_1_1 (_SystemArray.update_21 string_2 n_0 char_1_0)) (_predefined._Nil -> case n_0 (-1 -> string_2) ) 
utilities.revCharListToString !max_index_0::I !l_1 = utilities.fill_string_25 max_index_0 l_1 (_SystemArray.createArray_17 (<{StdInt.+_6}> max_index_0 1) '\0')
utilities.skipUnderscores::C !i_0::I !size_1::I !s_2 = case (<{StdInt.<_17}> i_0 size_1) (True -> let !c_2_0::C = _SystemArray.select_19 s_2 i_0 in case (<{StdChar.==_18}> c_2_0 '_') (True -> utilities.skipUnderscores (<{StdInt.+_6}> i_0 1) size_1 s_2) (False -> c_2_0) ) (False -> '_') 
utilities.isUpperCaseName::B !id_0 = let !c_1_0::C = utilities.skipUnderscores 0 (_SystemArray.size_20 id_0) id_0 in case (StdBool.not (<{StdChar.<_19}> c_1_0 'A')) (True -> StdBool.not (<{StdChar.<_19}> 'Z' c_1_0)) (False -> False) 
utilities.isLowerCaseName::B !id_0 = let !c_1_0::C = utilities.skipUnderscores 0 (_SystemArray.size_20 id_0) id_0 in case (StdBool.not (<{StdChar.<_19}> c_1_0 'a')) (True -> StdBool.not (<{StdChar.<_19}> 'z' c_1_0)) (False -> False) 
utilities.isSpecialChar::B !_x_0::C = case _x_0 ('~' -> True) ('@' -> True) ('#' -> True) ('$' -> True) ('%' -> True) ('^' -> True) ('?' -> True) ('!' -> True) ('+' -> True) ('-' -> True) ('*' -> True) ('<' -> True) ('>' -> True) ('\\' -> True) ('/' -> True) ('|' -> True) ('&' -> True) ('=' -> True) (':' -> True) ('.' -> True) (_ -> False)
utilities.isFunnyIdName::B !id_0 = utilities.isSpecialChar (_SystemArray.select_19 id_0 0)
utilities.isNotEmpty::B !_x_0 = case _x_0 (_predefined._Nil -> False) (_ -> True)
utilities.app2St !_x_0 !_x_1 !s_2 = case _x_0 (_Tuple2 f_1_0 g_1_1 -> case _x_1 (_Tuple2 x_2_0 y_2_1 -> let _x_3_0 = f_1_0 x_2_0 s_2, _x_3_1 = g_1_1 y_2_1 (select _x_3_0::_Tuple2 1) in <{_Tuple2!3}> (_Tuple2 (select _x_3_0::_Tuple2 0) (select _x_3_1::_Tuple2 0)) (select _x_3_1::_Tuple2 1)) ) 
utilities.mapAppendSt !f_0 !_x_1 !tail_2 !s_3 = case _x_1 (_predefined._Cons x_1_0 xs_1_1 -> let _x_2_0 = f_0 x_1_0 s_3, _x_2_1 = utilities.mapAppendSt f_0 xs_1_1 tail_2 (select _x_2_0::_Tuple2 1) in <{_Tuple2!3}> (_predefined._Cons (select _x_2_0::_Tuple2 0) (select _x_2_1::_Tuple2 0)) (select _x_2_1::_Tuple2 1)) (_predefined._Nil -> <{_Tuple2!3}> tail_2 s_3) 
utilities.strictMap !f_0 !_x_1 = case _x_1 (_predefined._Cons x_1_0 xs_1_1 -> let !head_2_0 = f_0 x_1_0, !tail_2_1 = utilities.strictMap f_0 xs_1_1 in _predefined._Cons head_2_0 tail_2_1) (_ -> _predefined._Nil)
utilities.strictMapAppend !f_0 !_x_1 !tail_2 = case _x_1 (_predefined._Cons x_1_0 xs_1_1 -> let !x_2_0 = f_0 x_1_0, !xs_2_1 = utilities.strictMapAppend f_0 xs_1_1 tail_2 in _predefined._Cons x_2_0 xs_2_1) (_predefined._Nil -> tail_2) 
utilities.mapAppend !f_0 !_x_1 !tail_2 = case _x_1 (_predefined._Cons x_1_0 xs_1_1 -> _predefined._Cons (f_0 x_1_0) (utilities.mapAppend f_0 xs_1_1 tail_2)) (_predefined._Nil -> tail_2) 
utilities.eqMerge !_vEq_0 !_x_1 !y_2 = case _x_1 (_predefined._Cons a_1_0 x_1_1 -> case (StdList.isMember _vEq_0 a_1_0 y_2) (True -> utilities.eqMerge _vEq_0 x_1_1 y_2) (False -> _predefined._Cons a_1_0 (utilities.eqMerge _vEq_0 x_1_1 y_2)) ) (_ -> y_2)
utilities.optCons !_x_0 !l_1 = case _x_0 (general.No -> <{_Tuple2!3}> l_1 0) (general.Yes x_1_0 -> <{_Tuple2!3}> (_predefined._Cons x_1_0 l_1) 0) 
utilities.revAppend !_x_0 !acc_1 = case _x_0 (_predefined._Nil -> acc_1) (_predefined._Cons x_1_0 xs_1_1 -> utilities.revAppend xs_1_1 (_predefined._Cons x_1_0 acc_1)) 
utilities.revMap !f_0 !_x_1 !acc_2 = case _x_1 (_predefined._Nil -> acc_2) (_predefined._Cons x_1_0 xs_1_1 -> utilities.revMap f_0 xs_1_1 (_predefined._Cons (f_0 x_1_0) acc_2)) 
utilities.accumulate_elements_26 !_x_0 accu_1 = case _x_0 (utilities.Empty -> accu_1) (utilities.Single element_1_0 -> _predefined._Cons element_1_0 accu_1) (utilities.Pair bag1_1_0 bag2_1_1 -> utilities.accumulate_elements_26 bag1_1_0 (utilities.accumulate_elements_26 bag2_1_1 accu_1)) 
utilities.uniqueBagToList !bag_0 = utilities.accumulate_elements_26 bag_0 _predefined._Nil
utilities.accumulate_elements_27 !_x_0 accu_1 = case _x_0 (utilities.Empty -> accu_1) (utilities.Single element_1_0 -> _predefined._Cons element_1_0 accu_1) (utilities.Pair bag1_1_0 bag2_1_1 -> utilities.accumulate_elements_27 bag1_1_0 (utilities.accumulate_elements_27 bag2_1_1 accu_1)) 
utilities.bagToList !bag_0 = utilities.accumulate_elements_27 bag_0 _predefined._Nil
utilities.isEmptyBag::B !_x_0 = case _x_0 (utilities.Empty -> True) (_ -> False)
utilities.fold_st_72 op_0 !_x_1 st_2 = case _x_1 (_predefined._Nil -> st_2) (_predefined._Cons a_1_0 x_1_1 -> utilities.fold_st_72 op_0 x_1_1 (op_0 a_1_0 st_2)) 
utilities.push_on_dep_stack_30 !node_index_0::I !ps_1 = case ps_1 (utilities._PartitioningState ps_marks_1_0 ps_next_num_1_1 ps_groups_1_2 ps_deps_1_3 -> update ps_1::utilities._PartitioningState [0:_SystemArray.update_13 ps_marks_1_0 node_index_0 ps_next_num_1_1,1:<{StdInt.+_6}> ps_next_num_1_1 StdInt.one_11,3:_predefined._Cons node_index_0 ps_deps_1_3]) 
utilities.close_group_33 !node_index_0::I !_x_1 !marks_2 !group_3 !pi_4 = case _x_1 (_predefined._Cons d_1_0 ds_1_1 -> case (<{StdInt.==_16}> d_1_0 node_index_0) (True -> <{_Tuple3!7}> ds_1_1 (_SystemArray.update_13 marks_2 d_1_0 (select pi_4::utilities._DAG 0)) (_predefined._Cons d_1_0 group_3)) (False -> utilities.close_group_33 node_index_0 ds_1_1 (_SystemArray.update_13 marks_2 d_1_0 (select pi_4::utilities._DAG 0)) (_predefined._Cons d_1_0 group_3) pi_4) ) 
utilities.try_to_close_group_32 !node_index_0::I !next_num_1::I !min_dep_2::I !pi_3 !ps_4 = case ps_4 (utilities._PartitioningState ps_marks_1_0 ps_next_num_1_1 ps_groups_1_2 ps_deps_1_3 -> case (StdBool.not (<{StdInt.<_17}> min_dep_2 next_num_1)) (True -> let _x_3_0 = utilities.close_group_33 node_index_0 ps_deps_1_3 ps_marks_1_0 _predefined._Nil pi_3 in <{_Tuple2!3}> (select pi_3::utilities._DAG 0) (update ps_4::utilities._PartitioningState [0:select _x_3_0::_Tuple3 1,2:_predefined._Cons (select _x_3_0::_Tuple3 2) ps_groups_1_2,3:select _x_3_0::_Tuple3 0])) (False -> <{_Tuple2!3}> min_dep_2 ps_4) ) 
utilities.visit_children_31 !_x_0 !min_dep_1::I !pi_2 !ps_3 = case _x_0 (_predefined._Cons child_1_0 children_1_1 -> case ps_3 (utilities._PartitioningState ps_marks_2_0 ps_next_num_2_1 ps_groups_2_2 ps_deps_2_3 -> let !mark_3_0::I = _SystemArray.select_11 ps_marks_2_0 child_1_0 in case (<{StdInt.==_16}> mark_3_0 -1) (True -> let _x_5_0::I = utilities.partitionate_unvisited_node_29 child_1_0 pi_2 ps_3, mark_5_1 = select _x_5_0::_Tuple2 0 in utilities.visit_children_31 children_1_1 (<{utilities._c;48;16_74}> (<{StdInt.<_17}> min_dep_1 mark_5_1) min_dep_1 mark_5_1) pi_2 (select _x_5_0::_Tuple2 1)) (False -> utilities.visit_children_31 children_1_1 (<{utilities._c;48;16_75}> (<{StdInt.<_17}> min_dep_1 mark_3_0) min_dep_1 mark_3_0) pi_2 ps_3) ) ) (_predefined._Nil -> <{_Tuple2!3}> min_dep_1 ps_3) 
utilities.partitionate_unvisited_node_29 !node_index_0::I !pi_1 !ps_2 = case ps_2 (utilities._PartitioningState ps_marks_1_0 ps_next_num_1_1 ps_groups_1_2 ps_deps_1_3 -> let _x_2_0 = utilities.visit_children_31 (select pi_1::utilities._DAG 1 node_index_0) (select pi_1::utilities._DAG 0) pi_1 (utilities.push_on_dep_stack_30 node_index_0 ps_2) in utilities.try_to_close_group_32 node_index_0 ps_next_num_1_1 (select _x_2_0::_Tuple2 0) pi_1 (select _x_2_0::_Tuple2 1)) 
<{utilities._c;48;16_75}>::I !_x_0::B min_dep_1::I mark_2::I = case _x_0 (True -> min_dep_1) (_ -> mark_2)
<{utilities._c;48;16_74}>::I !_x_0::B min_dep_1::I mark_2::I = case _x_0 (True -> min_dep_1) (_ -> mark_2)
utilities.partitionate_node_28 !pi_0 !node_index_1::I !ps_2 = case ps_2 (utilities._PartitioningState ps_marks_1_0 ps_next_num_1_1 ps_groups_1_2 ps_deps_1_3 -> case (<{StdInt.==_16}> (_SystemArray.select_11 ps_marks_1_0 node_index_1) -1) (True -> select (utilities.partitionate_unvisited_node_29 node_index_1 pi_0 ps_2)::_Tuple2 1) (False -> ps_2) ) 
utilities.fold_st_73 pi_0 !_x_1 !st_2 = case _x_1 (_predefined._Nil -> st_2) (_predefined._Cons a_1_0 x_1_1 -> utilities.fold_st_73 pi_0 x_1_1 (utilities.partitionate_node_28 pi_0 a_1_0 st_2)) 
utilities.partitionateDAG !pi_0 !roots_1 = case pi_0 (utilities._DAG dag_nr_of_nodes_1_0 dag_get_children_1_1 -> select (utilities.fold_st_73 pi_0 roots_1 (utilities._PartitioningState (_SystemArray.createArray_9 dag_nr_of_nodes_1_0 -1) 0 _predefined._Nil _predefined._Nil))::utilities._PartitioningState 2) 
<{utilities.TD;Bag}> _x_0::B = _predefined._Nil
<{utilities.TD;DAG}> _x_0::B = _predefined._Nil
<{utilities.TD;PartitioningState}> _x_0::B = _predefined._Nil

:: utilities.Bag = utilities.Empty | utilities.Single !a1 | utilities.Pair !a1 !a2

|| Converted Records
:: utilities._DAG = {!utilities.dag_nr_of_nodes::I, !utilities.dag_get_children}

:: utilities._PartitioningState = {!utilities.ps_marks, !utilities.ps_next_num::I, !utilities.ps_groups, !utilities.ps_deps}

