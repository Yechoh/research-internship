|| ?module? Data.Set


Data.Set.member::B !<{_v<_0}> !<{_v==_1}> !x_2 !_x_3 = case _x_3 (Data.Set.Tip -> False) (Data.Set.Bin _x_1_0 y_1_1 l_1_2 r_1_3 -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 x_2 y_1_1) (True -> Data.Set.member <{_v<_0}> <{_v==_1}> x_2 l_1_2) (False -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 y_1_1 x_2) (True -> Data.Set.member <{_v<_0}> <{_v==_1}> x_2 r_1_3) (False -> True) ) ) 
Data.Set.singleton !x_0 = Data.Set.Bin 1 x_0 Data.Set.Tip Data.Set.Tip
Data.Set.balanceL !x_0 !l_1 !r_2 = <{Data.Set._c;543;18_117}> r_2 l_1 x_0
<{Data.Set._c;543;18_117}> !r_0 !l_1 !x_2 = case r_0 (Data.Set.Tip -> <{Data.Set._c;544;10_112}> l_1 x_2) (Data.Set.Bin rs_1_0 _x_1_1 _x_1_2 _x_1_3 -> <{Data.Set._c;553;21_116}> l_1 rs_1_0 x_2 r_0) 
<{Data.Set._c;553;21_116}> !l_0 !rs_1::I !x_2 !r_3 = case l_0 (Data.Set.Tip -> Data.Set.Bin (<{StdInt.+_6}> 1 rs_1) x_2 Data.Set.Tip r_3) (Data.Set.Bin ls_1_0 lx_1_1 ll_1_2 lr_1_3 -> case (<{StdInt.<_17}> (<{StdInt.*_9}> 4 rs_1) ls_1_0) (True -> <{Data.Set._c;557;35_115}> (_Tuple2 ll_1_2 lr_1_3) ls_1_0 rs_1 lx_1_1 ll_1_2 x_2 lr_1_3 r_3) (False -> Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> 1 ls_1_0) rs_1) x_2 l_0 r_3) ) 
<{Data.Set._c;557;35_115}> !_x_0 !ls_1::I !rs_2::I !lx_3 !ll_4 !x_5 lr_6 !r_7 = case _x_0 (_Tuple2 _x_1_0 _x_1_1 -> case _x_1_0 (Data.Set.Bin lls_2_0 _x_2_1 _x_2_2 _x_2_3 -> case _x_1_1 (Data.Set.Bin lrs_3_0 lrx_3_1 lrl_3_2 lrr_3_3 -> case (<{StdInt.<_17}> lrs_3_0 (<{StdInt.*_9}> 2 lls_2_0)) (True -> Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> 1 ls_1) rs_2) lx_3 ll_4 (Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> 1 rs_2) lrs_3_0) x_5 lr_6 r_7)) (False -> Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> 1 ls_1) rs_2) lrx_3_1 (Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> 1 lls_2_0) (<{Data.Set._c;61;12_113}> lrl_3_2)) lx_3 ll_4 lrl_3_2) (Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> 1 rs_2) (<{Data.Set._c;61;12_114}> lrr_3_3)) x_5 lrr_3_3 r_7)) ) ) (_ -> StdMisc.abort "Failure in Data.Map.balanceL")) 
<{Data.Set._c;61;12_114}>::I !lrr_0 = case lrr_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_113}>::I !lrl_0 = case lrl_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;544;10_112}> !l_0 !x_1 = case l_0 (Data.Set.Tip -> Data.Set.Bin 1 x_1 Data.Set.Tip Data.Set.Tip) (Data.Set.Bin _x_1_0 _x_1_1 _x_1_2 _x_1_3 -> case _x_1_2 (Data.Set.Tip -> case _x_1_3 (Data.Set.Tip -> Data.Set.Bin 2 x_1 l_0 Data.Set.Tip) (Data.Set.Bin _x_3_0 lrx_3_1 _x_3_2 _x_3_3 -> Data.Set.Bin 3 lrx_3_1 (Data.Set.Bin 1 _x_1_1 Data.Set.Tip Data.Set.Tip) (Data.Set.Bin 1 x_1 Data.Set.Tip Data.Set.Tip)) ) (Data.Set.Bin _x_2_0 _x_2_1 _x_2_2 _x_2_3 -> case _x_1_3 (Data.Set.Tip -> Data.Set.Bin 3 _x_1_1 _x_1_2 (Data.Set.Bin 1 x_1 Data.Set.Tip Data.Set.Tip)) (Data.Set.Bin lrs_3_0 lrx_3_1 lrl_3_2 lrr_3_3 -> case (<{StdInt.<_17}> lrs_3_0 (<{StdInt.*_9}> 2 _x_2_0)) (True -> Data.Set.Bin (<{StdInt.+_6}> 1 _x_1_0) _x_1_1 _x_1_2 (Data.Set.Bin (<{StdInt.+_6}> 1 lrs_3_0) x_1 _x_1_3 Data.Set.Tip)) (False -> Data.Set.Bin (<{StdInt.+_6}> 1 _x_1_0) lrx_3_1 (Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> 1 _x_2_0) (<{Data.Set._c;61;12_110}> lrl_3_2)) _x_1_1 _x_1_2 lrl_3_2) (Data.Set.Bin (<{StdInt.+_6}> 1 (<{Data.Set._c;61;12_111}> lrr_3_3)) x_1 lrr_3_3 Data.Set.Tip)) ) ) ) 
<{Data.Set._c;61;12_111}>::I !lrr_0 = case lrr_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_110}>::I !lrl_0 = case lrl_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
Data.Set.insertMin !x_0 !_x_1 = case _x_1 (Data.Set.Tip -> Data.Set.singleton x_0) (Data.Set.Bin _x_1_0 y_1_1 l_1_2 r_1_3 -> Data.Set.balanceL y_1_1 (Data.Set.insertMin x_0 l_1_2) r_1_3) 
Data.Set.balanceR !x_0 !l_1 !r_2 = <{Data.Set._c;567;18_125}> l_1 r_2 x_0
<{Data.Set._c;567;18_125}> !l_0 !r_1 !x_2 = case l_0 (Data.Set.Tip -> <{Data.Set._c;568;10_120}> r_1 x_2) (Data.Set.Bin ls_1_0 _x_1_1 _x_1_2 _x_1_3 -> <{Data.Set._c;577;21_124}> r_1 ls_1_0 x_2 l_0) 
<{Data.Set._c;577;21_124}> !r_0 !ls_1::I !x_2 !l_3 = case r_0 (Data.Set.Tip -> Data.Set.Bin (<{StdInt.+_6}> 1 ls_1) x_2 l_3 Data.Set.Tip) (Data.Set.Bin rs_1_0 rx_1_1 rl_1_2 rr_1_3 -> case (<{StdInt.<_17}> (<{StdInt.*_9}> 4 ls_1) rs_1_0) (True -> <{Data.Set._c;581;35_123}> (_Tuple2 rl_1_2 rr_1_3) ls_1 rs_1_0 rx_1_1 x_2 l_3 rl_1_2 rr_1_3) (False -> Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> 1 ls_1) rs_1_0) x_2 l_3 r_0) ) 
<{Data.Set._c;581;35_123}> !_x_0 !ls_1::I !rs_2::I !rx_3 !x_4 !l_5 rl_6 !rr_7 = case _x_0 (_Tuple2 _x_1_0 _x_1_1 -> case _x_1_0 (Data.Set.Bin rls_2_0 rlx_2_1 rll_2_2 rlr_2_3 -> case _x_1_1 (Data.Set.Bin rrs_3_0 _x_3_1 _x_3_2 _x_3_3 -> case (<{StdInt.<_17}> rls_2_0 (<{StdInt.*_9}> 2 rrs_3_0)) (True -> Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> 1 ls_1) rs_2) rx_3 (Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> 1 ls_1) rls_2_0) x_4 l_5 rl_6) rr_7) (False -> Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> 1 ls_1) rs_2) rlx_2_1 (Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> 1 ls_1) (<{Data.Set._c;61;12_121}> rll_2_2)) x_4 l_5 rll_2_2) (Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> 1 rrs_3_0) (<{Data.Set._c;61;12_122}> rlr_2_3)) rx_3 rlr_2_3 rr_7)) ) ) (_ -> StdMisc.abort "Failure in Data.Map.balanceR")) 
<{Data.Set._c;61;12_122}>::I !rlr_0 = case rlr_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_121}>::I !rll_0 = case rll_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;568;10_120}> !r_0 !x_1 = case r_0 (Data.Set.Tip -> Data.Set.Bin 1 x_1 Data.Set.Tip Data.Set.Tip) (Data.Set.Bin _x_1_0 _x_1_1 _x_1_2 _x_1_3 -> case _x_1_2 (Data.Set.Tip -> case _x_1_3 (Data.Set.Tip -> Data.Set.Bin 2 x_1 Data.Set.Tip r_0) (Data.Set.Bin _x_3_0 _x_3_1 _x_3_2 _x_3_3 -> Data.Set.Bin 3 _x_1_1 (Data.Set.Bin 1 x_1 Data.Set.Tip Data.Set.Tip) _x_1_3) ) (Data.Set.Bin _x_2_0 rlx_2_1 _x_2_2 _x_2_3 -> case _x_1_3 (Data.Set.Tip -> Data.Set.Bin 3 rlx_2_1 (Data.Set.Bin 1 x_1 Data.Set.Tip Data.Set.Tip) (Data.Set.Bin 1 _x_1_1 Data.Set.Tip Data.Set.Tip)) (Data.Set.Bin rrs_3_0 _x_3_1 _x_3_2 _x_3_3 -> case (<{StdInt.<_17}> _x_2_0 (<{StdInt.*_9}> 2 rrs_3_0)) (True -> Data.Set.Bin (<{StdInt.+_6}> 1 _x_1_0) _x_1_1 (Data.Set.Bin (<{StdInt.+_6}> 1 _x_2_0) x_1 Data.Set.Tip _x_1_2) _x_1_3) (False -> Data.Set.Bin (<{StdInt.+_6}> 1 _x_1_0) rlx_2_1 (Data.Set.Bin (<{StdInt.+_6}> 1 (<{Data.Set._c;61;12_118}> _x_2_2)) x_1 Data.Set.Tip _x_2_2) (Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> 1 rrs_3_0) (<{Data.Set._c;61;12_119}> _x_2_3)) _x_1_1 _x_2_3 _x_1_3)) ) ) ) 
<{Data.Set._c;61;12_119}>::I !_x_0 = case _x_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_118}>::I !_x_0 = case _x_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
Data.Set.insertMax !x_0 !_x_1 = case _x_1 (Data.Set.Tip -> Data.Set.singleton x_0) (Data.Set.Bin _x_1_0 y_1_1 l_1_2 r_1_3 -> Data.Set.balanceR y_1_1 l_1_2 (Data.Set.insertMax x_0 r_1_3)) 
Data.Set.link !x_0 !_x_1 !r_2 = case _x_1 (Data.Set.Tip -> Data.Set.insertMin x_0 r_2) (_ -> case r_2 (Data.Set.Tip -> Data.Set.insertMax x_0 _x_1) (Data.Set.Bin sizeR_1_0 z_1_1 lz_1_2 rz_1_3 -> case _x_1 (Data.Set.Bin sizeL_2_0 y_2_1 ly_2_2 ry_2_3 -> case (<{StdInt.<_17}> (<{StdInt.*_9}> 4 sizeL_2_0) sizeR_1_0) (True -> Data.Set.balanceL z_1_1 (Data.Set.link x_0 _x_1 lz_1_2) rz_1_3) (False -> case (<{StdInt.<_17}> (<{StdInt.*_9}> 4 sizeR_1_0) sizeL_2_0) (True -> Data.Set.balanceR y_2_1 ly_2_2 (Data.Set.link x_0 ry_2_3 r_2)) (False -> Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> (<{Data.Set._c;61;12_126}> _x_1) (<{Data.Set._c;61;12_127}> r_2)) 1) x_0 _x_1 r_2) ) ) ) )
<{Data.Set._c;61;12_127}>::I !r_0 = case r_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_126}>::I !_x_0 = case _x_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
Data.Set.splitMember !<{_v<_0}> !<{_v==_1}> !_x_2 !_x_3 = case _x_3 (Data.Set.Tip -> <{_Tuple3!7}> Data.Set.Tip False Data.Set.Tip) (Data.Set.Bin _x_1_0 y_1_1 l_1_2 r_1_3 -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 _x_2 y_1_1) (True -> let !_x_3_0 = Data.Set.splitMember <{_v<_0}> <{_v==_1}> _x_2 l_1_2 in <{_Tuple3!7}> (select _x_3_0::_Tuple3 0) (select _x_3_0::_Tuple3 1) (Data.Set.link y_1_1 (select _x_3_0::_Tuple3 2) r_1_3)) (False -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 y_1_1 _x_2) (True -> let !_x_4_0 = Data.Set.splitMember <{_v<_0}> <{_v==_1}> _x_2 r_1_3 in <{_Tuple3!7}> (Data.Set.link y_1_1 l_1_2 (select _x_4_0::_Tuple3 0)) (select _x_4_0::_Tuple3 1) (select _x_4_0::_Tuple3 2)) (False -> <{_Tuple3!7}> l_1_2 True r_1_3) ) ) 
Data.Set.isSubsetOfX::B !<{_v<_0}> !<{_v==_1}> !_x_2 !_x_3 = case _x_2 (Data.Set.Tip -> True) (_ -> case _x_3 (Data.Set.Tip -> False) (_ -> case _x_2 (Data.Set.Bin _x_1_0 x_1_1 l_1_2 r_1_3 -> let !_x_2_0 = Data.Set.splitMember <{_v<_0}> <{_v==_1}> x_1_1 _x_3 in case (select _x_2_0::_Tuple3 1) (True -> case (Data.Set.isSubsetOfX <{_v<_0}> <{_v==_1}> l_1_2 (select _x_2_0::_Tuple3 0)) (True -> Data.Set.isSubsetOfX <{_v<_0}> <{_v==_1}> r_1_3 (select _x_2_0::_Tuple3 2)) (False -> False) ) (False -> False) ) ))
Data.Set.newSet = Data.Set.Tip
Data.Set.insert !<{_v<_0}> !<{_v==_1}> !x_2 !_x_3 = case _x_3 (Data.Set.Tip -> Data.Set.singleton x_2) (Data.Set.Bin sz_1_0 y_1_1 l_1_2 r_1_3 -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 x_2 y_1_1) (True -> Data.Set.balanceL y_1_1 (Data.Set.insert <{_v<_0}> <{_v==_1}> x_2 l_1_2) r_1_3) (False -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 y_1_1 x_2) (True -> Data.Set.balanceR y_1_1 l_1_2 (Data.Set.insert <{_v<_0}> <{_v==_1}> x_2 r_1_3)) (False -> Data.Set.Bin sz_1_0 x_2 l_1_2 r_1_3) ) ) 
Data.Set.deleteFindMax !_x_0 = case _x_0 (Data.Set.Bin _x_1_0 x_1_1 l_1_2 _x_1_3 -> case _x_1_3 (Data.Set.Tip -> <{_Tuple2!3}> x_1_1 l_1_2) (_ -> let !_x_2_0 = Data.Set.deleteFindMax _x_1_3 in <{_Tuple2!3}> (select _x_2_0::_Tuple2 0) (Data.Set.balanceL x_1_1 l_1_2 (select _x_2_0::_Tuple2 1)))) (Data.Set.Tip -> <{_Tuple2!3}> (StdMisc.abort "Set.deleteFindMax: can not return the maximal element of an empty set") Data.Set.Tip) 
Data.Set.deleteFindMin !_x_0 = case _x_0 (Data.Set.Bin _x_1_0 x_1_1 _x_1_2 r_1_3 -> case _x_1_2 (Data.Set.Tip -> <{_Tuple2!3}> x_1_1 r_1_3) (_ -> let !_x_2_0 = Data.Set.deleteFindMin _x_1_2 in <{_Tuple2!3}> (select _x_2_0::_Tuple2 0) (Data.Set.balanceR x_1_1 (select _x_2_0::_Tuple2 1) r_1_3))) (Data.Set.Tip -> <{_Tuple2!3}> (StdMisc.abort "Set.deleteFindMin: can not return the minimal element of an empty set") Data.Set.Tip) 
Data.Set.glue !_x_0 !r_1 = case _x_0 (Data.Set.Tip -> r_1) (_ -> case r_1 (Data.Set.Tip -> _x_0) (_ -> case (<{StdInt.<_17}> (<{Data.Set._c;61;12_128}> r_1) (<{Data.Set._c;61;12_129}> _x_0)) (True -> let !_x_2_0 = Data.Set.deleteFindMax _x_0 in Data.Set.balanceR (select _x_2_0::_Tuple2 0) (select _x_2_0::_Tuple2 1) r_1) (False -> let !_x_2_0 = Data.Set.deleteFindMin r_1 in Data.Set.balanceL (select _x_2_0::_Tuple2 0) _x_0 (select _x_2_0::_Tuple2 1)) ))
<{Data.Set._c;61;12_129}>::I !_x_0 = case _x_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_128}>::I !r_0 = case r_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
Data.Set.delete !<{_v<_0}> !<{_v==_1}> !x_2 !_x_3 = case _x_3 (Data.Set.Tip -> Data.Set.Tip) (Data.Set.Bin _x_1_0 y_1_1 l_1_2 r_1_3 -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 x_2 y_1_1) (True -> Data.Set.balanceR y_1_1 (Data.Set.delete <{_v<_0}> <{_v==_1}> x_2 l_1_2) r_1_3) (False -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 y_1_1 x_2) (True -> Data.Set.balanceL y_1_1 l_1_2 (Data.Set.delete <{_v<_0}> <{_v==_1}> x_2 r_1_3)) (False -> Data.Set.glue l_1_2 r_1_3) ) ) 
Data.Set.findMin !_x_0 = case _x_0 (Data.Set.Bin _x_1_0 x_1_1 _x_1_2 _x_1_3 -> case _x_1_2 (Data.Set.Tip -> x_1_1) (_ -> Data.Set.findMin _x_1_2)) (Data.Set.Tip -> StdMisc.abort "Set.findMin: empty set has no minimal element") 
Data.Set.findMax !_x_0 = case _x_0 (Data.Set.Bin _x_1_0 x_1_1 _x_1_2 _x_1_3 -> case _x_1_3 (Data.Set.Tip -> x_1_1) (_ -> Data.Set.findMax _x_1_3)) (Data.Set.Tip -> StdMisc.abort "Set.findMax: empty set has no maximal element") 
Data.Set.deleteMin !_x_0 = case _x_0 (Data.Set.Bin _x_1_0 _x_1_1 _x_1_2 r_1_3 -> case _x_1_2 (Data.Set.Tip -> r_1_3) (_ -> Data.Set.balanceR _x_1_1 (Data.Set.deleteMin _x_1_2) r_1_3)) (Data.Set.Tip -> Data.Set.Tip) 
Data.Set.deleteMax !_x_0 = case _x_0 (Data.Set.Bin _x_1_0 _x_1_1 l_1_2 _x_1_3 -> case _x_1_3 (Data.Set.Tip -> l_1_2) (_ -> Data.Set.balanceL _x_1_1 l_1_2 (Data.Set.deleteMax _x_1_3))) (Data.Set.Tip -> Data.Set.Tip) 
Data.Set.minView !_x_0 = case _x_0 (Data.Set.Tip -> Data.Maybe.Nothing) (_ -> Data.Maybe.Just (Data.Set.deleteFindMin _x_0))
Data.Set.maxView !_x_0 = case _x_0 (Data.Set.Tip -> Data.Maybe.Nothing) (_ -> Data.Maybe.Just (Data.Set.deleteFindMax _x_0))
<{Data.Set.filter`_53}> !<{_v<_0}> _x_1 !_x_2 = case _x_2 (Data.Set.Tip -> Data.Set.Tip) (Data.Set.Bin _x_1_0 x_1_1 l_1_2 r_1_3 -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 x_1_1 _x_1) (True -> Data.Set.link x_1_1 l_1_2 (<{Data.Set.filter`_53}> <{_v<_0}> _x_1 r_1_3)) (False -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 _x_1 x_1_1) (True -> l_1_2) (False -> <{Data.Set.filter`_53}> <{_v<_0}> _x_1 l_1_2) ) ) 
Data.Set.filterLt !<{_v<_0}> !<{_v==_1}> !_x_2 !t_3 = case _x_2 (Data.Set.NothingS -> t_3) (Data.Set.JustS b_1_0 -> <{Data.Set.filter`_53}> <{_v<_0}> b_1_0 t_3) 
<{Data.Set.filter`_52}> !<{_v<_0}> _x_1 !_x_2 = case _x_2 (Data.Set.Tip -> Data.Set.Tip) (Data.Set.Bin _x_1_0 x_1_1 l_1_2 r_1_3 -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 _x_1 x_1_1) (True -> Data.Set.link x_1_1 (<{Data.Set.filter`_52}> <{_v<_0}> _x_1 l_1_2) r_1_3) (False -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 x_1_1 _x_1) (True -> r_1_3) (False -> <{Data.Set.filter`_52}> <{_v<_0}> _x_1 r_1_3) ) ) 
Data.Set.filterGt !<{_v<_0}> !<{_v==_1}> !_x_2 !t_3 = case _x_2 (Data.Set.NothingS -> t_3) (Data.Set.JustS b_1_0 -> <{Data.Set.filter`_52}> <{_v<_0}> b_1_0 t_3) 
Data.Set.insertR !<{_v<_0}> !<{_v==_1}> !x_2 !_x_3 = case _x_3 (Data.Set.Tip -> Data.Set.singleton x_2) (Data.Set.Bin _x_1_0 y_1_1 l_1_2 r_1_3 -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 x_2 y_1_1) (True -> Data.Set.balanceL y_1_1 (Data.Set.insertR <{_v<_0}> <{_v==_1}> x_2 l_1_2) r_1_3) (False -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 y_1_1 x_2) (True -> Data.Set.balanceR y_1_1 l_1_2 (Data.Set.insertR <{_v<_0}> <{_v==_1}> x_2 r_1_3)) (False -> _x_3) ) ) 
Data.Set.greater_49 !<{_v<_0}> lo_1 !_x_2 = case _x_2 (Data.Set.Bin _x_1_0 x_1_1 _x_1_2 r_1_3 -> case (StdBool.not (select <{_v<_0}>::<{StdOverloaded.<;}> 0 lo_1 x_1_1)) (True -> Data.Set.greater_49 <{_v<_0}> lo_1 r_1_3) ) (_ -> _x_2)
Data.Set.lesser_50 !<{_v<_0}> hi_1 !_x_2 = case _x_2 (Data.Set.Bin _x_1_0 x_1_1 l_1_2 _x_1_3 -> case (StdBool.not (select <{_v<_0}>::<{StdOverloaded.<;}> 0 x_1_1 hi_1)) (True -> Data.Set.lesser_50 <{_v<_0}> hi_1 l_1_2) ) (_ -> _x_2)
Data.Set.middle_51 !<{_v<_0}> lo_1 hi_2 !_x_3 = case _x_3 (Data.Set.Bin _x_1_0 x_1_1 _x_1_2 r_1_3 -> case (StdBool.not (select <{_v<_0}>::<{StdOverloaded.<;}> 0 lo_1 x_1_1)) (True -> Data.Set.middle_51 <{_v<_0}> lo_1 hi_2 r_1_3) (False -> case (StdBool.not (select <{_v<_0}>::<{StdOverloaded.<;}> 0 x_1_1 hi_2)) (True -> Data.Set.middle_51 <{_v<_0}> lo_1 hi_2 _x_1_2) ) ) (_ -> _x_3)
Data.Set.trim !<{_v<_0}> !<{_v==_1}> !_x_2 !_x_3 !t_4 = case _x_2 (Data.Set.NothingS -> case _x_3 (Data.Set.NothingS -> t_4) (Data.Set.JustS hx_2_0 -> Data.Set.lesser_50 <{_v<_0}> hx_2_0 t_4) ) (Data.Set.JustS lx_1_0 -> case _x_3 (Data.Set.NothingS -> Data.Set.greater_49 <{_v<_0}> lx_1_0 t_4) (Data.Set.JustS hx_2_0 -> Data.Set.middle_51 <{_v<_0}> lx_1_0 hx_2_0 t_4) ) 
Data.Set.hedgeUnion !<{_v<_0}> !<{_v==_1}> !_x_2 !_x_3 !t1_4 !_x_5 = case _x_5 (Data.Set.Tip -> t1_4) (Data.Set.Bin _x_1_0 x_1_1 l_1_2 r_1_3 -> case t1_4 (Data.Set.Tip -> Data.Set.link x_1_1 (Data.Set.filterGt <{_v<_0}> <{_v==_1}> _x_2 l_1_2) (Data.Set.filterLt <{_v<_0}> <{_v==_1}> _x_3 r_1_3)) (_ -> case l_1_2 (Data.Set.Tip -> case r_1_3 (Data.Set.Tip -> Data.Set.insertR <{_v<_0}> <{_v==_1}> x_1_1 t1_4) ) )) (_ -> case t1_4 (Data.Set.Bin _x_1_0 x_1_1 l_1_2 r_1_3 -> let bmi_2_0 = Data.Set.JustS x_1_1 in Data.Set.link x_1_1 (Data.Set.hedgeUnion <{_v<_0}> <{_v==_1}> _x_2 bmi_2_0 l_1_2 (Data.Set.trim <{_v<_0}> <{_v==_1}> _x_2 bmi_2_0 _x_5)) (Data.Set.hedgeUnion <{_v<_0}> <{_v==_1}> bmi_2_0 _x_3 r_1_3 (Data.Set.trim <{_v<_0}> <{_v==_1}> bmi_2_0 _x_3 _x_5))) )
Data.Set.union !<{_v<_0}> !<{_v==_1}> !_x_2 !t2_3 = case _x_2 (Data.Set.Tip -> t2_3) (_ -> case t2_3 (Data.Set.Tip -> _x_2) (_ -> Data.Set.hedgeUnion <{_v<_0}> <{_v==_1}> Data.Set.NothingS Data.Set.NothingS _x_2 t2_3))
Data.Set.merge !_x_0 !r_1 = case _x_0 (Data.Set.Tip -> r_1) (_ -> case r_1 (Data.Set.Tip -> _x_0) (Data.Set.Bin sizeR_1_0 y_1_1 ly_1_2 ry_1_3 -> case _x_0 (Data.Set.Bin sizeL_2_0 x_2_1 lx_2_2 rx_2_3 -> case (<{StdInt.<_17}> (<{StdInt.*_9}> 4 sizeL_2_0) sizeR_1_0) (True -> Data.Set.balanceL y_1_1 (Data.Set.merge _x_0 ly_1_2) ry_1_3) (False -> case (<{StdInt.<_17}> (<{StdInt.*_9}> 4 sizeR_1_0) sizeL_2_0) (True -> Data.Set.balanceR x_2_1 lx_2_2 (Data.Set.merge rx_2_3 r_1)) (False -> Data.Set.glue _x_0 r_1) ) ) ) )
Data.Set.hedgeDiff !<{_v<_0}> !<{_v==_1}> !_x_2 !_x_3 !_x_4 !_x_5 = case _x_4 (Data.Set.Tip -> Data.Set.Tip) (Data.Set.Bin _x_1_0 x_1_1 l_1_2 r_1_3 -> case _x_5 (Data.Set.Tip -> Data.Set.link x_1_1 (Data.Set.filterGt <{_v<_0}> <{_v==_1}> _x_2 l_1_2) (Data.Set.filterLt <{_v<_0}> <{_v==_1}> _x_3 r_1_3)) ) (_ -> case _x_5 (Data.Set.Bin _x_1_0 x_1_1 l_1_2 r_1_3 -> let bmi_2_0 = Data.Set.JustS x_1_1 in Data.Set.merge (Data.Set.hedgeDiff <{_v<_0}> <{_v==_1}> _x_2 bmi_2_0 (Data.Set.trim <{_v<_0}> <{_v==_1}> _x_2 bmi_2_0 _x_4) l_1_2) (Data.Set.hedgeDiff <{_v<_0}> <{_v==_1}> bmi_2_0 _x_3 (Data.Set.trim <{_v<_0}> <{_v==_1}> bmi_2_0 _x_3 _x_4) r_1_3)) )
Data.Set.difference !<{_v<_0}> !<{_v==_1}> !_x_2 !_x_3 = case _x_2 (Data.Set.Tip -> Data.Set.Tip) (_ -> case _x_3 (Data.Set.Tip -> _x_2) (_ -> Data.Set.hedgeDiff <{_v<_0}> <{_v==_1}> Data.Set.NothingS Data.Set.NothingS _x_2 _x_3))
Data.Set.hedgeInt !<{_v<_0}> !<{_v==_1}> !_x_2 !_x_3 !_x_4 !_x_5 = case _x_5 (Data.Set.Tip -> Data.Set.Tip) (_ -> case _x_4 (Data.Set.Tip -> Data.Set.Tip) (Data.Set.Bin _x_1_0 x_1_1 l_1_2 r_1_3 -> let !bmi_2_0 = Data.Set.JustS x_1_1, !<{l`_2_1}> = Data.Set.hedgeInt <{_v<_0}> <{_v==_1}> _x_2 bmi_2_0 l_1_2 (Data.Set.trim <{_v<_0}> <{_v==_1}> _x_2 bmi_2_0 _x_5), !<{r`_2_2}> = Data.Set.hedgeInt <{_v<_0}> <{_v==_1}> bmi_2_0 _x_3 r_1_3 (Data.Set.trim <{_v<_0}> <{_v==_1}> bmi_2_0 _x_3 _x_5) in case (Data.Set.member <{_v<_0}> <{_v==_1}> x_1_1 _x_5) (True -> Data.Set.link x_1_1 <{l`_2_1}> <{r`_2_2}>) (False -> Data.Set.merge <{l`_2_1}> <{r`_2_2}>) ) )
Data.Set.intersection !<{_v<_0}> !<{_v==_1}> !_x_2 !_x_3 = case _x_2 (Data.Set.Tip -> Data.Set.Tip) (_ -> case _x_3 (Data.Set.Tip -> Data.Set.Tip) (_ -> Data.Set.hedgeInt <{_v<_0}> <{_v==_1}> Data.Set.NothingS Data.Set.NothingS _x_2 _x_3))
Data.Set.foldl_59 op_0 r_1 !_x_2 = case _x_2 (_predefined._Nil -> r_1) (_predefined._Cons a_1_0 x_1_1 -> Data.Set.foldl_59 op_0 (op_0 r_1 a_1_0) x_1_1) 
Data.Set.foldl_108 <{_v<_0}> <{_v==_1}> !r_2 !_x_3 = case _x_3 (_predefined._Nil -> r_2) (_predefined._Cons a_1_0 x_1_1 -> Data.Set.foldl_108 <{_v<_0}> <{_v==_1}> (Data.Set.intersection <{_v<_0}> <{_v==_1}> r_2 a_1_0) x_1_1) 
Data.Set.intersections !<{_v<_0}> !<{_v==_1}> !_x_2 = case _x_2 (_predefined._Cons t_1_0 _x_1_1 -> case _x_1_1 (_predefined._Nil -> t_1_0) (_ -> Data.Set.foldl_108 <{_v<_0}> <{_v==_1}> t_1_0 _x_1_1)) 
Data.Set.filter !<{_v<_0}> !<{_v==_1}> !_x_2 !_x_3 = case _x_3 (Data.Set.Tip -> Data.Set.Tip) (Data.Set.Bin _x_1_0 x_1_1 l_1_2 r_1_3 -> case (_x_2 x_1_1) (True -> Data.Set.link x_1_1 (Data.Set.filter <{_v<_0}> <{_v==_1}> _x_2 l_1_2) (Data.Set.filter <{_v<_0}> <{_v==_1}> _x_2 r_1_3)) (False -> Data.Set.merge (Data.Set.filter <{_v<_0}> <{_v==_1}> _x_2 l_1_2) (Data.Set.filter <{_v<_0}> <{_v==_1}> _x_2 r_1_3)) ) 
Data.Set.partition !<{_v<_0}> !<{_v==_1}> !_x_2 !_x_3 = case _x_3 (Data.Set.Tip -> <{_Tuple2!3}> Data.Set.Tip Data.Set.Tip) (Data.Set.Bin _x_1_0 x_1_1 l_1_2 r_1_3 -> let !_x_2_0 = Data.Set.partition <{_v<_0}> <{_v==_1}> _x_2 l_1_2, !_x_2_1 = Data.Set.partition <{_v<_0}> <{_v==_1}> _x_2 r_1_3 in case (_x_2 x_1_1) (True -> <{_Tuple2!3}> (Data.Set.link x_1_1 (select _x_2_0::_Tuple2 0) (select _x_2_1::_Tuple2 0)) (Data.Set.merge (select _x_2_0::_Tuple2 1) (select _x_2_1::_Tuple2 1))) (False -> <{_Tuple2!3}> (Data.Set.merge (select _x_2_0::_Tuple2 0) (select _x_2_1::_Tuple2 0)) (Data.Set.link x_1_1 (select _x_2_0::_Tuple2 1) (select _x_2_1::_Tuple2 1))) ) 
Data.Set.split !<{_v<_0}> !<{_v==_1}> !_x_2 !_x_3 = case _x_3 (Data.Set.Tip -> <{_Tuple2!3}> Data.Set.Tip Data.Set.Tip) (Data.Set.Bin _x_1_0 y_1_1 l_1_2 r_1_3 -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 _x_2 y_1_1) (True -> let !_x_3_0 = Data.Set.split <{_v<_0}> <{_v==_1}> _x_2 l_1_2 in <{_Tuple2!3}> (select _x_3_0::_Tuple2 0) (Data.Set.link y_1_1 (select _x_3_0::_Tuple2 1) r_1_3)) (False -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 y_1_1 _x_2) (True -> let !_x_4_0 = Data.Set.split <{_v<_0}> <{_v==_1}> _x_2 r_1_3 in <{_Tuple2!3}> (Data.Set.link y_1_1 l_1_2 (select _x_4_0::_Tuple2 0)) (select _x_4_0::_Tuple2 1)) (False -> <{_Tuple2!3}> l_1_2 r_1_3) ) ) 
Data.Set.fold !_x_0 !z_1 !_x_2 = case _x_2 (Data.Set.Tip -> z_1) (Data.Set.Bin _x_1_0 x_1_1 l_1_2 r_1_3 -> Data.Set.fold _x_0 (_x_0 x_1_1 (Data.Set.fold _x_0 z_1 r_1_3)) l_1_2) 
Data.Set.foldl_60 op_0 r_1 !_x_2 = case _x_2 (_predefined._Nil -> r_1) (_predefined._Cons a_1_0 x_1_1 -> Data.Set.foldl_60 op_0 (op_0 r_1 a_1_0) x_1_1) 
Data.Set.ins_48 !<{_v<_0}> !<{_v==_1}> !t_2 !x_3 = Data.Set.insert <{_v<_0}> <{_v==_1}> x_3 t_2
Data.Set.foldl_109 <{_v<_0}> <{_v==_1}> !r_2 !_x_3 = case _x_3 (_predefined._Nil -> r_2) (_predefined._Cons a_1_0 x_1_1 -> Data.Set.foldl_109 <{_v<_0}> <{_v==_1}> (Data.Set.ins_48 <{_v<_0}> <{_v==_1}> r_2 a_1_0) x_1_1) 
Data.Set.fromList !<{_v<_0}> !<{_v==_1}> !xs_2 = Data.Set.foldl_109 <{_v<_0}> <{_v==_1}> Data.Set.newSet xs_2
Data.Set.mapSetMonotonic !_x_0 !_x_1 = case _x_1 (Data.Set.Tip -> Data.Set.Tip) (Data.Set.Bin n_1_0 x_1_1 l_1_2 r_1_3 -> Data.Set.Bin n_1_0 (_x_0 x_1_1) (Data.Set.mapSetMonotonic _x_0 l_1_2) (Data.Set.mapSetMonotonic _x_0 r_1_3)) 
Data.Set.singleL !x1_0 !t1_1 !_x_2 = case _x_2 (Data.Set.Bin _x_1_0 x2_1_1 t2_1_2 t3_1_3 -> let l_2_0 = Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> (<{Data.Set._c;61;12_130}> t1_1) (<{Data.Set._c;61;12_131}> t2_1_2)) 1) x1_0 t1_1 t2_1_2 in Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> (<{Data.Set._c;61;12_132}> l_2_0) (<{Data.Set._c;61;12_133}> t3_1_3)) 1) x2_1_1 l_2_0 t3_1_3) (Data.Set.Tip -> StdMisc.abort "singleL") 
<{Data.Set._c;61;12_133}>::I !t3_0 = case t3_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_132}>::I !l_0 = case l_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_131}>::I !t2_0 = case t2_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_130}>::I !t1_0 = case t1_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
Data.Set.doubleL !x1_0 !t1_1 !_x_2 = case _x_2 (Data.Set.Bin _x_1_0 x2_1_1 _x_1_2 t4_1_3 -> case _x_1_2 (Data.Set.Bin _x_2_0 x3_2_1 t2_2_2 t3_2_3 -> let l_3_0 = Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> (<{Data.Set._c;61;12_136}> t1_1) (<{Data.Set._c;61;12_137}> t2_2_2)) 1) x1_0 t1_1 t2_2_2, r_3_1 = Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> (<{Data.Set._c;61;12_134}> t3_2_3) (<{Data.Set._c;61;12_135}> t4_1_3)) 1) x2_1_1 t3_2_3 t4_1_3 in Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> (<{Data.Set._c;61;12_138}> l_3_0) (<{Data.Set._c;61;12_139}> r_3_1)) 1) x3_2_1 l_3_0 r_3_1) ) (_ -> StdMisc.abort "doubleL")
<{Data.Set._c;61;12_139}>::I !r_0 = case r_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_138}>::I !l_0 = case l_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_137}>::I !t2_0 = case t2_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_136}>::I !t1_0 = case t1_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_135}>::I !t4_0 = case t4_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_134}>::I !t3_0 = case t3_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
Data.Set.rotateL !x_0 !l_1 !r_2 = case r_2 (Data.Set.Bin _x_1_0 _x_1_1 ly_1_2 ry_1_3 -> case (<{StdInt.<_17}> (<{Data.Set._c;61;12_140}> ly_1_2) (<{StdInt.*_9}> 2 (<{Data.Set._c;61;12_141}> ry_1_3))) (True -> Data.Set.singleL x_0 l_1 r_2) (False -> Data.Set.doubleL x_0 l_1 r_2) ) (Data.Set.Tip -> StdMisc.abort "rotateL Tip") 
<{Data.Set._c;61;12_141}>::I !ry_0 = case ry_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_140}>::I !ly_0 = case ly_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
Data.Set.singleR !x1_0 !_x_1 !t3_2 = case _x_1 (Data.Set.Bin _x_1_0 x2_1_1 t1_1_2 t2_1_3 -> let r_2_0 = Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> (<{Data.Set._c;61;12_142}> t2_1_3) (<{Data.Set._c;61;12_143}> t3_2)) 1) x1_0 t2_1_3 t3_2 in Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> (<{Data.Set._c;61;12_144}> t1_1_2) (<{Data.Set._c;61;12_145}> r_2_0)) 1) x2_1_1 t1_1_2 r_2_0) (Data.Set.Tip -> StdMisc.abort "singleR") 
<{Data.Set._c;61;12_145}>::I !r_0 = case r_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_144}>::I !t1_0 = case t1_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_143}>::I !t3_0 = case t3_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_142}>::I !t2_0 = case t2_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
Data.Set.doubleR !x1_0 !_x_1 !t4_2 = case _x_1 (Data.Set.Bin _x_1_0 x2_1_1 t1_1_2 _x_1_3 -> case _x_1_3 (Data.Set.Bin _x_2_0 x3_2_1 t2_2_2 t3_2_3 -> let l_3_0 = Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> (<{Data.Set._c;61;12_148}> t1_1_2) (<{Data.Set._c;61;12_149}> t2_2_2)) 1) x2_1_1 t1_1_2 t2_2_2, r_3_1 = Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> (<{Data.Set._c;61;12_146}> t3_2_3) (<{Data.Set._c;61;12_147}> t4_2)) 1) x1_0 t3_2_3 t4_2 in Data.Set.Bin (<{StdInt.+_6}> (<{StdInt.+_6}> (<{Data.Set._c;61;12_150}> l_3_0) (<{Data.Set._c;61;12_151}> r_3_1)) 1) x3_2_1 l_3_0 r_3_1) ) (_ -> StdMisc.abort "doubleR")
<{Data.Set._c;61;12_151}>::I !r_0 = case r_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_150}>::I !l_0 = case l_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_149}>::I !t2_0 = case t2_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_148}>::I !t1_0 = case t1_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_147}>::I !t4_0 = case t4_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_146}>::I !t3_0 = case t3_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
Data.Set.rotateR !x_0 !l_1 !r_2 = case l_1 (Data.Set.Bin _x_1_0 _x_1_1 ly_1_2 ry_1_3 -> case (<{StdInt.<_17}> (<{Data.Set._c;61;12_152}> ry_1_3) (<{StdInt.*_9}> 2 (<{Data.Set._c;61;12_153}> ly_1_2))) (True -> Data.Set.singleR x_0 l_1 r_2) (False -> Data.Set.doubleR x_0 l_1 r_2) ) (Data.Set.Tip -> StdMisc.abort "rotateL Tip") 
<{Data.Set._c;61;12_153}>::I !ly_0 = case ly_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_152}>::I !ry_0 = case ry_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
Data.Set.anon_62 a_0 as_1 = _predefined._Cons a_0 as_1
Data.Set.anon_61 a_0 as_1 = _predefined._Cons a_0 as_1
<{Data.Set.==_25}>::B !<{_v==_0}> !t1_1 !t2_2 = case (<{StdInt.==_16}> (<{Data.Set._c;61;12_154}> t1_1) (<{Data.Set._c;61;12_155}> t2_2)) (True -> <{StdList.==_45}> <{_v==_0}> (Data.Set.fold Data.Set.anon_61 _predefined._Nil t1_1) (Data.Set.fold Data.Set.anon_62 _predefined._Nil t2_2)) (False -> False) 
<{Data.Set._c;61;12_155}>::I !t2_0 = case t2_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
<{Data.Set._c;61;12_154}>::I !t1_0 = case t1_0 (Data.Set.Tip -> 0) (Data.Set.Bin sz_1_0 _x_1_1 _x_1_2 _x_1_3 -> sz_1_0) 
Data.Set.anon_64 a_0 as_1 = _predefined._Cons a_0 as_1
Data.Set.anon_63 a_0 as_1 = _predefined._Cons a_0 as_1
Data.Set.compare_54::B !<{_v<_0}> !_x_1 !_x_2 = case _x_1 (_predefined._Nil -> case _x_2 (_predefined._Nil -> False) (_ -> True)) (_predefined._Cons _x_1_0 _x_1_1 -> case _x_2 (_predefined._Nil -> False) (_predefined._Cons b_2_0 bs_2_1 -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 _x_1_0 b_2_0) (True -> True) (False -> case (select <{_v<_0}>::<{StdOverloaded.<;}> 0 b_2_0 _x_1_0) (True -> False) (False -> Data.Set.compare_54 <{_v<_0}> _x_1_1 bs_2_1) ) ) ) 
<{Data.Set.<_26}>::B !<{_v<_0}> !s1_1 !s2_2 = Data.Set.compare_54 <{_v<_0}> (Data.Set.fold Data.Set.anon_63 _predefined._Nil s1_1) (Data.Set.fold Data.Set.anon_64 _predefined._Nil s2_2)
<{Data.Set.TD;Set}> _x_0::B = _predefined._Nil
<{Data.Set.TD;MaybeS}> _x_0::B = _predefined._Nil

:: Data.Set.Set = Data.Set.Tip | Data.Set.Bin !a1::I !a2 !a3 !a4
:: Data.Set.MaybeS = Data.Set.NothingS | Data.Set.JustS !a1

|| Converted Records
:: <{Data.Set.gEq_s;}> = {!Data.Set.gEq_s}

:: <{Data.Set.gEq_ss;}> = {!Data.Set.gEq_ss}

:: <{Data.Set.gEq_sss;}> = {!Data.Set.gEq_sss}

:: <{Data.Set.gEq_ssss;}> = {!Data.Set.gEq_ssss}

:: <{Data.Set.gEq_sssss;}> = {!Data.Set.gEq_sssss}

:: <{Data.Set.gEq_ssssss;}> = {!Data.Set.gEq_ssssss}

:: <{Data.Set.gEq_sssssss;}> = {!Data.Set.gEq_sssssss}

:: <{Data.Set.gEq_ssssssss;}> = {!Data.Set.gEq_ssssssss}

:: <{Data.Set.gEq_sssssssss;}> = {!Data.Set.gEq_sssssssss}

:: <{Data.Set.bimap_s;}> = {Data.Set.bimap_s}

:: <{Data.Set.bimap_ss;}> = {Data.Set.bimap_ss}

:: <{Data.Set.bimap_sss;}> = {Data.Set.bimap_sss}

